<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Separation_Algebra (Isabelle2018: August 2018)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Separation_Algebra</h1>

<span class="command">theory</span> <span class="name">Separation_Algebra</span><br/>
<span class="keyword">imports</span> <a href="Arbitrary_Comm_Monoid.html"><span class="name">Arbitrary_Comm_Monoid</span></a> <a href="Adhoc_Overloading.html"><span class="name">Adhoc_Overloading</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2014, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See &quot;LICENSE_BSD2.txt&quot; for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Authors: Gerwin Klein and Rafal Kolanski, 2012
   Maintainers: Gerwin Klein &lt;kleing at cse.unsw.edu.au&gt;
                Rafal Kolanski &lt;rafal.kolanski at nicta.com.au&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* chapter &quot;Abstract Separation Algebra&quot; *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Separation_Algebra</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Arbitrary_Comm_Monoid</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;HOL-Library.Adhoc_Overloading&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* This theory is the main abstract separation algebra development *}</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Input syntax for lifting boolean predicates to separation predicates *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_and</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; bool) &#8658; (&#39;a &#8658; bool) &#8658; &#39;a &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;and&quot;</span></span></span><span> </span><span>35</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a and b &#8801; &#955;s. a s &#8743; b s&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_or</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; bool) &#8658; (&#39;a &#8658; bool) &#8658; &#39;a &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;or&quot;</span></span></span><span> </span><span>30</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a or b &#8801; &#955;s. a s &#8744; b s&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_not</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; bool) &#8658; &#39;a &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;not _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>40</span><span class="delimiter">]</span><span> </span><span>40</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;not a &#8801; &#955;s. &#172;a s&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_imp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; bool) &#8658; (&#39;a &#8658; bool) &#8658; &#39;a &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imp&quot;</span></span></span><span> </span><span>25</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a imp b &#8801; &#955;s. a s &#10230; b s&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_K</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b &#8658; &#39;a &#8658; &#39;b&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;_&#10217;&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;f&#10217; &#8801; &#955;s. f&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_ex</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;b &#8658; &#39;a &#8658; bool) &#8658; &#39;a &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">binder</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;EXS &quot;</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;EXS x. P x &#8801; &#955;s. &#8707;x. P x s&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_all</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;b &#8658; &#39;a &#8658; bool) &#8658; &#39;a &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">binder</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ALLS &quot;</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;ALLS x. P x &#8801; &#955;s. &#8704;x. P x s&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Associative/Commutative Monoid Basis of Separation Algebras *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>pre_sep_algebra</span><span> </span><span class="delimiter">=</span><span> </span><span>zero</span><span> </span><span class="delimiter">+</span><span> </span><span>plus</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>sep_disj</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a =&gt; &#39;a =&gt; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;##&quot;</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sep_disj_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sep_disj_commuteI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y &#10233; y ## x&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sep_add_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x + 0 = x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sep_add_commute</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y &#10233; x + y = y + x&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sep_add_assoc</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; x ## y; y ## z; x ## z &#10215; &#10233; (x + y) + z = x + (y + z)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_disj_commute</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y = y ## x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sep_disj_commuteI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_add_left_commute</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a ## b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b ## c&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a ## c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b + (a + c) = a + (b + c)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?lhs = ?rhs&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?lhs = b + a + c&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_add_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>sep_disj_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;... = a + b + c&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_add_commute</span><span> </span><span>sep_disj_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;... = ?rhs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_add_assoc</span><span> </span><span>sep_disj_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>sep_add_ac</span><span> </span><span class="delimiter">=</span><span> </span><span>sep_add_assoc</span><span> </span><span>sep_add_commute</span><span> </span><span>sep_add_left_commute</span><span>
</span><span>                    </span><span>sep_disj_commute</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nearly always necessary *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Separation Algebra as Defined by Calcagno et al. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>sep_algebra</span><span> </span><span class="delimiter">=</span><span> </span><span>pre_sep_algebra</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sep_disj_addD1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; x ## y + z; y ## z &#10215; &#10233; x ## y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sep_disj_addI1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; x ## y + z; y ## z &#10215; &#10233; x + y ## z&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Basic Construct Definitions and Abbreviations *}</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Lower precedence than pred_conj, otherwise &quot;P &#8743;* Q and R&quot; is ambiguous,
 * (noting that Isabelle turns &quot;(P &#8743;* Q) and R&quot; into &quot;P &#8743;* Q and R&quot;).
 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>sep_conj</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; bool) &#8658; (&#39;a &#8658; bool) &#8658; (&#39;a &#8658; bool)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;**&quot;</span></span></span><span> </span><span>36</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;P ** Q &#8801; &#955;h. &#8707;x y. x ## y &#8743; h = x + y &#8743; P x &#8743; Q y&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span>
</span><span>  </span><span>sep_conj</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8743;*&quot;</span></span></span><span> </span><span>36</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span class="delimiter">(</span><span>latex</span><span> </span><span class="keyword2"><span class="keyword">output</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span>sep_conj</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8743;<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span></span></span><span> </span><span>36</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>sep_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#9633;&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#9633; &#8801; &#955;h. h = 0&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>sep_impl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; bool) &#8658; (&#39;a &#8658; bool) &#8658; (&#39;a &#8658; bool)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10230;*&quot;</span></span></span><span> </span><span>25</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;P &#10230;* Q &#8801; &#955;h. &#8704;h&#39;. h ## h&#39; &#8743; P h&#39; &#10230; Q (h + h&#39;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>sep_substate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8828;&quot;</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8828; y &#8801; &#8707;z. x ## z &#8743; x + z = y&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* We want these to be abbreviations not definitions, because basic True and
   False will occur by simplification in sep_conj terms *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sep_true &#8801; &#10216;True&#10217;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sep_false &#8801; &#10216;False&#10217;&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Disjunction/Addition Properties *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>disjoint_zero_sym</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 ## x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_disj_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_add_zero_sym</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 + x = x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_add_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_disj_addD2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; x ## y + z; y ## z &#10215; &#10233; x ## z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_add_commute</span><span> </span><span>sep_disj_addD1</span><span> </span><span>sep_disj_commuteI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_disj_addD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; x ## y + z; y ## z &#10215; &#10233; x ## y &#8743; x ## z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_disj_addD1</span><span> </span><span>sep_disj_addD2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_add_disjD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; x + y ## z; x ## y &#10215; &#10233; x ## z &#8743; y ## z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_disj_addD</span><span> </span><span>sep_disj_commuteI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_disj_addI2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; x ## y + z; y ## z &#10215; &#10233; x + z ## y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sep_add_commute</span><span> </span><span>sep_disj_addI1</span><span> </span><span>sep_disj_commuteI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_add_disjI1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; x + y ## z; x ## y &#10215; &#10233; x + z ## y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_add_commute</span><span> </span><span>sep_disj_addI1</span><span> </span><span>sep_disj_commuteI</span><span> </span><span>sep_add_disjD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_add_disjI2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; x + y ## z; x ## y &#10215; &#10233; z + y ## x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_add_commute</span><span> </span><span>sep_disj_addI1</span><span> </span><span>sep_disj_commuteI</span><span> </span><span>sep_add_disjD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_disj_addI3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x + y ## z &#10233; x ## y &#10233; x ## y + z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_add_commute</span><span> </span><span>sep_disj_addI1</span><span> </span><span>sep_disj_commuteI</span><span> </span><span>sep_add_disjD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_disj_add</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; y ## z; x ## y &#10215; &#10233; x ## y + z = x + y ## z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_disj_addI1</span><span> </span><span>sep_disj_addI3</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Substate Properties *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_substate_disj_add</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y &#10233; x &#8828; x + y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sep_substate_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_substate_disj_add&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y &#10233; x &#8828; y + x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_add_ac</span><span> </span><span>sep_substate_disj_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Separating Conjunction Properties *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conjD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(P &#8743;* Q) h &#10233; &#8707;x y. x ## y &#8743; h = x + y &#8743; P x &#8743; Q y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_conj_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conjE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (P ** Q) h; &#8896;x y. &#10214; P x; Q y; x ## y; h = x + y &#10215; &#10233; X &#10215; &#10233; X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_conj_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conjI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; P x; Q y; x ## y; h = x + y &#10215; &#10233; (P ** Q) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_conj_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_commuteI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(P ** Q) h &#10233; (Q ** P) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjI</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjE</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_add_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_commute</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(P ** Q) = (Q ** P)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sep_conj_commuteI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_assoc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((P ** Q) ** R) = (P ** Q ** R)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?lhs = ?rhs&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>h</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?lhs h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q y&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R z&quot;</span></span></span><span>
</span><span>                      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## z&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y ## z&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x + y ## z&quot;</span></span></span><span>
</span><span>                      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h = x + y + z&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjD</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>sep_add_disjD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y + z&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_disj_add</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?rhs h&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_add_ac</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>h</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?rhs h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q y&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R z&quot;</span></span></span><span>
</span><span>                      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## z&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y ## z&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y + z&quot;</span></span></span><span>
</span><span>                      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h = x + y + z&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjE</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_add_ac</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>sep_disj_addD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?lhs h&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_conj_def</span><span> </span><span>sep_disj_addI1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_impl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (P ** Q) h; &#8896;h. P h &#10233; P&#39; h; &#8896;h. Q h &#10233; Q&#39; h &#10215; &#10233; (P&#39; ** Q&#39;) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>sep_conjE</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_impl1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;h. P h &#10233; I h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P ** R) h &#10233; (I ** R) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sep_conj_impl</span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_globalise</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (P ** R) h; (&#8896;h. P h &#10233; Q h) &#10215; &#10233; (Q ** R) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fast</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>sep_conj_impl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_trivial_strip1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Q = R &#10233; (P ** Q) = (P ** R)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_trivial_strip2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Q = R &#10233; (Q ** P) = (R ** P)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>disjoint_subheaps_exist</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;x y. x ## y &#8743; h = x + y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>0</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_left_commute</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* for permutative rewriting *)</span></span></span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(P ** (Q ** R)) = (Q ** (P ** R))&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?x = ?y&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?x = ((Q ** R) ** P)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_conj_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = (Q ** (R ** P))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sep_conj_assoc</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_conj_commute</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>sep_conj_ac</span><span> </span><span class="delimiter">=</span><span> </span><span>sep_conj_commute</span><span> </span><span>sep_conj_assoc</span><span> </span><span>sep_conj_left_commute</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_empty_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#9633; 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_empty_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Properties of @{text sep_true} and @{text sep_false} *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_sep_true</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;P h &#10233; (P ** sep_true) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_conjI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">=</span><span>0</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_sep_true&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;P h &#10233; (sep_true ** P) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_conjI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>0</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_true</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(sep_true ** sep_true) = sep_true&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sep_conj_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>disjoint_subheaps_exist</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_false_right</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(P ** sep_false) = sep_false&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>sep_conjE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_false_left</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(sep_false ** P) = sep_false&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sep_conj_commute</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sep_conj_false_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Properties of @{const sep_empty} *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(P ** &#9633;) = P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_conj_def</span><span> </span><span>sep_empty_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_empty&#39;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#9633; ** P) = P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sep_conj_commute</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>sep_conj_empty</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_sep_emptyI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;P h &#10233; (P ** &#9633;) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_sep_emptyE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; P s; (P ** &#9633;) s &#10233; (Q ** R) s &#10215; &#10233; (Q ** R) s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Properties of top (@{text sep_true}) *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_true_P</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(sep_true ** (sep_true ** P)) = (sep_true ** P)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_conj_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_disj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((P or Q) ** R) = ((P ** R) or (Q ** R))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_conj_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_sep_true_left</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(P ** Q) h &#10233; (sep_true ** Q) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>sep_conj_impl</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_sep_true_right</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(P ** Q) h &#10233; (P ** sep_true) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>sep_conj_commute</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>sep_conj_sep_true_left</span><span class="delimiter">,</span><span>
</span><span>      </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_conj_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Separating Conjunction with Quantifiers *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_conj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((P and Q) ** R) h &#10233; ((P ** R) and (Q ** R)) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sep_conjI</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_exists1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((EXS x. P x) ** Q) = (EXS x. (P x ** Q))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sep_conjI</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>sep_conjE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_exists2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(P ** (EXS x. Q x)) = (EXS x. P ** Q x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjI</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>sep_conj_exists</span><span> </span><span class="delimiter">=</span><span> </span><span>sep_conj_exists1</span><span> </span><span>sep_conj_exists2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_spec1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((ALLS x. P x) ** Q) h &#10233; (P x ** Q) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sep_conjI</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>sep_conjE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_spec2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(P ** (ALLS x. Q x)) h &#10233; (P ** Q x) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sep_conjI</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>sep_conjE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>sep_conj_spec</span><span> </span><span class="delimiter">=</span><span> </span><span>sep_conj_spec1</span><span> </span><span>sep_conj_spec2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Properties of Separating Implication *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_implI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;h&#39;. &#10214; h ## h&#39;; P h&#39; &#10215; &#10233; Q (h + h&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P &#10230;* Q) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sep_impl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_implD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(x &#10230;* y) h &#10233; &#8704;h&#39;. h ## h&#39; &#8743; x h&#39; &#10230; y (h + h&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_impl_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_implE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(x &#10230;* y) h &#10233; (&#8704;h&#39;. h ## h&#39; &#8743; x h&#39; &#10230; y (h + h&#39;) &#10233; Q) &#10233; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>sep_implD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_impl_sep_true</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(P &#10230;* sep_true) = sep_true&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_implI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_impl_sep_false</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(sep_false &#10230;* P) = sep_true&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_implI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_impl_sep_true_P</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(sep_true &#10230;* P) h &#10233; P h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_implD</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>allE</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>0</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_impl_sep_true_false</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(sep_true &#10230;* sep_false) = sep_false&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>sep_impl_sep_true_P</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_sep_impl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; P h; &#8896;h. (P ** Q) h &#10233; R h &#10215; &#10233; (Q &#10230;* R) h&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sep_implI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>h&#39;</span><span> </span><span>h</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P h&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h ## h&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q h&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P ** Q) (h + h&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sep_conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;h. (P ** Q) h &#10233; R h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R (h + h&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_sep_impl2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (P ** Q) h; &#8896;h. P h &#10233; (Q &#10230;* R) h &#10215; &#10233; R h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>sep_implD</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>sep_conjE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_sep_impl_sep_conj2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(P ** R) h &#10233; (P ** (Q &#10230;* (Q ** R))) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>sep_conj_impl</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>sep_conj_sep_impl</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_conj_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Pure assertions *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>pure</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; bool) &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;pure P &#8801; &#8704;h h&#39;. P h = P h&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_sep_true</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;pure sep_true&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_sep_false</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;pure sep_false&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_split</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;pure P = (P = sep_true &#8744; P = sep_false)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_sep_conj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; pure P; pure Q &#10215; &#10233; pure (P &#8743;* Q)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_sep_impl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; pure P; pure Q &#10215; &#10233; pure (P &#10230;* Q)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_conj_sep_conj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (P and Q) h; pure P &#8744; pure Q &#10215; &#10233; (P &#8743;* Q) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>pure_def</span><span> </span><span>sep_add_zero</span><span> </span><span>sep_conjI</span><span> </span><span>sep_conj_commute</span><span> </span><span>sep_disj_zero</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_sep_conj_conj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (P &#8743;* Q) h; pure P; pure Q &#10215; &#10233; (P and Q) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_conj_sep_conj_assoc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;pure P &#10233; ((P and Q) &#8743;* R) = (P and (Q &#8743;* R))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_sep_impl_impl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (P &#10230;* Q) h; pure P &#10215; &#10233; P h &#10230; Q h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_split</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>sep_impl_sep_true_P</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_impl_sep_impl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; P h &#10230; Q h; pure P; pure Q &#10215; &#10233; (P &#10230;* Q) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_conj_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q &#8743;* (&#10216;P&#39;&#10217; and Q&#39;)) = (&#10216;P&#39;&#10217; and (Q &#8743;* Q&#39;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>rule</span><span class="delimiter">,</span><span> </span><span>rule</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjE</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>erule</span><span> </span><span>sep_conj_impl</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_conj_right&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q &#8743;* (P&#39; and &#10216;Q&#39;&#10217;)) = (&#10216;Q&#39;&#10217; and (Q &#8743;* P&#39;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>conj_comms</span><span> </span><span>pure_conj_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_conj_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#10216;P&#39;&#10217; and Q&#39;) &#8743;* Q) = (&#10216;P&#39;&#10217; and (Q&#39; &#8743;* Q))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_conj_right</span><span> </span><span>sep_conj_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_conj_left&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((P&#39; and &#10216;Q&#39;&#10217;) &#8743;* Q) = (&#10216;Q&#39;&#10217; and (P&#39; &#8743;* Q))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>conj_comms</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>pure_conj_left</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>pure_conj</span><span> </span><span class="delimiter">=</span><span> </span><span>pure_conj_right</span><span> </span><span>pure_conj_right&#39;</span><span> </span><span>pure_conj_left</span><span>
</span><span>    </span><span>pure_conj_left&#39;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>pure_conj</span><span class="delimiter">[</span><span>simp</span><span> </span><span>add</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Intuitionistic assertions *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>intuitionistic</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; bool) &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;intuitionistic P &#8801; &#8704;h h&#39;. P h &#8743; h &#8828; h&#39; &#10230; P h&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intuitionisticI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;h h&#39;. &#10214; P h; h &#8828; h&#39; &#10215; &#10233; P h&#39;) &#10233; intuitionistic P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>intuitionistic_def</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intuitionisticD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; intuitionistic P; P h; h &#8828; h&#39; &#10215; &#10233; P h&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>intuitionistic_def</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_intuitionistic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;pure P &#10233; intuitionistic P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>intuitionistic_def</span><span> </span><span>pure_def</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intuitionistic_conj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; intuitionistic P; intuitionistic Q &#10215; &#10233; intuitionistic (P and Q)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>intuitionisticI</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>intuitionisticD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intuitionistic_disj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; intuitionistic P; intuitionistic Q &#10215; &#10233; intuitionistic (P or Q)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>intuitionisticI</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>intuitionisticD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intuitionistic_forall</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;x. intuitionistic (P x)) &#10233; intuitionistic (ALLS x. P x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>intuitionisticI</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>intuitionisticD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intuitionistic_exists</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;x. intuitionistic (P x)) &#10233; intuitionistic (EXS x. P x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>intuitionisticI</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>intuitionisticD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intuitionistic_sep_conj_sep_true</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;intuitionistic (sep_true &#8743;* P)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>intuitionisticI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>h</span><span> </span><span>h&#39;</span><span> </span><span>r</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(sep_true &#8743;* P) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P y&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h = x + y&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xyd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>sep_conjD</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h &#8828; h&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h&#39; = h + z&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hzd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h ## z&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_substate_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P &#8743;* sep_true) (y + (x + z))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P</span><span> </span><span>h</span><span> </span><span>hzd</span><span> </span><span>xyd</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_add_disjI1</span><span> </span><span>sep_disj_commute</span><span> </span><span>sep_conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(sep_true &#8743;* P) h&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hzd</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_conj_commute</span><span> </span><span>sep_add_ac</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_disj_addD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intuitionistic_sep_impl_sep_true</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;intuitionistic (sep_true &#10230;* P)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>intuitionisticI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>h</span><span> </span><span>h&#39;</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>imp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(sep_true &#10230;* P) h&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hh&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h &#8828; h&#39;&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hh&#39;</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h&#39; = h + z&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hzd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h ## z&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_substate_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(sep_true &#10230;* P) h&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>imp</span><span> </span><span>h&#39;</span><span> </span><span>hzd</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_implD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_add_assoc</span><span> </span><span>sep_add_disjD</span><span> </span><span>sep_disj_addI3</span><span> </span><span>sep_implI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intuitionistic_sep_conj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;intuitionistic (P::(&#39;a &#8658; bool))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;intuitionistic (P &#8743;* Q)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>intuitionisticI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>h</span><span> </span><span>h&#39;</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P &#8743;* Q) h&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hh&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h &#8828; h&#39;&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hh&#39;</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h&#39; = h + z&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hzd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h ## z&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_substate_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sc</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>px</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>qy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q y&quot;</span></span></span><span>
</span><span>                       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h = x + y&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xyd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_conj_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## z&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hzd</span><span> </span><span>h</span><span> </span><span>xyd</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_add_disjD</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ip</span><span> </span><span>px</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P (x + z)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>intuitionisticD</span><span> </span><span>sep_substate_disj_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P &#8743;* Q) h&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h&#39;</span><span> </span><span>h</span><span> </span><span>hzd</span><span> </span><span>qy</span><span> </span><span>xyd</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>sep_add_commute</span><span> </span><span>sep_add_disjD</span><span> </span><span>sep_add_disjI2</span><span>
</span><span>              </span><span>sep_add_left_commute</span><span> </span><span>sep_conjI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intuitionistic_sep_impl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>iq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;intuitionistic Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;intuitionistic (P &#10230;* Q)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>intuitionisticI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>h</span><span> </span><span>h&#39;</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>imp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P &#10230;* Q) h&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hh&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h &#8828; h&#39;&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hh&#39;</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h&#39; = h + z&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hzd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h ## z&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_substate_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>px</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hzx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h + z ## x&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h + x &#8828; h + x + z&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hzx</span><span> </span><span>hzd</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_add_disjI1</span><span> </span><span>sep_substate_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>imp</span><span> </span><span>hzd</span><span> </span><span>iq</span><span> </span><span>px</span><span> </span><span>hzx</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q (h + z + x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>intuitionisticD</span><span> </span><span>sep_add_assoc</span><span> </span><span>sep_add_ac</span><span> </span><span>sep_add_disjD</span><span> </span><span>sep_implE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>imp</span><span> </span><span>h&#39;</span><span> </span><span>hzd</span><span> </span><span>iq</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P &#10230;* Q) h&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sep_implI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strongest_intuitionistic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(&#8707;Q. (&#8704;h. (Q h &#10230; (P &#8743;* sep_true) h)) &#8743; intuitionistic Q &#8743; Q &#8800; (P &#8743;* sep_true) &#8743; (&#8704;h. P h &#10230; Q h))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>sep_substate_disj_add</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjD</span><span> </span><span>intuitionisticD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weakest_intuitionistic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; (&#8707;Q. (&#8704;h. ((sep_true &#10230;* P) h &#10230; Q h)) &#8743; intuitionistic Q &#8743;
      Q &#8800; (sep_true &#10230;* P) &#8743; (&#8704;h. Q h &#10230; P h))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sep_implI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>h</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;x + h&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>intuitionisticD</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_add_ac</span><span> </span><span>sep_substate_disj_add</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intuitionistic_sep_conj_sep_true_P</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (P &#8743;* sep_true) s; intuitionistic P &#10215; &#10233; P s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>intuitionisticD</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>sep_conjE</span><span> </span><span>sep_substate_disj_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intuitionistic_sep_conj_sep_true_simp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;intuitionistic P &#10233; (P &#8743;* sep_true) = P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fast</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conj_sep_true</span><span>
</span><span>           </span><span>elim</span><span class="delimiter">:</span><span> </span><span>intuitionistic_sep_conj_sep_true_P</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intuitionistic_sep_impl_sep_true_P</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; P h; intuitionistic P &#10215; &#10233; (sep_true &#10230;* P) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_implI</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>intuitionisticD</span><span>
</span><span>            </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sep_substate_disj_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intuitionistic_sep_impl_sep_true_simp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;intuitionistic P &#10233; (sep_true &#10230;* P) = P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fast</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>sep_impl_sep_true_P</span><span> </span><span>intuitionistic_sep_impl_sep_true_P</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Strictly exact assertions *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>strictly_exact</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; bool) &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strictly_exact P &#8801; &#8704;h h&#39;. P h &#8743; P h&#39; &#10230; h = h&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strictly_exactD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; strictly_exact P; P h; P h&#39; &#10215; &#10233; h = h&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>strictly_exact_def</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strictly_exactI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;h h&#39;. &#10214; P h; P h&#39; &#10215; &#10233; h = h&#39;) &#10233; strictly_exact P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>strictly_exact_def</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strictly_exact_sep_conj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; strictly_exact P; strictly_exact Q &#10215; &#10233; strictly_exact (P &#8743;* Q)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>strictly_exactI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>sep_conjE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>h</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;xa&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>strictly_exactD</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>h</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;y&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;ya&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>strictly_exactD</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strictly_exact_conj_impl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (Q &#8743;* sep_true) h; P h; strictly_exact Q &#10215; &#10233; (Q &#8743;* (Q &#10230;* P)) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sep_conjI</span><span> </span><span>sep_implI</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>strictly_exactD</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjE</span><span>
</span><span>            </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_add_commute</span><span> </span><span>sep_add_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Separation Algebra with Stronger, but More Intuitive Disjunction Axiom *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>stronger_sep_algebra</span><span> </span><span class="delimiter">=</span><span> </span><span>pre_sep_algebra</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sep_add_disj_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y ## z &#10233; x ## y + z = (x ## y &#8743; x ## z)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_disj_add_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y &#10233; x + y ## z = (x ## z &#8743; y ## z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_add_disj_eq</span><span> </span><span>sep_disj_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>sep_algebra</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>sep</span><span class="delimiter">:</span><span> </span><span>ab_semigroup_mult</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;( ** )&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_conj_ac</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>sep</span><span class="delimiter">:</span><span> </span><span>comm_monoid</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;( ** )&quot;</span></span></span><span> </span><span>&#9633;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>sep</span><span class="delimiter">:</span><span> </span><span>comm_monoid_mult</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;( ** )&quot;</span></span></span><span> </span><span>&#9633;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Folding separating conjunction over lists and sets of predicates *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>sep_list_conj</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::sep_algebra &#8658; bool) list &#8658; (&#39;a &#8658; bool)&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sep_list_conj Ps &#8801; foldl (( ** )) &#9633; Ps&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>sep_map_list_conj</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;b &#8658; &#39;a::sep_algebra &#8658; bool) &#8658; &#39;b list &#8658; (&#39;a &#8658; bool)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sep_map_list_conj g S &#8801; sep_list_conj (map g S)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>sep_map_set_conj</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;b &#8658; &#39;a::sep_algebra &#8658; bool) &#8658; &#39;b set &#8658; (&#39;a &#8658; bool)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sep_map_set_conj g S &#8801; sep.prod g S&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>sep_set_conj</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::sep_algebra &#8658; bool) set &#8658; (&#39;a &#8658; bool)&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sep_set_conj S &#8801; sep.prod id S&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Notation. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span>
</span><span>  </span><span>sep_conj_lifted</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b &#8658; (&#39;a::sep_algebra &#8658; bool)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;* _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">]</span><span> </span><span>90</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span class="delimiter">(</span><span>latex</span><span> </span><span class="keyword2"><span class="keyword">output</span></span><span class="delimiter">)</span><span> </span><span>sep_conj_lifted</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;<span class="hidden">&#8679;</span><sup>*</sup> _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">]</span><span> </span><span>90</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span class="delimiter">(</span><span>latex</span><span> </span><span class="keyword2"><span class="keyword">output</span></span><span class="delimiter">)</span><span> </span><span>sep_map_list_conj</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;<span class="hidden">&#8679;</span><sup>*</sup> _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">]</span><span> </span><span>90</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>sep_conj_lifted</span><span> </span><span>sep_list_conj</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>sep_conj_lifted</span><span> </span><span>sep_set_conj</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME. Add notation for sep_map_list_conj, and consider unifying with sep_map_set_conj. *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Now: lots of fancy syntax. First, @{term &quot;sep_map_set_conj (%x. g) A&quot;} is written @{text&quot;&#8896;+x&#8712;A. g&quot;}. *}</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Clagged from Big_Operators. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_sep_map_set_conj&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pttrn =&gt; &#39;a set =&gt; &#39;b =&gt; &#39;b::comm_monoid_add&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(3SETSEPCONJ _:_. _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="delimiter">(</span><span>xsymbols</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_sep_map_set_conj&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pttrn =&gt; &#39;a set =&gt; &#39;b =&gt; &#39;b::comm_monoid_add&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(3&#8896;*_&#8712;_. _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="delimiter">(</span><span>HTML</span><span> </span><span class="keyword2"><span class="keyword">output</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_sep_map_set_conj&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pttrn =&gt; &#39;a set =&gt; &#39;b =&gt; &#39;b::comm_monoid_add&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(3&#8896;*_&#8712;_. _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="delimiter">(</span><span>latex</span><span> </span><span class="keyword2"><span class="keyword">output</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_sep_map_set_conj&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pttrn =&gt; &#39;a set =&gt; &#39;b =&gt; &#39;b::comm_monoid_add&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(3&#8896;<span class="hidden">&#8679;</span><sup>*</sup>(00<span class="hidden">&#8664;</span><sub>_&#8712;_<span class="hidden">&#8665;</span></sub>) _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span> </span><span class="comment">&#8213; &#8249;Beware of argument permutation!&#8250;</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;SETSEPCONJ x:A. g&quot;</span></span></span><span> </span><span class="delimiter">==</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CONST sep_map_set_conj (%x. g) A&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;* x&#8712;A. g&quot;</span></span></span><span> </span><span class="delimiter">==</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CONST sep_map_set_conj (%x. g) A&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Instead of @{term&quot;&#8896;*x&#8712;{x. P}. g&quot;} we introduce the shorter @{text&quot;&#8896;+x|P. g&quot;}. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_qsep_map_set_conj&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pttrn &#8658; bool &#8658; &#39;a &#8658; &#39;a&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(3SETSEPCONJ _ |/ _./ _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">,</span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="delimiter">(</span><span>xsymbols</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_qsep_map_set_conj&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pttrn &#8658; bool &#8658; &#39;a &#8658; &#39;a&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(3&#8896;*_ | (_)./ _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">,</span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="delimiter">(</span><span>HTML</span><span> </span><span class="keyword2"><span class="keyword">output</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_qsep_map_set_conj&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pttrn &#8658; bool &#8658; &#39;a &#8658; &#39;a&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(3&#8896;*_ | (_)./ _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">,</span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="delimiter">(</span><span>latex</span><span> </span><span class="keyword2"><span class="keyword">output</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_qsep_map_set_conj&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pttrn &#8658; bool &#8658; &#39;a &#8658; &#39;a&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(3&#8896;<span class="hidden">&#8679;</span><sup>*</sup>(00<span class="hidden">&#8664;</span><sub>_ | (_)<span class="hidden">&#8665;</span></sub>) /_)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">,</span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;SETSEPCONJ x|P. g&quot;</span></span></span><span> </span><span class="delimiter">=&gt;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CONST sep_map_set_conj (%x. g) {x. P}&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;*x|P. g&quot;</span></span></span><span> </span><span class="delimiter">=&gt;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CONST sep_map_set_conj (%x. g) {x. P}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">print_translation</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*
let
  fun setsepconj_tr&#39; [Abs (x, Tx, t), Const (@{const_syntax Collect}, _) $ Abs (y, Ty, P)] =
        if x &lt;&gt; y then raise Match
        else
          let
            val x&#39; = Syntax_Trans.mark_bound_body (x, Tx);
            val t&#39; = subst_bound (x&#39;, t);
            val P&#39; = subst_bound (x&#39;, P);
          in
            Syntax.const @{syntax_const &quot;_qsep_map_set_conj&quot;} $ Syntax_Trans.mark_bound_abs (x, Tx) $ P&#39; $ t&#39;
          end
    | setsepconj_tr&#39; _ = raise Match;
in [(@{const_syntax sep_map_set_conj}, K setsepconj_tr&#39;)] end
*}</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>sep</span><span class="delimiter">:</span><span> </span><span>folding</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8743;*)&quot;</span></span></span><span> </span><span>&#9633;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>comp_def</span><span> </span><span>sep_conj_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;* [&#9633;,P] = P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_list_conj_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;* {&#9633;} = &#9633;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_set_conj_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;* {P,&#9633;} = P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P = &#9633;&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_set_conj_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;* x&#8712;{0,1::nat}. if x=0 then &#9633; else P) = P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_sep_list_conj_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;x. x &#8712; set xs &#10233; f x = g x) &#10233; &#8896;* map f xs = &#8896;* map g xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>map_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_conj_Nil</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;* [] = &#9633;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_list_conj_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* apparently these two are rarely used and had to be removed from List.thy *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigroup</span><span class="delimiter">)</span><span> </span><span>foldl_assoc</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;foldl f (f x y) zs = f x (foldl f y zs)&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>zs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>monoid</span><span class="delimiter">)</span><span> </span><span>foldl_absorb1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;f x (foldl f z zs) = foldl f x zs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>zs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>foldl_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>comm_monoid</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldl_map_filter</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;f (foldl f z (map P (filter t xs))) (foldl f z (map P (filter (not t) xs))) = foldl f z (map P xs)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;foldl f z (map P xs) =  f (foldl f z (map P (filter t xs))) (foldl f z (map P [x&#8592;xs . &#172; t x]))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>eq_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>foldl_Cons&#39;</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x xs. foldl f z (x # xs) = f x (foldl f z xs)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>foldl_absorb1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>foldl_Cons</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>foldl_Cons&#39;</span><span> </span><span>IH</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; t x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>foldl_Cons</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>foldl_Cons&#39;</span><span> </span><span>IH</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldl_map_add</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;foldl f z (map (&#955;x. f (P x) (Q x)) xs) = f (foldl f z (map P xs)) (foldl f z (map Q xs))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>commute</span><span> </span><span>foldl_absorb1</span><span> </span><span>foldl_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldl_map_remove1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; set xs &#10233; foldl f z (map P xs) = f (P x) (foldl f z (map P (remove1 x xs)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>foldl_absorb1</span><span> </span><span>left_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_conj_Cons</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;* (x#xs) = (x ** &#8896;* xs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_list_conj_def</span><span> </span><span>sep.foldl_absorb1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_conj_append</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;* (xs @ ys) = (&#8896;* xs ** &#8896;* ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_list_conj_def</span><span> </span><span>sep.foldl_absorb1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_conj_map_append</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;* map f (xs @ ys) = (&#8896;* map f xs &#8743;* &#8896;* map f ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>map_append</span><span> </span><span>sep_list_conj_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_con_map_filter</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;* map P (filter t xs) &#8743;* &#8896;* map P (filter (not t) xs))
   = &#8896;* map P xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_list_conj_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sep.foldl_map_filter</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>union_filter</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;({x &#8712; xs. P x} &#8746; {x &#8712; xs. &#172; P x}) = xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_map_set_conj_restrict</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;finite xs &#10233;
    sep_map_set_conj P xs =
   (sep_map_set_conj P {x &#8712; xs. t x} &#8743;*
    sep_map_set_conj P {x &#8712; xs. &#172; t x})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sep.prod.union_disjoint</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>union_filter</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_conj_map_add</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;* map (&#955;x. f x &#8743;* g x) xs = (&#8896;* map f xs &#8743;* &#8896;* map g xs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_list_conj_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sep.foldl_map_add</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>filter_empty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; set xs &#10233; filter ((=) x) xs = []&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>filter_singleton</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;x &#8712; set xs; distinct xs&#10215; &#10233; [x&#39;&#8592;xs . x = x&#39;] = [x]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_empty</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove1_filter</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;distinct xs &#10233; remove1 x xs = filter (&#955;y. x &#8800; y) xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>filter_True</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_conj_map_remove1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; set xs &#10233; &#8896;* map P xs = (P x &#8743;* &#8896;* map P (remove1 x xs))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_list_conj_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>sep.foldl_map_remove1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_map_take_Suc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; length xs &#10233;
  &#8896;* map P (take (Suc i) xs) = (&#8896;* map P (take i xs) &#8743;* P (xs ! i))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>take_Suc_conv_app_nth</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_conj_map_split</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;* map f xs &#8743;* f a &#8743;* &#8896;* map f ys)
  = (&#8896;* map f (xs @ a # ys))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.map</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>map_append</span><span> </span><span>sep_list_conj_Cons</span><span> </span><span>sep_list_conj_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Separation predicates on sets&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_map_set_conj_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P = Q; xs = ys&#10215; &#10233; sep_map_set_conj P xs = sep_map_set_conj Q ys&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_set_conj_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sep_set_conj {} = &#9633;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_set_conj_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME: We should be able to pull this from the &quot;comm_monoid_big&quot;
 * or &quot;comm_monoid_add&quot; locales, but I can&#39;t work out how... *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_map_set_conj_reindex_cong</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;inj_on f A; B = f ` A; &#8896;a. a &#8712; A &#10233; g a = h (f a)&#10215;
    &#10233; sep_map_set_conj h B = sep_map_set_conj g A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep.prod.reindex</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_conj_sep_map_set_conj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;distinct xs
  &#10233; &#8896;* (map P xs) = (&#8896;* x &#8712; set xs. P x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_conj_sep_set_conj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;distinct xs; inj_on P (set xs)&#10215;
  &#10233; &#8896;* (map P xs) = &#8896;* (P ` set xs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sep_list_conj_sep_map_set_conj</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_set_conj_def</span><span> </span><span>sep.prod.reindex</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_map_set_conj_sep_list_conj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;finite A &#10233;
   &#8707;xs. set xs = A &#8743; distinct xs &#8743; sep_map_set_conj P A = &#8896;* map P xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>finite_distinct_list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>sep_list_conj_sep_map_set_conj</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_conj_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;distinct xs; distinct ys; set xs = set ys&#10215; &#10233;
  &#8896;* (map P xs) = &#8896;* (map P ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>sep_list_conj_sep_map_set_conj</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span>P</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>sep_list_conj_sep_map_set_conj</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span>P</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_conj_impl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; list_all2 (&#955;x y. &#8704;s. x s &#10230; y s) xs ys; (&#8896;* xs) s &#10215; &#10233; (&#8896;* ys) s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_all2_induct</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>sep_conj_impl</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_conj_exists</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;x. (&#8896;* map (&#955;y s. P x y s) ys) s) &#10233; ((&#8896;* map (&#955;y s. &#8707;x. P x y s) ys) s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>sep_list_conj_impl</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>list_all2I</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_zip</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_conj_map_impl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#8896;s x. &#10214;x &#8712; set xs; P x s&#10215; &#10233; Q x s; (&#8896;* map P xs) s&#10215;
  &#10233; (&#8896;* map Q xs) s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>sep_list_conj_impl</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>list_all2I</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_zip</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_map_set_conj_impl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;sep_map_set_conj P A s; &#8896;s x. &#10214;x &#8712; A; P x s&#10215; &#10233; Q x s; finite A&#10215;
  &#10233; sep_map_set_conj Q A s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>sep_map_set_conj_sep_list_conj</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span>P</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>sep_map_set_conj_sep_list_conj</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span>Q</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_list_conj_map_impl</span><span> </span><span>sep_list_conj_sep_map_set_conj</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_sub_sub</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;zs &#8838; ys&#10215; &#10233; (xs - zs) - (ys - zs) = (xs - ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_map_set_conj_sub_sub_disjoint</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;finite xs; zs &#8838; ys; ys &#8838; xs&#10215;
  &#10233; sep_map_set_conj P (xs - zs) = (sep_map_set_conj P (xs - ys) &#8743;* sep_map_set_conj P (ys - zs))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cut_tac</span><span> </span><span>sep.prod.subset_diff</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;xs-zs&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;ys-zs&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span class="delimiter">=</span><span>P</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>set_sub_sub</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldl_use_filter_map</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;foldl (&#8743;*) Q (map (&#955;x. if T x then P x else &#9633;) xs) =
   foldl (&#8743;*) Q (map P (filter T xs))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>Q</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_conj_filter_map</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;* (map (&#955;x. if T x then P x else &#9633;) xs) =
   &#8896;* (map P (filter T xs))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_list_conj_def</span><span> </span><span>foldl_use_filter_map</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_map_set_conj_restrict_predicate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;finite A &#10233; (&#8896;* x&#8712;A. if T x then P x else &#9633;) = (&#8896;* x&#8712;(Set.filter T A). P x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Set.filter_def</span><span> </span><span>sep.prod.inter_filter</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distinct_filters</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;distinct xs; &#8896;x. (f x &#8743; g x) = False&#10215; &#10233;
  set [x&#8592;xs . f x &#8744; g x] = set [x&#8592;xs . f x] &#8746; set [x&#8592;xs . g x]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_list_conj_distinct_filters</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;distinct xs; &#8896;x. (f x &#8743; g x) = False&#10215; &#10233;
  &#8896;* map P [x&#8592;xs . f x &#8744; g x] = (&#8896;* map P [x&#8592;xs . f x] &#8743;* &#8896;* map P [x&#8592;xs . g x])&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sep_list_conj_sep_map_set_conj</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_filters</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sep.prod.union_disjoint</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_map_set_conj_set_disjoint</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;finite {x. P x}; finite {x. Q x}; &#8896;x. (P x &#8743; Q x) = False&#10215;
 &#10233; sep_map_set_conj g {x. P x &#8744; Q x} =
  (sep_map_set_conj g {x. P x} &#8743;* sep_map_set_conj g {x. Q x})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sep.prod.union_disjoint</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Collect_disj_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*
  Separation algebra with positivity
  *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>positive_sep_algebra</span><span> </span><span class="delimiter">=</span><span> </span><span>stronger_sep_algebra</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sep_disj_positive</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a ## a &#10233; a + a = b &#10233; a = b&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Separation Algebra with a Cancellative Monoid *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*
  Separation algebra with a cancellative monoid. The results of being a precise
  assertion (distributivity over separating conjunction) require this.
  *}</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>cancellative_sep_algebra</span><span> </span><span class="delimiter">=</span><span> </span><span>positive_sep_algebra</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sep_add_cancelD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; x + z = y + z ; x ## z ; y ## z &#10215; &#10233; x = y&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* In any heap, there exists at most one subheap for which P holds *)</span></span></span></span></span><span>
</span><span>  </span><span>precise</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; bool) &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;precise P = (&#8704;h hp hp&#39;. hp &#8828; h &#8743; P hp &#8743; hp&#39; &#8828; h &#8743; P hp&#39; &#10230; hp = hp&#39;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;precise ((=) s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>precise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_add_cancel</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x ## z &#10233; y ## z &#10233; (x + z = y + z) = (x = y)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_add_cancelD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>precise_distribute</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;precise P = (&#8704;Q R. ((Q and R) &#8743;* P) = ((Q &#8743;* P) and (R &#8743;* P)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>pp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;precise P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Q</span><span> </span><span>R</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>h</span><span> </span><span>hp</span><span> </span><span>hp&#39;</span><span> </span><span>s</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((Q and R) &#8743;* P) s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((Q &#8743;* P) and (R &#8743;* P)) s&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjD</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>sep_conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>qs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q &#8743;* P) s&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>qr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(R &#8743;* P) s&quot;</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>qs</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sxy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s = x + y&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y&quot;</span></span></span><span>
</span><span>                           </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P y&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>qr</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x&#39;</span><span> </span><span>y&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sxy&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s = x&#39; + y&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xy&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; ## y&#39;&quot;</span></span></span><span>
</span><span>                           </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R x&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P y&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_conjD</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sxy</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ys</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8828; x + y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xy</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_substate_disj_add&#39;</span><span> </span><span>sep_disj_commute</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sxy&#39;</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ys&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#39; &#8828; x&#39; + y&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xy&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_substate_disj_add&#39;</span><span> </span><span>sep_disj_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>yy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y = y&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sxy</span><span> </span><span>sxy&#39;</span><span> </span><span>xy</span><span> </span><span>xy&#39;</span><span> </span><span>y</span><span> </span><span>y&#39;</span><span> </span><span>ys</span><span> </span><span>ys&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>precise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = x&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sxy</span><span> </span><span>sxy&#39;</span><span> </span><span>xy</span><span> </span><span>xy&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sep_add_cancelD</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((Q and R) &#8743;* P) s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sxy</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span> </span><span>yy</span><span> </span><span>y&#39;</span><span> </span><span>xy&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sep_conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((Q and R) &#8743;* P) s = ((Q &#8743;* P) and (R &#8743;* P)) s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Q R. ((Q and R) &#8743;* P) = ((Q &#8743;* P) and (R &#8743;* P))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Q R. ((Q and R) &#8743;* P) = ((Q &#8743;* P) and (R &#8743;* P))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;precise P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>precise_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>h</span><span> </span><span>hp</span><span> </span><span>hp&#39;</span><span> </span><span>Q</span><span> </span><span>R</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hp &#8828; h&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hp&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hp&#39; &#8828; h&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>php</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P hp&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>php&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P hp&#39;&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>hhp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h = hp + z&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hpz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hp ## z&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_substate_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>hhp&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h = hp&#39; + z&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hpz&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hp&#39; ## z&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hp&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_substate_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z&#39; + hp&#39; = z + hp&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hhp</span><span> </span><span>hhp&#39;</span><span> </span><span>hpz</span><span> </span><span>hpz&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_add_ac</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hhp</span><span> </span><span>hhp&#39;</span><span> </span><span>a</span><span> </span><span>hpz</span><span> </span><span>hpz&#39;</span><span> </span><span>h_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Q R. ((Q and R) &#8743;* P) (z + hp) = ((Q &#8743;* P) and (R &#8743;* P)) (z&#39; + hp&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>h_eq</span><span> </span><span>sep_add_ac</span><span> </span><span>sep_conj_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(((=) z and (=) z&#39;) &#8743;* P) (z + hp) =
           (((=) z &#8743;* P) and ((=) z&#39; &#8743;* P)) (z&#39; + hp&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;hp = hp&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>php</span><span> </span><span>php&#39;</span><span> </span><span>hpz</span><span> </span><span>hpz&#39;</span><span> </span><span>h_eq</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>iffD2</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span>
</span><span>                    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_add_ac</span><span> </span><span>sep_add_cancel</span><span> </span><span>sep_conj_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strictly_precise</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strictly_exact P &#10233; precise P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>precise_def</span><span> </span><span>strictly_exactD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_disj_positive_zero</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y &#10233; x + y = 0 &#10233; x = 0 &#8743; y = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>disjoint_zero_sym</span><span> </span><span>sep_add_cancelD</span><span> </span><span>sep_add_disjD</span><span>
</span><span>                         </span><span>sep_add_zero_sym</span><span> </span><span>sep_disj_positive</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>

</div>
</body>
</html>
