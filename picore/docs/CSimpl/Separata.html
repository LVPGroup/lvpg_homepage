<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Separata (Isabelle2018: August 2018)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Separata</h1>

<span class="command">theory</span> <span class="name">Separata</span><br/>
<span class="keyword">imports</span> <a href="Separation_Algebra.html"><span class="name">Separation_Algebra</span></a> <a href="Eisbach_Tools.html"><span class="name">Eisbach_Tools</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2016, NTU
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See &quot;LICENSE_BSD2.txt&quot; for details.
 *
 * Author: Zhe Hou, David Sanan.
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Separata</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;../lib/Sep_Algebra/Separation_Algebra&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HOL-Eisbach.Eisbach_Tools&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* The tactics in this file are a simple proof search procedure based on
the labelled sequent calculus LS\_PASL for Propositional Abstract Separation Logic 
in Zhe Hou&#39;s PhD thesis. 

We extend the tactics with a treatment for quantifiers over heaps a la Zhe Hou \&amp;
Alwen Tiu&#39;s APLAS2016 paper. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* We define a class which is an extension to cancellative\_sep\_algebra 
with other useful properties in separation algebra, including:
indivisible unit, disjointness, and cross-split. 
We also add a property about the (reverse) distributivity of the disjointness. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>heap_sep_algebra</span><span> </span><span class="delimiter">=</span><span> </span><span>cancellative_sep_algebra</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sep_add_ind_unit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;x + y = 0; x ## y&#10215; &#10233; x = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sep_add_disj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x##x &#10233;x= 0 &quot;</span></span></span><span>   
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sep_add_cross_split</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;a + b = w; c + d = w; a ## b; c ## d&#10215; &#10233;
       &#8707; e f g h. e + f = a &#8743; g + h = b &#8743; e + g = c &#8743; f + h = d &#8743; 
                  e ## f &#8743; g ## h &#8743; e ## g &#8743; f ## h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>disj_dstri</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;x ## y; y ## z; x ## z&#10215; &#10233; x ## (y + z)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Lemmas about the labelled sequent calculus. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* An abbreviation of the + and \#\# operators in Separation\_Algebra.thy. 
This notion is closer to the ternary relational atoms used in the literature. 
This will be the main data structure which our labelled sequent calculus works on. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tern_rel</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a &#8658; &#39;a &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(_,_&#9657;_)&quot;</span></span></span><span> </span><span>25</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(a,b&#9657;c) &#8801; a ## b &#8743; a + b = c&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exist_comb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y &#10233; &#8707;z. (x,y&#9657;z)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>disj_comb</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x,y&#9657;z)&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## w&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y ## w&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z ## w&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x ## y &#8743; x + y = z&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>a3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.disj_dstri</span><span> </span><span>local.sep_disj_commuteI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>      
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* The following lemmas corresponds to inference rules in LS\_PASL. 
Thus these lemmas prove the soundness of LS\_PASL. 
We also show the invertibility of those rules. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_id</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (A h) &#10233; (A h) &#8744; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_botl</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (sep_false h) &#10233; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_topr</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#10233; (sep_true h) &#8744; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_empl</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h = 0) &#10230; Delta &#10233; 
 Gamma &#8743; (sep_empty h) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.sep_empty_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_empl_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (sep_empty h) &#10230; Delta &#10233;  
 Gamma &#8743; (h = 0) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* The following two lemmas are the same as applying 
simp add: sep\_empty\_def. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_empl_der</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sep_empty h &#10233; h = 0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.sep_empty_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_empl_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(sep_empty h) = (h = 0)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.sep_empty_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_empr</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#10230; (sep_empty 0) &#8744; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_notl</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#10230; (A h) &#8744; Delta &#10233; 
 Gamma &#8743; ((not A) h) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_notl_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; ((not A) h) &#10230; Delta &#10233;
 Gamma &#10230; (A h) &#8744; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_notr</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (A h) &#10230; Delta &#10233; 
 Gamma &#10230; ((not A) h) &#8744; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_notr_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#10230; ((not A) h) &#8744; Delta &#10233;
 Gamma &#8743; (A h) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_andl</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (A h) &#8743; (B h) &#10230; Delta &#10233; 
 Gamma &#8743; ((A and B) h) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_andl_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; ((A and B) h) &#10230; Delta &#10233; 
 Gamma &#8743; (A h) &#8743; (B h) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_andr</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;Gamma &#10230; (A h) &#8744; Delta; Gamma &#10230; (B h) &#8744; Delta&#10215; &#10233;
 Gamma &#10230; ((A and B) h) &#8744; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_andr_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#10230; ((A and B) h) &#8744; Delta &#10233;
 (Gamma &#10230; (A h) &#8744; Delta) &#8743; (Gamma &#10230; (B h) &#8744; Delta)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_orl</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;Gamma &#8743; (A h) &#10230; Delta; Gamma &#8743; (B h) &#10230; Delta&#10215; &#10233;
 Gamma &#8743; (A or B) h &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_orl_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (A or B) h &#10230; Delta &#10233;
 (Gamma &#8743; (A h) &#10230; Delta) &#8743; (Gamma &#8743; (B h) &#10230; Delta)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_orr</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#10230; (A h) &#8744; (B h) &#8744; Delta &#10233;
 Gamma &#10230; ((A or B) h) &#8744; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_orr_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#10230; ((A or B) h) &#8744; Delta &#10233;
 Gamma &#10230; (A h) &#8744; (B h) &#8744; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_impl</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;Gamma &#10230; (A h) &#8744; Delta; Gamma &#8743; (B h) &#10230; Delta&#10215; &#10233;
 Gamma &#8743; ((A imp B) h) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_impl_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; ((A imp B) h) &#10230; Delta &#10233;
 (Gamma &#10230; (A h) &#8744; Delta) &#8743; (Gamma &#8743; (B h) &#10230; Delta)&quot;</span></span></span><span>    
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_impr</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (A h) &#10230; (B h) &#8744; Delta &#10233;
 Gamma &#10230; ((A imp B) h) &#8744; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_impr_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#10230; ((A imp B) h) &#8744; Delta &#10233;
 Gamma &#8743; (A h) &#10230; (B h) &#8744; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* We don&#39;t provide lemmas for derivations for the classical connectives,
as Isabelle proof methods can easily deal with them. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_starl</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;h1 h2. (Gamma &#8743; (h1,h2&#9657;h0) &#8743; (A h1) &#8743; (B h2))) &#10230; Delta &#10233;
 Gamma &#8743; ((A ** B) h0) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.sep_conj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_starl_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; ((A ** B) h0) &#10230; Delta &#10233;
 (&#8707;h1 h2. (Gamma &#8743; (h1,h2&#9657;h0) &#8743; (A h1) &#8743; (B h2))) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.sep_conjI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_starl_der</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;((A ** B) h0) &#10233; (&#8707;h1 h2. (h1,h2&#9657;h0) &#8743; (A h1) &#8743; (B h2))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>lspasl_starl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_starl_eq</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;((A ** B) h0) = (&#8707;h1 h2. (h1,h2&#9657;h0) &#8743; (A h1) &#8743; (B h2))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>lspasl_starl</span><span> </span><span>lspasl_starl_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_starr</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;Gamma &#8743; (h1,h2&#9657;h0) &#10230; (A h1) &#8744; ((A ** B) h0) &#8744; Delta; 
  Gamma &#8743; (h1,h2&#9657;h0) &#10230; (B h2) &#8744; ((A ** B) h0) &#8744; Delta&#10215; &#10233;
 Gamma &#8743; (h1,h2&#9657;h0) &#10230; ((A ** B) h0) &#8744; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.sep_conjI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_starr_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;h0) &#10230; ((A ** B) h0) &#8744; Delta &#10233; 
 (Gamma &#8743; (h1,h2&#9657;h0) &#10230; (A h1) &#8744; ((A ** B) h0) &#8744; Delta) &#8743; 
 (Gamma &#8743; (h1,h2&#9657;h0) &#10230; (B h2) &#8744; ((A ** B) h0) &#8744; Delta)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* For efficiency we only apply *R on a pair of a ternary relational atom
and a formula ONCE. To achieve this, we create a special predicate to indicate that
a pair of a ternary relational atom and a formula has already been used in
a *R application. 
Note that the predicate is true even if the *R rule hasn&#39;t been applied. 
We will not infer the truth of this predicate in proof search, but only
check its syntactical appearance, which is only generated by the lemma lspasl\_starr\_der. 
We need to ensure that this predicate is not generated elsewhere
in the proof search. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>starr_applied</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a &#8658; &#39;a &#8658; (&#39;a &#8658; bool) &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;starr_applied h1 h2 h0 F &#8801; (h1,h2&#9657;h0) &#8743; &#172;(F h0)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_starr_der</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0) &#10233; &#172; ((A ** B) h0) &#10233; 
  ((h1,h2&#9657;h0) &#8743; &#172; ((A h1) &#8744; ((A ** B) h0)) &#8743; (starr_applied h1 h2 h0 (A ** B))) &#8744; 
  ((h1,h2&#9657;h0) &#8743; &#172; ((B h2) &#8744; ((A ** B) h0)) &#8743; (starr_applied h1 h2 h0 (A ** B)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lspasl_starl_eq</span><span> </span><span>starr_applied_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_starr_der2</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0) &#10233; &#172; ((A ** B) h0) &#10233; 
  ((h1,h2&#9657;h0) &#8743; &#172; ((A h2) &#8744; ((A ** B) h0)) &#8743; (starr_applied h2 h1 h0 (A ** B))) &#8744; 
  ((h1,h2&#9657;h0) &#8743; &#172; ((B h1) &#8744; ((A ** B) h0)) &#8743; (starr_applied h2 h1 h0 (A ** B)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.sep_add_commute</span><span> </span><span>local.sep_disj_commute</span><span> </span><span>lspasl_starr_der</span><span> </span><span>tern_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_starr_eq</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;((h1,h2&#9657;h0) &#8743; &#172; ((A ** B) h0)) = 
  (((h1,h2&#9657;h0) &#8743; &#172; ((A h1) &#8744; ((A ** B) h0))) &#8744; ((h1,h2&#9657;h0) &#8743; &#172; ((B h2) &#8744; ((A ** B) h0))))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_starr_der</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_magicl</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;Gamma &#8743; (h1,h2&#9657;h0) &#8743; ((A &#10230;* B) h2) &#10230; (A h1) &#8744; Delta;
  Gamma &#8743; (h1,h2&#9657;h0) &#8743; ((A &#10230;* B) h2) &#8743; (B h0) &#10230; Delta&#10215; &#10233;
 Gamma &#8743; (h1,h2&#9657;h0) &#8743; ((A &#10230;* B) h2) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.sep_add_commute</span><span> </span><span>local.sep_disj_commuteI</span><span> </span><span>local.sep_implD</span><span> </span><span>tern_rel_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_magicl_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;h0) &#8743; ((A &#10230;* B) h2) &#10230; Delta &#10233;
 (Gamma &#8743; (h1,h2&#9657;h0) &#8743; ((A &#10230;* B) h2) &#10230; (A h1) &#8744; Delta) &#8743; 
 (Gamma &#8743; (h1,h2&#9657;h0) &#8743; ((A &#10230;* B) h2) &#8743; (B h0) &#10230; Delta)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* For efficiency we only apply -*L on a pair of a ternary relational atom
and a formula ONCE. To achieve this, we create a special predicate to indicate that
a pair of a ternary relational atom and a formula has already been used in
a *R application. 
Note that the predicate is true even if the *R rule hasn&#39;t been applied. 
We will not infer the truth of this predicate in proof search, but only
check its syntactical appearance, which is only generated by the lemma lspasl\_magicl\_der.
We need to ensure that in the proof search of Separata, this predicate is 
not generated elsewhere.*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>magicl_applied</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a &#8658; &#39;a &#8658; (&#39;a &#8658; bool) &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;magicl_applied h1 h2 h0 F &#8801; (h1,h2&#9657;h0) &#8743; (F h2)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_magicl_der</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0) &#10233; ((A &#10230;* B) h2) &#10233;
  ((h1,h2&#9657;h0) &#8743; &#172;(A h1) &#8743; ((A &#10230;* B) h2) &#8743; (magicl_applied h1 h2 h0 (A &#10230;* B))) &#8744; 
  ((h1,h2&#9657;h0) &#8743; (B h0) &#8743; ((A &#10230;* B) h2) &#8743; (magicl_applied h1 h2 h0 (A &#10230;* B)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>lspasl_magicl</span><span> </span><span>magicl_applied_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_magicl_der2</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(h2,h1&#9657;h0) &#10233; ((A &#10230;* B) h2) &#10233;
  ((h2,h1&#9657;h0) &#8743; &#172;(A h1) &#8743; ((A &#10230;* B) h2) &#8743; (magicl_applied h1 h2 h0 (A &#10230;* B))) &#8744; 
  ((h2,h1&#9657;h0) &#8743; (B h0) &#8743; ((A &#10230;* B) h2) &#8743; (magicl_applied h1 h2 h0 (A &#10230;* B)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.sep_add_commute</span><span> </span><span>local.sep_disj_commuteI</span><span> </span><span>local.sep_implD</span><span> </span><span>magicl_applied_def</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_magicl_eq</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;((h1,h2&#9657;h0) &#8743; ((A &#10230;* B) h2)) =
  (((h1,h2&#9657;h0) &#8743; &#172;(A h1) &#8743; ((A &#10230;* B) h2)) &#8744; ((h1,h2&#9657;h0) &#8743; (B h0) &#8743; ((A &#10230;* B) h2)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_magicl_der</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_magicr</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;h1 h0. Gamma &#8743; (h1,h2&#9657;h0) &#8743; (A h1) &#8743; ((not B) h0)) &#10230; Delta &#10233;
 Gamma &#10230; ((A &#10230;* B) h2) &#8744; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.sep_add_commute</span><span> </span><span>local.sep_disj_commute</span><span> </span><span>local.sep_impl_def</span><span> </span><span>tern_rel_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_magicr_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#10230; ((A &#10230;* B) h2) &#8744; Delta &#10233;
 (&#8707;h1 h0. Gamma &#8743; (h1,h2&#9657;h0) &#8743; (A h1) &#8743; ((not B) h0)) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>lspasl_magicl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_magicr_der</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#172; ((A &#10230;* B) h2) &#10233; 
 (&#8707;h1 h0. (h1,h2&#9657;h0) &#8743; (A h1) &#8743; ((not B) h0))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>lspasl_magicr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_magicr_eq</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#172; ((A &#10230;* B) h2)) = 
 ((&#8707;h1 h0. (h1,h2&#9657;h0) &#8743; (A h1) &#8743; ((not B) h0)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>lspasl_magicl</span><span> </span><span>lspasl_magicr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_eq</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (0,h2&#9657;h2) &#8743; h1 = h2 &#10230; Delta &#10233;
 Gamma &#8743; (0,h1&#9657;h2) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_eq_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (0,h1&#9657;h2) &#10230; Delta &#10233;
 Gamma &#8743; (0,h2&#9657;h2) &#8743; h1 = h2 &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_eq_der</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(0,h1&#9657;h2) &#10233; ((0,h1&#9657;h1) &#8743; h1 = h2)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_eq_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(0,h1&#9657;h2) = ((0,h1&#9657;h1) &#8743; (h1 = h2))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_eq2</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h2,0&#9657;h2) &#8743; h1 = h2 &#10230; Delta &#10233;
 Gamma &#8743; (h1,0&#9657;h2) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_eq_inv2</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,0&#9657;h2) &#10230; Delta &#10233;
 Gamma &#8743; (h2,0&#9657;h2) &#8743; h1 = h2 &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_eq_der2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h1,0&#9657;h2) &#10233; ((h1,0&#9657;h1) &#8743; h1 = h2)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_eq2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_eq_eq2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h1,0&#9657;h2) = ((h1,0&#9657;h1) &#8743; (h1 = h2))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_u</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h,0&#9657;h) &#10230; Delta &#10233;
 Gamma &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_u_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#10230; Delta &#10233;
 Gamma &#8743; (h,0&#9657;h) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_u_der</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h,0&#9657;h)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_e</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h0) &#10230; Delta &#10233;
 Gamma &#8743; (h1,h2&#9657;h0) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.sep_add_commute</span><span> </span><span>local.sep_disj_commute</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_e_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;h0) &#10230; Delta &#10233;
 Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h0) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_e_der</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0) &#10233; (h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h0)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_e</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>           
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_e_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0) = ((h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h0))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_e</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_a_der</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h3,h4&#9657;h1)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;h5. (h3,h5&#9657;h0) &#8743; (h2,h4&#9657;h5) &#8743; (h1,h2&#9657;h0) &#8743; (h3,h4&#9657;h1))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h1 ## h2&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h3 ## h4&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h3 + h4 = h1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h3 ## h2&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.sep_disj_addD1</span><span> </span><span>local.sep_disj_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h2 ## h3&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.sep_disj_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h2 + h4 ## h3&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>local.sep_add_commute</span><span> </span><span>local.sep_add_disjI1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h4 ## h2&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.sep_add_commute</span><span> </span><span>local.sep_disj_addD1</span><span> </span><span>local.sep_disj_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f5</span><span> </span><span>f4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>assms</span><span> </span><span>tern_rel_def</span><span> </span><span>local.sep_add_assoc</span><span> </span><span>local.sep_add_commute</span><span> </span><span>local.sep_disj_commute</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_a</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;h5. Gamma &#8743; (h3,h5&#9657;h0) &#8743; (h2,h4&#9657;h5) &#8743; (h1,h2&#9657;h0) &#8743; (h3,h4&#9657;h1)) &#10230; Delta &#10233;
 Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h3,h4&#9657;h1) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_a_der</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_a_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h3,h4&#9657;h1) &#10230; Delta &#10233;
 (&#8707;h5. Gamma &#8743; (h3,h5&#9657;h0) &#8743; (h2,h4&#9657;h5) &#8743; (h1,h2&#9657;h0) &#8743; (h3,h4&#9657;h1)) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_a_eq</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;((h1,h2&#9657;h0) &#8743; (h3,h4&#9657;h1)) = 
 (&#8707;h5. (h3,h5&#9657;h0) &#8743; (h2,h4&#9657;h5) &#8743; (h1,h2&#9657;h0) &#8743; (h3,h4&#9657;h1))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_a_der</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_p</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;h0) &#8743; h0 = h3 &#10230; Delta &#10233;
 Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h1,h2&#9657;h3) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_p_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h1,h2&#9657;h3) &#10230; Delta &#10233;
 Gamma &#8743; (h1,h2&#9657;h0) &#8743; h0 = h3 &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_p_der</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0) &#10233; (h1,h2&#9657;h3) &#10233; (h1,h2&#9657;h0) &#8743; h0 = h3&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_p_eq</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;((h1,h2&#9657;h0) &#8743; (h1,h2&#9657;h3)) = ((h1,h2&#9657;h0) &#8743; h0 = h3)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_p_der</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_p2</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h0) &#8743; h0 = h3 &#10230; Delta &#10233;
 Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h3) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_e_der</span><span> </span><span>lspasl_p_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_p_inv2</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h3) &#10230; Delta &#10233;
 Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h0) &#8743; h0 = h3 &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_p_der2</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0) &#10233; (h2,h1&#9657;h3) &#10233; (h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h0) &#8743; h0 = h3&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_e_der</span><span> </span><span>lspasl_p_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_p_eq2</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;((h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h3)) = ((h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h0) &#8743; h0 = h3)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_p_der</span><span> </span><span>lspasl_e_der</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;h0) &#8743; h2 = h3 &#10230; Delta &#10233;
 Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h1,h3&#9657;h0) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.sep_add_cancelD</span><span> </span><span>local.sep_add_commute</span><span> </span><span>tern_rel_def</span><span>
</span><span>local.sep_disj_commuteI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h1,h3&#9657;h0) &#10230; Delta &#10233;
 Gamma &#8743; (h1,h2&#9657;h0) &#8743; h2 = h3 &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c_der</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0) &#10233; (h1,h3&#9657;h0) &#10233; (h1,h2&#9657;h0) &#8743; h2 = h3&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c_eq</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;((h1,h2&#9657;h0) &#8743; (h1,h3&#9657;h0)) = ((h1,h2&#9657;h0) &#8743; h2 = h3)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_c_der</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c2</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h0) &#8743; h2 = h3 &#10230; Delta &#10233;
 Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h3,h1&#9657;h0) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.sep_add_cancelD</span><span> </span><span>local.sep_add_commute</span><span> </span><span>tern_rel_def</span><span>
</span><span>local.sep_disj_commuteI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c_inv2</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h3,h1&#9657;h0) &#10230; Delta &#10233;
 Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h0) &#8743; h2 = h3 &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c_der2</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0) &#10233; (h3,h1&#9657;h0) &#10233; (h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h0) &#8743; h2 = h3&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_c2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c_eq2</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;((h1,h2&#9657;h0) &#8743; (h3,h1&#9657;h0)) = ((h1,h2&#9657;h0) &#8743; (h2,h1&#9657;h0) &#8743; h2 = h3)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_c_der</span><span> </span><span>lspasl_e_der</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c3</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h2,h1&#9657;h0) &#8743; (h1,h2&#9657;h0) &#8743; h2 = h3 &#10230; Delta &#10233;
 Gamma &#8743; (h2,h1&#9657;h0) &#8743; (h1,h3&#9657;h0) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.sep_add_cancelD</span><span> </span><span>local.sep_add_commute</span><span> </span><span>tern_rel_def</span><span>
</span><span>local.sep_disj_commuteI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c_inv3</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h2,h1&#9657;h0) &#8743; (h1,h3&#9657;h0) &#10230; Delta &#10233;
 Gamma &#8743; (h2,h1&#9657;h0) &#8743; (h1,h2&#9657;h0) &#8743; h2 = h3 &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c_der3</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(h2,h1&#9657;h0) &#10233; (h1,h3&#9657;h0) &#10233; (h2,h1&#9657;h0) &#8743; (h1,h2&#9657;h0) &#8743; h2 = h3&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_c3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c_eq3</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;((h2,h1&#9657;h0) &#8743; (h1,h3&#9657;h0)) = ((h2,h1&#9657;h0) &#8743; (h1,h2&#9657;h0) &#8743; h2 = h3)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_c_der3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c4</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h2,h1&#9657;h0) &#8743; h2 = h3 &#10230; Delta &#10233;
 Gamma &#8743; (h2,h1&#9657;h0) &#8743; (h3,h1&#9657;h0) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.sep_add_cancelD</span><span>  </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c_inv4</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h2,h1&#9657;h0) &#8743; (h3,h1&#9657;h0) &#10230; Delta &#10233;
 Gamma &#8743; (h2,h1&#9657;h0) &#8743; h2 = h3 &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c_der4</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(h2,h1&#9657;h0) &#10233; (h3,h1&#9657;h0) &#10233; (h2,h1&#9657;h0) &#8743; h2 = h3&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_c4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_c_eq4</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;((h2,h1&#9657;h0) &#8743; (h3,h1&#9657;h0)) = ((h2,h1&#9657;h0) &#8743; h2 = h3)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_c_der4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_iu</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (0,h2&#9657;0) &#8743; h1 = 0 &#10230; Delta &#10233;
 Gamma &#8743; (h1,h2&#9657;0) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.sep_add_ind_unit</span><span> </span><span>tern_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_iu_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;0) &#10230; Delta &#10233;
 Gamma &#8743; (0,h2&#9657;0) &#8743; h1 = 0 &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_iu_der</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;0) &#10233; ((0,0&#9657;0) &#8743; h1 = 0 &#8743; h2 = 0)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_eq_der</span><span> </span><span>lspasl_iu</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_iu_eq</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;0) = ((0,0&#9657;0) &#8743; h1 = 0 &#8743; h2 = 0)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_iu_der</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_d</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (0,0&#9657;h2) &#8743; h1 = 0 &#10230; Delta &#10233;
 Gamma &#8743; (h1,h1&#9657;h2) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.sep_add_disj</span><span> </span><span>tern_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_d_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h1&#9657;h2) &#10230; Delta &#10233;
 Gamma &#8743; (0,0&#9657;h2) &#8743; h1 = 0 &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_d_der</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h1&#9657;h2) &#10233; (0,0&#9657;0) &#8743; h1 = 0 &#8743; h2 = 0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_d</span><span> </span><span>lspasl_eq_der</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_d_eq</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h1&#9657;h2) = ((0,0&#9657;0) &#8743; h1 = 0 &#8743; h2 = 0)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_d_der</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_cs_der</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h3,h4&#9657;h0)&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;h5 h6 h7 h8. (h5,h6&#9657;h1) &#8743; (h7,h8&#9657;h2) &#8743;(h5,h7&#9657;h3) &#8743; (h6,h8&#9657;h4)
        &#8743; (h1,h2&#9657;h0) &#8743; (h3,h4&#9657;h0))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h1 + h2 = h0 &#8743; h3 + h4 = h0 &#8743; h1 ## h2 &#8743; h3 ## h4&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;h5 h6 h7 h8. h5 + h6 = h1 &#8743; h7 + h8 = h2 &#8743;
    h5 + h7 = h3 &#8743; h6 + h8 = h4 &#8743; h5 ## h6 &#8743; h7 ## h8 &#8743;
    h5 ## h7 &#8743; h6 ## h8&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.sep_add_cross_split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;h5 h6 h7 h8. (h5,h6&#9657;h1) &#8743; h7 + h8 = h2 &#8743;
    h5 + h7 = h3 &#8743; h6 + h8 = h4 &#8743; h7 ## h8 &#8743;
    h5 ## h7 &#8743; h6 ## h8&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;h5 h6 h7 h8. (h5,h6&#9657;h1) &#8743; (h7,h8&#9657;h2) &#8743;
    h5 + h7 = h3 &#8743; h6 + h8 = h4 &#8743; h5 ## h7 &#8743; h6 ## h8&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;h5 h6 h7 h8. (h5,h6&#9657;h1) &#8743; (h7,h8&#9657;h2) &#8743;
    (h5,h7&#9657;h3) &#8743; h6 + h8 = h4 &#8743; h6 ## h8&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tern_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>tern_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_cs</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;h5 h6 h7 h8. Gamma &#8743; (h5,h6&#9657;h1) &#8743; (h7,h8&#9657;h2) &#8743;(h5,h7&#9657;h3) &#8743; (h6,h8&#9657;h4) &#8743; (h1,h2&#9657;h0) &#8743; (h3,h4&#9657;h0)) &#10230; Delta &#10233;
 Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h3,h4&#9657;h0) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_cs_der</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_cs_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;Gamma &#8743; (h1,h2&#9657;h0) &#8743; (h3,h4&#9657;h0) &#10230; Delta &#10233;
 (&#8707;h5 h6 h7 h8. Gamma &#8743; (h5,h6&#9657;h1) &#8743; (h7,h8&#9657;h2) &#8743;(h5,h7&#9657;h3) &#8743; (h6,h8&#9657;h4) &#8743; (h1,h2&#9657;h0) &#8743; (h3,h4&#9657;h0)) &#10230; Delta&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lspasl_cs_eq</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;((h1,h2&#9657;h0) &#8743; (h3,h4&#9657;h0)) =
 (&#8707;h5 h6 h7 h8. (h5,h6&#9657;h1) &#8743; (h7,h8&#9657;h2) &#8743;(h5,h7&#9657;h3) &#8743; (h6,h8&#9657;h4) &#8743; 
  (h1,h2&#9657;h0) &#8743; (h3,h4&#9657;h0))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_cs_der</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* This section extends separata with treatments for quantifiers over 
heaps. This is similar to the modalities [] and &lt;&gt; we used in our APLAS2016 
paper. Here we use /\ h. A h be mean that h is universally quantified, which 
is h: []A in the APLAS2016 paper. Similarly, Formulae like this are frequently used in seL4&#39;s proofs. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lsfasl_boxl_der</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;h. A h) &#10233; &#8704;h. A h&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* The above proves the soundness and invertibility of LS\_PASL. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Lemmas David proved for separation algebra. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_substate_tran</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8828; y &#8743; y &#8828; z &#10233; x &#8828; z&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sep_substate_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;z. x ## z &#8743; x + z = y) &#8743; (&#8707;za. y ## za &#8743; y + za = z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x&#39;</span><span> </span><span>y&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span>fixed</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(x ## x&#39; &#8743; x + x&#39; = y) &#8743; (y ## y&#39; &#8743; y + y&#39; = z)&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>disj_x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x ## y&#39; &#8743; x&#39; ## y&#39;&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sep_disj_addD</span><span> </span><span>sep_disj_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x ## (x&#39; + y&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fixed</span><span> </span><span>sep_disj_commute</span><span> </span><span>sep_disj_addI3</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x + (x&#39; + y&#39;) = z&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disj_x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>fixed</span><span> </span><span>sep_add_assoc</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;za. x ## za &#8743; x + za = z&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>precise_sep_conj</span><span class="delimiter">:</span><span> 
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;precise I&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;precise I&#39;&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;precise (I &#8743;* I&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>  </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>precise_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>hp</span><span> </span><span>hp&#39;</span><span> </span><span>h</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;hp &#8828; h&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hp&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hp&#39; &#8828; h&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ihp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(I &#8743;* I&#39;) hp&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ihp&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(I &#8743;* I&#39;) hp&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>hp1</span><span> </span><span>hp2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ihpex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hp1 ## hp2 &#8743; hp = hp1 + hp2 &#8743; I hp1 &#8743; I&#39; hp2&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ihp</span><span> </span><span>sep_conjD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>hp1&#39;</span><span> </span><span>hp2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ihpex&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hp1&#39; ## hp2&#39; &#8743; hp&#39; = hp1&#39; + hp2&#39; &#8743; I hp1&#39; &#8743; I&#39; hp2&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ihp&#39;</span><span> </span><span>sep_conjD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hp2&#39; ## hp1&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ihpex&#39;</span><span> </span><span>sep_disj_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hp2 ## hp1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ihpex</span><span> </span><span>sep_disj_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f5</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a. &#172; a &#8828; hp &#8744; a &#8828; h&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hp</span><span> </span><span>sep_substate_tran</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f6</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a. &#172; a &#8828; hp&#39; &#8744; a &#8828; h&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hp&#39;</span><span> </span><span>sep_substate_tran</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>    
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hp = hp&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>f3</span><span> </span><span>f5</span><span> </span><span>a2</span><span> </span><span>a1</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>ihpex</span><span> </span><span>ihpex&#39;</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>precise_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sep_add_commute</span><span> </span><span>sep_substate_disj_add&#39;</span><span class="delimiter">)</span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unique_subheap</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#963;1,&#963;2&#9657;&#963;) &#10233; &#8707;!&#963;2&#39;.(&#963;1,&#963;2&#39;&#9657;&#963;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lspasl_c_der</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_split_substate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#963;1, &#963;2&#9657; &#963;) &#10233; 
   (&#963;1  &#8828; &#963;) &#8743; (&#963;2  &#8828; &#963;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#963;1, &#963;2&#9657; &#963;)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#963;1  &#8828; &#963;) &#8743; (&#963;2  &#8828; &#963;)&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_disj_commute</span><span> 
</span><span>       </span><span>tern_rel_def</span><span> 
</span><span>      </span><span>sep_substate_disj_add</span><span> 
</span><span>      </span><span>sep_substate_disj_add&#39;</span><span class="delimiter">)</span><span>   
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>sep_septraction</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;a::sep_algebra) &#8658; bool) &#8658; (&#39;a &#8658; bool) &#8658; (&#39;a &#8658; bool)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10230;&#8853;&quot;</span></span></span><span> </span><span>25</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;P &#10230;&#8853; Q &#8801;  not (P &#10230;* not Q)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Below we integrate the inference rules in proof search. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_empl</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">[</span><span>thin</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sep_empty ?h&quot;</span></span></span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;insert lspasl_empl_der[OF P]&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_starl</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">[</span><span>thin</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(?A ** ?B) ?h&quot;</span></span></span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;insert lspasl_starl_der[OF P], auto&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_magicr</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">[</span><span>thin</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(?A &#10230;* ?B) ?h&quot;</span></span></span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;insert lspasl_magicr_der[OF P], auto&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Only apply the rule Eq on (0,h1,h2) where h1 and h2
are not syntactically the same. 
Note that we build commutativity in this rule application. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_eq</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">[</span><span>thin</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(0,?h1&#9657;?h2)&quot;</span></span></span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match P in 
    &quot;(0,h&#9657;h)&quot; for h &#8658; &#8249;fail&#8250;     
    &#166;_ &#8658; &#8249;insert lspasl_eq_der[OF P], auto&#8250;&#8250;</span></span></span><span>
</span><span class="delimiter">&#166;</span><span> </span><span>P&#39;</span><span class="delimiter">[</span><span>thin</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?h1,0&#9657;?h2)&quot;</span></span></span><span> </span><span class="delimiter">&#8658;</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match P&#39; in
    &quot;(h,0&#9657;h)&quot; for h &#8658; &#8249;fail&#8250;
    &#166;_ &#8658; &#8249;insert lspasl_eq_der2[OF P&#39;], auto&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* We restrict that the rule IU can&#39;t be applied 
on (0,0,0). *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_iu</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">[</span><span>thin</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(?h1,?h2&#9657;0)&quot;</span></span></span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match P in
    &quot;(0,0&#9657;0)&quot; &#8658; &#8249;fail&#8250;
    &#166;_ &#8658; &#8249;insert lspasl_iu_der[OF P], auto&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* We restrict that the rule D can&#39;t be applied 
on (0,0,0). *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_d</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">[</span><span>thin</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h1&#9657;h2)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match P in 
    &quot;(0,0&#9657;0)&quot; &#8658; &#8249;fail&#8250;
    &#166;_ &#8658; &#8249;insert lspasl_d_der[OF P], auto&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* We restrict that the rule P can&#39;t be applied to
two syntactically identical ternary relational atoms. 
Note that we build communtativity in this rule application. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_p</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">[</span><span>thin</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h0</span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in &quot;(h1,h2&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
  &#166;&quot;(h2,h1&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
  &#166;P&#39;[thin]:&quot;(h1,h2&#9657;?h3)&quot; &#8658; &#8249;insert lspasl_p_der[OF P P&#39;], auto&#8250;
  &#166;P&#39;&#39;[thin]:&quot;(h2,h1&#9657;?h3)&quot; &#8658; &#8249;insert lspasl_p_der2[OF P P&#39;&#39;], auto&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* We restrict that the rule C can&#39;t be applied to
two syntactically identical ternary relational atoms. 
Note that we build communtativity in this rule application. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_c</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">[</span><span>thin</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h0</span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in &quot;(h1,h2&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
  &#166;&quot;(h2,h1&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
  &#166;P&#39;[thin]:&quot;(h1,?h3&#9657;h0)&quot; &#8658; &#8249;insert lspasl_c_der[OF P P&#39;], auto&#8250;
  &#166;P&#39;&#39;[thin]:&quot;(?h3,h1&#9657;h0)&quot; &#8658; &#8249;insert lspasl_c_der2[OF P P&#39;&#39;], auto&#8250;
  &#166;P&#39;&#39;&#39;[thin]:&quot;(h2,?h3&#9657;h0)&quot; &#8658; &#8249;insert lspasl_c_der3[OF P P&#39;&#39;&#39;], auto&#8250;
  &#166;P&#39;&#39;&#39;&#39;[thin]:&quot;(?h3,h2&#9657;h0)&quot; &#8658; &#8249;insert lspasl_c_der4[OF P P&#39;&#39;&#39;&#39;], auto&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* We restrict that *R only applies to a pair of 
a ternary relational and a formula once. 
Here, we need to first try simp to simplify situations such as
(h1,h2,h0) and not((A ** B) h3) and (h3 = h0). 
In the end, we try simp\_all to simplify all branches. 
A similar strategy is used in -*L. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_starr</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>simp</span><span class="delimiter">?</span><span class="delimiter">,</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(A ** B) (h::&#39;a::heap_sep_algebra)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>h</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in &quot;starr_applied h1 h2 h (A ** B)&quot; &#8658; &#8249;fail&#8250; 
   &#166;_ &#8658; &#8249;insert lspasl_starr_der[OF P P&#39;], auto&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp_all</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_starr2</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>simp</span><span class="delimiter">?</span><span class="delimiter">,</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(A ** B) (h::&#39;a::heap_sep_algebra)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>h</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in &quot;starr_applied h1 h2 h (A ** B)&quot; &#8658; 
    &#8249;match premises in &quot;starr_applied h2 h1 h (A ** B)&quot; &#8658; &#8249;fail&#8250;
     &#166;_ &#8658; &#8249;insert lspasl_starr_der2[OF P P&#39;], auto&#8250;&#8250;     
   &#166;_ &#8658; &#8249;insert lspasl_starr_der[OF P P&#39;], auto&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp_all</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* We restrict that -*L only applies to a pair of 
a ternary relational and a formula once. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_magicl</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>simp</span><span class="delimiter">?</span><span class="delimiter">,</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h&#9657;h2)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(A &#10230;* B) (h::&#39;a::heap_sep_algebra)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>h</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in &quot;magicl_applied h1 h h2 (A &#10230;* B)&quot; &#8658; &#8249;fail&#8250; 
   &#166;_ &#8658; &#8249;insert lspasl_magicl_der[OF P P&#39;], auto&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp_all</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* We build commutativity in the following rule applicaiton. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_magicl2</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>simp</span><span class="delimiter">?</span><span class="delimiter">,</span><span>
</span><span class="delimiter">(</span><span class="delimiter">(</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h&#9657;h2)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(A &#10230;* B) (h::&#39;a::heap_sep_algebra)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>h</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in &quot;magicl_applied h1 h h2 (A &#10230;* B)&quot; &#8658; &#8249;fail&#8250; 
   &#166;_ &#8658; &#8249;insert lspasl_magicl_der[OF P P&#39;], auto&#8250;&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span class="delimiter">(</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h,h1&#9657;h2)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P&#39;&#39;&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(A &#10230;* B) (h::&#39;a::heap_sep_algebra)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>h</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in &quot;magicl_applied h1 h h2 (A &#10230;* B)&quot; &#8658; &#8249;fail&#8250; 
   &#166;_ &#8658; &#8249;insert lspasl_magicl_der2[OF P&#39;&#39; P&#39;&#39;&#39;], auto&#8250;&#8250;</span></span></span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">,</span><span>
</span><span>simp_all</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* We restrict that the U rule is only applicable to a world h
when (h,0,h) is not in the premises. There are two cases:
(1) We pick a ternary relational atom (h1,h2,h0),
and check if (h1,0,h1) occurs in the premises, if not, 
apply U on h1. Otherwise, check other ternary relational atoms.
(2) We pick a labelled formula (A h), 
and check if (h,0,h) occurs in the premises, if not,
apply U on h. Otherwise, check other labelled formulae. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_u_tern</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> 
</span><span>  </span><span>P</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;(h0::&#39;a::heap_sep_algebra))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>h0</span><span> </span><span class="delimiter">&#8658;</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in 
    &quot;(h1,0&#9657;h1)&quot; &#8658; &#8249;match premises in 
      &quot;(h2,0&#9657;h2)&quot; &#8658; &#8249;match premises in 
        I1:&quot;(h0,0&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
        &#166;_ &#8658; &#8249;insert lspasl_u_der[of h0]&#8250;&#8250;
      &#166;_ &#8658; &#8249;insert lspasl_u_der[of h2]&#8250;&#8250;
    &#166;_ &#8658; &#8249;insert lspasl_u_der[of h1]&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_u_form</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> 
</span><span>  </span><span>P&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;_ (h::&#39;a::heap_sep_algebra)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h</span><span> </span><span class="delimiter">&#8658;</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in &quot;(h,0&#9657;h)&quot; &#8658; &#8249;fail&#8250;
   &#166;&quot;(0,0&#9657;0)&quot; and &quot;h = 0&quot; &#8658; &#8249;fail&#8250;
   &#166;&quot;(0,0&#9657;0)&quot; and &quot;0 = h&quot; &#8658; &#8249;fail&#8250;
   &#166;_ &#8658; &#8249;insert lspasl_u_der[of h]&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* We restrict that the E rule is only applicable to
(h1,h2,h0) when (h2,h1,h0) is not in the premises. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_e</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>h0</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in &quot;(h2,h1&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
   &#166;_ &#8658; &#8249;insert lspasl_e_der[OF P], auto&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* We restrict that the A rule is only applicable to 
(h1,h2,h0) and (h3,h4,h1) when (h3,h,h0) and (h2,h4,h) 
or any commutative variants of the two 
do not occur in the premises, for some h. 
Additionally, we do not allow A to be applied to two identical 
ternary relational atoms. 
We further restrict that the leaves must not be 0, 
because otherwise this application does not gain anything. *}</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_a</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h0</span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in 
    &quot;(0,h2&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
   &#166;&quot;(h1,0&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
   &#166;&quot;(h1,h2&#9657;0)&quot; &#8658; &#8249;fail&#8250;
   &#166;P[thin]:&quot;(h1,h2&#9657;h0)&quot; &#8658; 
    &#8249;match premises in
      P&#39;:&quot;(h3,h4&#9657;h1)&quot; for h3 h4 &#8658; &#8249;match premises in
        &quot;(0,h4&#9657;h1)&quot; &#8658; &#8249;fail&#8250;
       &#166;&quot;(h3,0&#9657;h1)&quot; &#8658; &#8249;fail&#8250;
       &#166;&quot;(_,h3&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
       &#166;&quot;(h3,_&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
       &#166;&quot;(h2,h4&#9657;_)&quot; &#8658; &#8249;fail&#8250;
       &#166;&quot;(h4,h2&#9657;_)&quot; &#8658; &#8249;fail&#8250;       
       &#166;_ &#8658; &#8249;insert P P&#39;, drule lspasl_a_der, auto&#8250;&#8250;&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_a_full</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h0</span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in 
    &quot;(0,h2&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
   &#166;&quot;(h1,0&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
   &#166;&quot;(h1,h2&#9657;0)&quot; &#8658; &#8249;fail&#8250;
   &#166;P[thin]:&quot;(h1,h2&#9657;h0)&quot; &#8658; 
    &#8249;match premises in
      P&#39;:&quot;(h3,h4&#9657;h1)&quot; for h3 h4 &#8658; &#8249;match premises in
        &quot;(0,h4&#9657;h1)&quot; &#8658; &#8249;fail&#8250;
       &#166;&quot;(h3,0&#9657;h1)&quot; &#8658; &#8249;fail&#8250;
       &#166;&quot;(h5,h3&#9657;h0)&quot; for h5 &#8658; &#8249;match premises in 
         &quot;(h2,h4&#9657;h5)&quot; &#8658; &#8249;fail&#8250;
        &#166;&quot;(h4,h2&#9657;h5)&quot; &#8658; &#8249;fail&#8250;
        &#166;_ &#8658; &#8249;insert P P&#39;, drule lspasl_a_der, auto&#8250;&#8250;
       &#166;&quot;(h3,h5&#9657;h0)&quot; for h5 &#8658; &#8249;match premises in 
         &quot;(h2,h4&#9657;h5)&quot; &#8658; &#8249;fail&#8250;
        &#166;&quot;(h4,h2&#9657;h5)&quot; &#8658; &#8249;fail&#8250;
        &#166;_ &#8658; &#8249;insert P P&#39;, drule lspasl_a_der, auto&#8250;&#8250;
       &#166;&quot;(h2,h4&#9657;h5)&quot; for h5 &#8658; &#8249;match premises in 
         &quot;(h3,h5&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
        &#166;&quot;(h5,h3&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
        &#166;_ &#8658; &#8249;insert P P&#39;, drule lspasl_a_der, auto&#8250;&#8250;
       &#166;&quot;(h4,h2&#9657;h5)&quot; for h5 &#8658; &#8249;match premises in 
         &quot;(h3,h5&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
        &#166;&quot;(h5,h3&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
        &#166;_ &#8658; &#8249;insert P P&#39;, drule lspasl_a_der, auto&#8250;&#8250;       
       &#166;_ &#8658; &#8249;insert P P&#39;, drule lspasl_a_der, auto&#8250;&#8250;&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* I don&#39;t have a good heuristics for CS right now. 
I simply forbid CS to be applied on the same pair twice. *}</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
method try_lspasl_cs = (
match premises in P[thin]:&quot;(h1,h2&#9657;h0)&quot; for h0 h1 h2 &#8658; 
  &#8249;match premises in &quot;(h1,h2&#9657;h0)&quot; &#8658; &#8249;fail&#8250; 
   &#166;&quot;(h2,h1&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
   &#166;&quot;(0,h0&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
   &#166;&quot;(h0,0&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
   &#166;P&#39;:&quot;(h3,h4&#9657;h0)&quot; for h3 h4 &#8658; &#8249;match premises in 
      &quot;(h5,h6&#9657;h1)&quot; and &quot;(h7,h8&#9657;h2)&quot; and &quot;(h5,h7&#9657;h3)&quot; and &quot;(h6,h8&#9657;h4)&quot; for h5 h6 h7 h8 &#8658; &#8249;fail&#8250;
     &#166;&quot;(i5,i6&#9657;h2)&quot; and &quot;(i7,i8&#9657;h1)&quot; and &quot;(i5,i7&#9657;h3)&quot; and &quot;(i6,i8&#9657;h4)&quot; for i5 i6 i7 i8 &#8658; &#8249;fail&#8250;
     &#166;&quot;(j5,j6&#9657;h1)&quot; and &quot;(j7,j8&#9657;h2)&quot; and &quot;(j5,j7&#9657;h4)&quot; and &quot;(j6,j8&#9657;h3)&quot; for j5 j6 j7 j8 &#8658; &#8249;fail&#8250;
     &#166;&quot;(k5,k6&#9657;h2)&quot; and &quot;(k7,k8&#9657;h1)&quot; and &quot;(k5,k7&#9657;h4)&quot; and &quot;(k6,k8&#9657;h3)&quot; for k5 k6 k7 k8 &#8658; &#8249;fail&#8250;
     &#166;_ &#8658; &#8249;insert lspasl_cs_der[OF P P&#39;], auto&#8250;&#8250;&#8250;,
simp?
)
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_cs</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">[</span><span>thin</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h0</span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match P in &quot;(0,h0&#9657;h0)&quot; &#8658; &#8249;fail&#8250; 
   &#166;&quot;(h0,0&#9657;h0)&quot; &#8658; &#8249;fail&#8250; 
   &#166;_ &#8658; &#8249;match premises in P&#39;:&quot;(h3,h4&#9657;h0)&quot; for h3 h4 &#8658; 
    &#8249;match P&#39; in &quot;(h2,h1&#9657;h0)&quot; &#8658; &#8249;fail&#8250; 
     &#166;&quot;(0,h0&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
     &#166;&quot;(h0,0&#9657;h0)&quot; &#8658; &#8249;fail&#8250;
     &#166;_ &#8658; &#8249;insert lspasl_cs_der[OF P P&#39;], auto&#8250;&#8250;&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Note that we build commutativity in the following rule applicaiton. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_starr_guided</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>simp</span><span class="delimiter">?</span><span class="delimiter">,</span><span>
</span><span class="delimiter">(</span><span class="delimiter">(</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(A ** B) (h::&#39;a::heap_sep_algebra)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>h</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in &quot;starr_applied h1 h2 h (A ** B)&quot; &#8658; &#8249;fail&#8250;
   &#166;&quot;A h1&quot; &#8658; &#8249;insert lspasl_starr_der[OF P P&#39;], auto&#8250;
   &#166;&quot;B h2&quot; &#8658; &#8249;insert lspasl_starr_der[OF P P&#39;], auto&#8250;&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span class="delimiter">(</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h2&#9657;h)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(A ** B) (h::&#39;a::heap_sep_algebra)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>h</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in &quot;starr_applied h2 h1 h (A ** B)&quot; &#8658; &#8249;fail&#8250;
   &#166;&quot;A h2&quot; &#8658; &#8249;insert lspasl_starr_der2[OF P P&#39;], auto&#8250;
   &#166;&quot;B h1&quot; &#8658; &#8249;insert lspasl_starr_der2[OF P P&#39;], auto&#8250;&#8250;</span></span></span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">,</span><span>
</span><span>simp_all</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Note that we build commutativity in the following rule applicaiton. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lspasl_magicl_guided</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>simp</span><span class="delimiter">?</span><span class="delimiter">,</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h1,h&#9657;h2)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(A &#10230;* B) (h::&#39;a::heap_sep_algebra)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>h</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in &quot;magicl_applied h1 h h2 (A &#10230;* B)&quot; &#8658; &#8249;fail&#8250; 
   &#166;&quot;A h1&quot; &#8658; &#8249;insert lspasl_magicl_der[OF P P&#39;], auto&#8250;
   &#166;&quot;&#172;(B h2)&quot; &#8658; &#8249;insert lspasl_magicl_der[OF P P&#39;], auto&#8250;&#8250;</span></span></span><span>
</span><span class="delimiter">&#166;</span><span>P&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(h,h1&#9657;h2)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P&#39;&#39;&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(A &#10230;* B) (h::&#39;a::heap_sep_algebra)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>h</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="delimiter">&#8658;</span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;match premises in &quot;magicl_applied h1 h h2 (A &#10230;* B)&quot; &#8658; &#8249;fail&#8250; 
   &#166;&quot;A h1&quot; &#8658; &#8249;insert lspasl_magicl_der2[OF P&#39;&#39; P&#39;&#39;&#39;], auto&#8250;
   &#166;&quot;&#172;(B h2)&quot; &#8658; &#8249;insert lspasl_magicl_der2[OF P&#39;&#39; P&#39;&#39;&#39;], auto&#8250;&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp_all</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* The following rule deals with the meta-language universal quantifier. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>try_lsfasl_boxl</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>simp</span><span class="delimiter">?</span><span class="delimiter">,</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">[</span><span>thin</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;h. ?A (h::&#39;a::heap_sep_algebra)&quot;</span></span></span><span> </span><span class="delimiter">&#8658;</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;insert P, drule meta_spec, auto&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>auto</span><span class="delimiter">?</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Change this line to simp? will raise type errors... *)</span></span></span></span></span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* In case the conclusion is not False, we normalise the goal as below. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>norm_goal</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>match</span><span> </span><span class="keyword2"><span class="keyword">conclusion</span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span> </span><span class="delimiter">&#8658;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fail&#8250;</span></span></span><span>
</span><span class="delimiter">&#166;</span><span>_</span><span> </span><span class="delimiter">&#8658;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;rule ccontr&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>simp</span><span class="delimiter">?</span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* The tactic for separata. We first try to simplify the problem
with auto simp add: sep\_conj\_ac, which ought to solve many problems.
Then we apply the &quot;true&quot; invertible rules and structural rules 
which unify worlds as much as possible, followed by auto to simplify the goals. 
Then we apply *R and -*L and other structural rules.
The rule CS is only applied when nothing else is applicable. We try not
to use it. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Preparation for the solver. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_implE2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P ** (P &#10230;* Q)) h &#10233; Q h&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sep_conj_commuteI</span><span> </span><span>sep_conj_sep_impl2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_implE3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A ** (P ** (P &#10230;* Q))) h &#10233; (A ** Q) h&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sep_conj_impl</span><span> </span><span>sep_implE2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_implE4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((P ** (P &#10230;* Q)) ** A) h &#10233; (Q ** A) h&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sep_conj_commuteI</span><span> </span><span>sep_implE3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>prep</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_conj_ac</span><span class="delimiter">)</span><span class="delimiter">|</span><span>norm_goal</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* This part contains invertible rules. 
Apply as often as possible. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>invert</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span class="delimiter">(</span><span>try_lspasl_empl</span><span> 
</span><span class="delimiter">|</span><span>try_lspasl_iu</span><span>
</span><span class="delimiter">|</span><span>try_lspasl_d</span><span>
</span><span class="delimiter">|</span><span>try_lspasl_eq</span><span>     
</span><span class="delimiter">|</span><span>try_lspasl_p</span><span>
</span><span class="delimiter">|</span><span>try_lspasl_c</span><span>
</span><span class="delimiter">|</span><span>try_lspasl_starl</span><span>
</span><span class="delimiter">|</span><span>try_lspasl_magicr</span><span>  
</span><span class="delimiter">|</span><span>try_lspasl_starr_guided</span><span>
</span><span class="delimiter">|</span><span>try_lspasl_magicl_guided</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span>
</span><span>auto</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* This part contains structural rules. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>struct</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>try_lspasl_u_tern</span><span> 
</span><span class="delimiter">|</span><span>try_lspasl_e</span><span>
</span><span class="delimiter">|</span><span>try_lspasl_a</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* This part contains *R and -*L rules. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>noninvert</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>try_lspasl_starr2</span><span> 
</span><span class="delimiter">|</span><span>try_lspasl_magicl2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* This part contains rules that are rarely used. *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>rare</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>try_lspasl_u_form</span><span class="delimiter">+</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* This rule is rarely used. *)</span></span></span></span></span><span>
</span><span class="delimiter">|</span><span>try_lspasl_a_full</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Just in case we need more ternary relational atoms from associativity. *)</span></span></span></span></span><span>
</span><span class="delimiter">|</span><span>try_lspasl_cs</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Cross-split adds too much complication. Try not to use it. *)</span></span></span></span></span><span>
</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>separata</span><span> </span><span class="delimiter">=</span><span>     
</span><span class="delimiter">(</span><span>prep</span><span>
</span><span> </span><span class="delimiter">|</span><span class="delimiter">(</span><span>invert</span><span>
</span><span>  </span><span class="delimiter">|</span><span>try_lsfasl_boxl</span><span>         
</span><span>  </span><span class="delimiter">|</span><span>struct</span><span>  
</span><span>  </span><span class="delimiter">|</span><span>noninvert</span><span>   
</span><span> </span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span> </span><span class="delimiter">|</span><span>rare</span><span>
</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>

</div>
</body>
</html>
