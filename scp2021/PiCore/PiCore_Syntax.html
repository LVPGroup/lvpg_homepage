<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory PiCore_Syntax (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory PiCore_Syntax</h1>

<span class="command">theory</span> <span class="name">PiCore_Syntax</span><br/>
<span class="keyword">imports</span> <a href="PiCore_ext.html"><span class="name">PiCore_ext</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
Created by Yongwang Zhao (zhaoyw@buaa.edu.cn) 
School of Computer Science &amp; Engineering, Beihang University, China
and David Sanan (sanan@ntu.edu.sg)
School of Computer Science &amp; Engineering, Nanyang Technological University, Singapore
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Syntax for PiCore&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>PiCore_Syntax</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>PiCore_ext</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_quote&quot;</span></span></span><span>     </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b &#8658; (&#39;s &#8658; &#39;b)&quot;</span></span></span><span>                </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(&#171;_&#187;)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">]</span><span> </span><span>1000</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_antiquote&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#8658; &#39;b) &#8658; &#39;b&quot;</span></span></span><span>                </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#180;_&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">]</span><span> </span><span>1000</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_Assert&quot;</span></span></span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;s set&quot;</span></span></span><span>                    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(&#10627;_&#10628;)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">]</span><span> </span><span>1000</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;b&#10628;&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CONST Collect &#171;b&#187;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">parse_translation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  let
    fun quote_tr [t] = Syntax_Trans.quote_tr @{syntax_const &quot;_antiquote&quot;} t
      | quote_tr ts = raise TERM (&quot;quote_tr&quot;, ts);
  in [(@{syntax_const &quot;_quote&quot;}, K quote_tr)] end
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>                                            
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* &quot;_Event&quot;     :: &quot;[&#39;a, &#39;a, &#39;a] &#8658; (&#39;l,&#39;s,&#39;s com option) event&quot; (&quot;(EVENT _ WHEN _ THEN _ END)&quot; [0,0,0] 61)
  &quot;_Event2&quot;     :: &quot;[&#39;a, &#39;a] &#8658; (&#39;l,&#39;s,&#39;s com option) event&quot; (&quot;(EVENT _ THEN _ END)&quot; [0,0] 61)
  &quot;_Event_a&quot;     :: &quot;[&#39;a, &#39;a, &#39;a] &#8658; (&#39;l,&#39;s,&#39;s com option) event&quot; (&quot;(EVENT<span class="hidden">&#8681;</span><sub>A</sub> _ WHEN _ THEN _ END)&quot; [0,0,0] 61)
  &quot;_Event_a2&quot;     :: &quot;[&#39;a, &#39;a] &#8658; (&#39;l,&#39;s,&#39;s com option) event&quot; (&quot;(EVENT<span class="hidden">&#8681;</span><sub>A</sub> _ THEN _ END)&quot; [0,0] 61)&quot; *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_Event&quot;</span></span></span><span>     </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[&#39;l, &#39;g, &#39;prog] &#8658; (&#39;l,&#39;k,&#39;s,&#39;prog) esys&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(EVENT _ WHEN _ THEN _ END)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_Event2&quot;</span></span></span><span>     </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[&#39;l, &#39;prog] &#8658; (&#39;l,&#39;k,&#39;s,&#39;prog)  esys&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(EVENT _ THEN _ END)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_Event_a&quot;</span></span></span><span>     </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[&#39;l, &#39;g, &#39;prog] &#8658; (&#39;l,&#39;k,&#39;s,&#39;prog) esys&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(EVENT<span class="hidden">&#8681;</span><sub>A</sub> _ WHEN _ THEN _ END)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_Event_a2&quot;</span></span></span><span>     </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[&#39;l, &#39;prog] &#8658; (&#39;l,&#39;k,&#39;s,&#39;prog) esys&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(EVENT<span class="hidden">&#8681;</span><sub>A</sub> _ THEN _ END)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_EventSG&quot;</span></span></span><span>     </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[&#39;l, &#39;g, &#39;prog] &#8658; (&#39;l,&#39;s,&#39;prog) event&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(EVENT<span class="hidden">&#8681;</span><sub>s</sub> _ WHEN _ THEN _ END)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_EventS&quot;</span></span></span><span>     </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[&#39;l, &#39;g, &#39;prog] &#8658; (&#39;l,&#39;s,&#39;prog) event&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(EVENT<span class="hidden">&#8681;</span><sub>s</sub> _ THEN _ END)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>  
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;EVENT<span class="hidden">&#8681;</span><sub>s</sub> l WHEN g THEN bd END&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(l, &#10627;g&#10628;, bd)&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;EVENT<span class="hidden">&#8681;</span><sub>s</sub> l THEN bd END&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;EVENT<span class="hidden">&#8681;</span><sub>s</sub> l WHEN CONST True THEN bd END&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;EVENT l WHEN g THEN bd END&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CONST EBasic {(l, &#10627;g&#10628;, bd)}&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;EVENT l THEN bd END&quot;</span></span></span><span> </span><span class="delimiter">&#8652;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;EVENT l WHEN CONST True THEN bd END&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;EVENT<span class="hidden">&#8681;</span><sub>A</sub> l WHEN g THEN bd END&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CONST EAtom {(l, &#10627;g&#10628;,  bd)}&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;EVENT<span class="hidden">&#8681;</span><sub>A</sub> l THEN bd END&quot;</span></span></span><span> </span><span class="delimiter">&#8652;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;EVENT<span class="hidden">&#8681;</span><sub>A</sub> l WHEN CONST True THEN bd END&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_EventS&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(&#39;e &#8658; (&#39;l,&#39;s,&#39;prog) event)] &#8658; (&#39;l,&#39;k,&#39;s,&#39;prog) esys&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;ESET _ &quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Abs (&quot;c&quot;, &quot;nat&quot;,
         Const (&quot;HOL.Ex&quot;, &quot;(nat &#8658; bool) &#8658; bool&quot;) $
           Abs (&quot;h1&quot;, &quot;nat&quot;, Const (&quot;HOL.Ex&quot;, &quot;(bool &#8658; bool) &#8658; bool&quot;) $ Abs (&quot;h2&quot;, &quot;bool&quot;, Const (&quot;HOL.Ex&quot;, &quot;...&quot;) $ Abs (&quot;h3&quot;, &quot;...&quot;, ...)))) *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">parse_translation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  let
    fun get_types _ t = binder_types t;
    
    fun get_fun_type _ f =       
      let val t = type_of f           
          val dom = binder_types t
          val bod = body_type t in (dom,bod) end;   

    fun bound_term n = Bound n

    fun  params_bounds l 0 = l
       | params_bounds l n = params_bounds ((Bound (n - 1))::l) (n-1)
    
    fun mk_string n = &quot;p&quot;^(string_of_int n)
    
    fun  create_param_list _ 0 l = l
        |create_param_list ts n l = (create_param_list ts (n-1) ((mk_string n, nth ts (n-1))::l))
        
    fun create_free_list l =  map (fn x =&gt; Free x) l
        
    fun create_exists_term init l =  fold (fn (n,t) =&gt; fn e =&gt; HOLogic.mk_exists (n,t, e)) init l

    fun apply_fun f args = list_comb(f,args);
                                                              
    val x = HOLogic.mk_exists

    fun make_abs ctxt f =
      let val (param_t, body_t) = get_fun_type ctxt f 
          val xterm = Free (&quot;c&quot;,body_t) 
          val param_list = create_param_list param_t (length param_t) []        
          val f_app = list_comb (f, (create_free_list param_list))
          val eq_elem_f = HOLogic.mk_eq (xterm, f_app) in 
            lambda xterm (create_exists_term param_list eq_elem_f)
      end;
    
    fun strip_constrain ((Const x $ Free (n,t)) $ h) = n
    fun strip_Exn (Exn.Res f) = f
    fun event_tr ctxt [f] = 
       let val (l,r) = Syntax_Phases.decode_term ctxt ([],Exn.Res f)
           val t = strip_Exn r                    
           val f = Syntax.check_term ctxt  t           
           (* val f = Syntax.read_term ctxt  (strip_constrain f)
           val v = writeln (@{make_string} f) *) in 
       Syntax.const @{const_syntax EBasic} $ 
            (Syntax.const @{const_syntax Collect} $ make_abs ctxt f)  end;
  in 
 [(@{syntax_const &quot;_EventS&quot;}, event_tr)] end

&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Translations for variables before and after a transition:&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_before&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id &#8658; &#39;a&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#186;_&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_after&quot;</span></span></span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id &#8658; &#39;a&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#170;_&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#186;x&quot;</span></span></span><span> </span><span class="delimiter">&#8652;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#180;CONST fst&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#170;x&quot;</span></span></span><span> </span><span class="delimiter">&#8652;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#180;CONST snd&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">print_translation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  let
    fun quote_tr&#39; f (t :: ts) =
          Term.list_comb (f $ Syntax_Trans.quote_tr&#39; @{syntax_const &quot;_antiquote&quot;} t, ts)
      | quote_tr&#39; _ _ = raise Match;

    val assert_tr&#39; = quote_tr&#39; (Syntax.const @{syntax_const &quot;_Assert&quot;});

    fun bexp_tr&#39; name ((Const (@{const_syntax Collect}, _) $ t) :: ts) =
          quote_tr&#39; (Syntax.const name) (t :: ts)
      | bexp_tr&#39; _ _ = raise Match;   
  in
   [(@{const_syntax Collect}, K assert_tr&#39;)]
end &#8250;</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
