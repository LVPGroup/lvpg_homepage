<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory SmackHooks (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory SmackHooks</h1>

<span class="command">theory</span> <span class="name">SmackHooks</span><br/>
<span class="keyword">imports</span> <a href="Linux_LSM_Model.html"><span class="name">Linux_LSM_Model</span></a> <a href="smack_h.html"><span class="name">smack_h</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249; smack hooks&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>SmackHooks</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&quot;../../Monad_WP/WhileLoopRulesCompleteness&quot; *)</span></span></span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;../../LSM/Element&quot;</span></span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;../../LSM/Linux_LSM_Model&quot;</span></span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;../../LSM/LSM_Cap&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;../FSP/smack_h&quot;</span></span></span><span>
</span><span>          </span><span>Main</span><span> 
</span><span>          </span><span>HOL.Real</span><span>
</span><span>          </span><span>HOL.String</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;HOL-Word.Word_Bitwise&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;../../lib/Monad_WP/NonDetMonadVCG&quot;</span></span></span><span>                                            
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span>smack_parsed_rule</span><span> </span><span class="delimiter">=</span><span> </span><span>smk_subject</span><span> </span><span class="delimiter">::</span><span> </span><span>smack_known</span><span>
</span><span>                           </span><span>smk_object</span><span> </span><span class="delimiter">::</span><span> </span><span>smack_known</span><span>
</span><span>                           </span><span>smk_access1</span><span> </span><span class="delimiter">::</span><span> </span><span>int</span><span>
</span><span>                           </span><span>smk_access2</span><span> </span><span class="delimiter">::</span><span> </span><span>int</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*NetLabel audit information *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span>netlbl_audit</span><span> </span><span class="delimiter">=</span><span> </span><span>secid</span><span> </span><span class="delimiter">::</span><span> </span><span>u32</span><span>
</span><span>                      </span><span>loginuid</span><span> </span><span class="delimiter">::</span><span> </span><span>kuid</span><span>
</span><span>                      </span><span>sessionid</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span>smk_audit_info</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>rules</span><span> </span><span class="delimiter">::</span><span> </span><span>list_head</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>nlabel</span><span> </span><span class="delimiter">::</span><span> </span><span>netlbl_lsm_secattr</span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>smk_net4addr_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_net4addr list&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>smk_net6addr_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_net6addr list&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_known_floor &#8801; &#10631;smk_known = &#39;&#39;_&#39;&#39;,
                                 smk_secid = 5,
                                 smk_rules = rules,
                                 smk_netlabel = nlabel&#10632;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_known_hat &#8801; &#10631;smk_known = &#39;&#39;^&#39;&#39;,
                               smk_secid = 3, 
                               smk_rules = rules,
                               smk_netlabel = nlabel &#10632;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_known_huh &#8801; &#10631;smk_known = &#39;&#39;?&#39;&#39;,
                               smk_secid = 2, 
                               smk_rules = rules,
                               smk_netlabel = nlabel &#10632;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_known_star &#8801; &#10631;smk_known = &#39;&#39;*&#39;&#39;,
                                smk_secid = 4, 
                                smk_rules = rules ,
                                smk_netlabel = nlabel&#10632;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_known_web &#8801; &#10631;smk_known = &#39;&#39;@&#39;&#39;,
                               smk_secid = 7 , 
                               smk_rules = rules,
                               smk_netlabel = nlabel&#10632;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">axiomatization</span></span><span> </span><span>smack_unconfined</span><span> </span><span class="delimiter">::</span><span> </span><span>smack_known</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>assumes_unconfined</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_unconfined &#8800; smack_known_floor &#8743; 
                              smack_unconfined &#8800; smack_known_hat &#8743;
                              smack_unconfined &#8800; smack_known_huh &#8743; 
                              smack_unconfined &#8800; smack_known_star &#8743; 
                              smack_unconfined &#8800; smack_known_web&quot;</span></span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span>State&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>current</span><span> </span><span class="delimiter">::</span><span> </span><span>process_id</span><span>
</span><span>               </span><span>tasks</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;process_id &#8640; Task&quot;</span></span></span><span>
</span><span>               </span><span>k_superblock</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t_sb&#8640; super_block &quot;</span></span></span><span>
</span><span>               </span><span>inodes</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inum &#8640;  inode&quot;</span></span></span><span>
</span><span>               </span><span>sdentry</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dname&#8640; dentry&quot;</span></span></span><span>
</span><span>               </span><span>files</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fname &#8640; Files&quot;</span></span></span><span>
</span><span>               </span><span>msg_msgs</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;msg_mid &#8640;  msg_msg&quot;</span></span></span><span>
</span><span>               </span><span>msg_queues</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;msg_qid &#8640;  kern_ipc_perm&quot;</span></span></span><span>
</span><span>               </span><span>keys</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;keyid &#8640;  key&quot;</span></span></span><span>
</span><span>               </span><span>sockets</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;socketdesp &#8640;  socket&quot;</span></span></span><span>
</span><span>               </span><span>opts</span><span> </span><span class="delimiter">::</span><span> </span><span>opts</span><span>
</span><span>
</span><span>               </span><span>t_security</span><span> </span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Cred &#8658;task_smack option&quot;</span></span></span><span>            
</span><span>               </span><span>sb_security</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;super_block &#8658;superblock_smack option&quot;</span></span></span><span>
</span><span>               </span><span>msg_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;msg_msg &#8658; smack_known option&quot;</span></span></span><span>
</span><span>               </span><span>ipc_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;kern_ipc_perm &#8658; smack_known option&quot;</span></span></span><span>
</span><span>               </span><span>i_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inode &#8658; inode_smack option&quot;</span></span></span><span>
</span><span>               </span><span>f_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Files &#8658; smack_known option&quot;</span></span></span><span>
</span><span>               </span><span>sk_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sock &#8658; socket_smack option&quot;</span></span></span><span>
</span><span>               </span><span>key_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;key &#8658; smack_known option&quot;</span></span></span><span>
</span><span>               </span><span>subj_l</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Subj &#8658;Label&quot;</span></span></span><span>
</span><span>               </span><span>obj_l</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Obj &#8658; Label&quot;</span></span></span><span>
</span><span>               </span><span>Subjs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Subj set&quot;</span></span></span><span>
</span><span>               </span><span>Objs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Obj set&quot;</span></span></span><span>
</span><span>               </span><span>pol_tab</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; (Subj,Obj) policy_table&quot;</span></span></span><span>
</span><span>              </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  access_rules :: &quot; Label &#8658; Label &#8658; access set&quot; *)</span></span></span></span></span><span>
</span><span>            
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_current s&#8801;  (current s)&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_cur_task s = the(tasks s (get_current s))&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* current_cred - Access the current task&#39;s subjective credentials *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>current_cred</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Task &#8658; Cred&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;current_cred task = cred task&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**
 * current_real_cred - Access the current task&#39;s objective credentials
 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>current_real_cred</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Task &#8658; Cred&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;current_real_cred task = real_cred task&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**
 ** task_cred - Access a task&#39;s objective credentials
 * @task: The task to query
 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;task_cred task &#8801; cred task&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;task_real_cred task &#8801; real_cred task&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span>Shared</span><span> </span><span class="delimiter">=</span><span> </span><span>smack_enabled</span><span> </span><span class="delimiter">::</span><span> </span><span>int</span><span>
</span><span>                </span><span>smack_cipso_direct</span><span> </span><span class="delimiter">::</span><span> </span><span>int</span><span>
</span><span>                </span><span>smack_cipso_mapped</span><span> </span><span class="delimiter">::</span><span> </span><span>int</span><span> 
</span><span>                </span><span>smack_net_ambient</span><span> </span><span class="delimiter">::</span><span> </span><span>smack_known</span><span>
</span><span>                </span><span>smack_syslog_label</span><span> </span><span class="delimiter">::</span><span> </span><span>smack_known</span><span>
</span><span>                </span><span>smack_ptrace_rule</span><span> </span><span class="delimiter">::</span><span> </span><span>int</span><span>
</span><span>                </span><span>smack_known_lock</span><span> </span><span class="delimiter">::</span><span> </span><span>mutex</span><span>
</span><span>                </span><span>smack_onlycap_lock</span><span> </span><span class="delimiter">::</span><span> </span><span>mutex</span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>shared</span><span> </span><span class="delimiter">::</span><span>  </span><span>Shared</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>string_to_label</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;string &#8658; Label&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;string_to_label str &#8801; if str = &#39;&#39;?&#39;&#39; then Huh
                                else if str = &#39;&#39;^&#39;&#39; then Hat
                                else if str = &#39;&#39;_&#39;&#39; then Floor
                                else if str = &#39;&#39;*&#39;&#39; then Star
                                else if str = &#39;&#39;@&#39;&#39; then Web
                                else Normal str&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_of_subjlabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; process_id&#8658; Label&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_subjlabel s pid &#8801; let 
         subjlabel = (t_security s) (cred(the(tasks s pid))) in
         if subjlabel = None then UNDEFINED 
         else 
         string_to_label (smk_known(smk_of_task(the(t_security s (task_cred (the((tasks s) pid )))))))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_of_subjlabel_real</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; process_id&#8658; Label&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_subjlabel_real s pid &#8801; 
    string_to_label (smk_known(smk_of_task(the(t_security s (task_real_cred (the((tasks s) pid )))))))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_of_filelabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Files &#8658; Label&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_filelabel s file &#8801; let  flabel = (f_security s file) in
         if flabel = None then UNDEFINED 
         else
          string_to_label(smk_known (the flabel))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_of_ipclabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; kern_ipc_perm &#8658; Label&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_ipclabel s ipc&#39; &#8801; let  flabel = (ipc_security s ipc&#39;) in
         if flabel = None then UNDEFINED 
         else
          string_to_label(smk_known (the flabel))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_of_msglabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; msg_msg &#8658; Label&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_msglabel s msg&#39; &#8801; let  label = (msg_security s msg&#39;) in
         if label = None then UNDEFINED 
         else
          string_to_label(smk_known (the label))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_of_keylabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; key &#8658; Label&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_keylabel s k &#8801; let  label = (key_security s k) in
         if label = None then UNDEFINED 
         else
          string_to_label(smk_known (the label))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_of_sklabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; sock &#8658; Label&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_sklabel s k &#8801; let  label = (sk_security s k) in
         if label = None then UNDEFINED 
         else
          string_to_label(smk_known(smk_in (the label)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_of_inodelabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; inode &#8658; Label&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_inodelabel s i &#8801; let  label = (i_security s i) in
         if label = None then UNDEFINED 
         else
          string_to_label(smk_known(smk_inode (the label)))&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_of_superblocklabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; super_block &#8658; Label&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_superblocklabel s t &#8801; let sblabel = (sb_security s  t)
 in if sblabel = None then UNDEFINED 
    else
       string_to_label(smk_known (smk_default (the sblabel)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>smk_of_objectlabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Obj &#8658; Label&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_objectlabel s (File obj) = smk_of_filelabel s obj&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_objectlabel s (Sb obj) = smk_of_superblocklabel s obj&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_objectlabel s (Process obj) = smk_of_subjlabel_real s obj&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_objectlabel s (IPC obj) = smk_of_ipclabel s obj&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_objectlabel s (Msg obj) = smk_of_msglabel s obj&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_objectlabel s (ObjInode obj) = smk_of_inodelabel s obj&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_objectlabel s (ObjSock obj) = smk_of_sklabel s obj&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_objectlabel s (ObjKey obj) = smk_of_keylabel s obj&quot;</span></span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>objlabelAccess</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Label &#8658; access set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;objlabelAccess obj &#8801; case obj of Floor &#8658; {READ,EXECUTE} | 
                                           Star &#8658; {READ,EXECUTE,WRITE,APPEND,T, LOCK } |
                                           _ &#8658; {} &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_access_rules&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39;&#8658;Label &#8658; Label &#8658; access set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_access_rules&#39; s subj obj &#8801; 
              case subj of Star &#8658; {} |                                  
                           Hat &#8658; {READ,EXECUTE} |
                           Floor &#8658; objlabelAccess obj |
                           Huh &#8658;  objlabelAccess obj  |
                           Web &#8658;  objlabelAccess obj  |
                           Normal x &#8658; if obj = Floor then  objlabelAccess obj
                                       else if obj = Star then objlabelAccess obj
                                       else if obj = Normal x  then {READ,EXECUTE,WRITE,APPEND,T, LOCK }
                                       else {} &quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Label_to_string</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Label &#8658; string&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Label_to_string label&#39;&#8801; SOME x. Normal x = label&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>user_define_rule</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;string &#8658; string &#8658; access set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;user_define_rule _ _ = {}&quot;</span></span></span><span>
</span><span>         
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_access_rules</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Label &#8658; Label &#8658; access set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_access_rules  subj obj &#8801; 
          if obj = UNDEFINED then {}
          else
          if subj = Star then {} 
          else 
          if obj = Web &#8744; subj = Web then {READ,EXECUTE,WRITE,APPEND,T, LOCK }
          else 
          if obj = Star then {READ,EXECUTE,WRITE,APPEND,T, LOCK }
          else 
          if subj = obj then {READ,EXECUTE,WRITE,APPEND,T, LOCK } 
          else
          if obj = Floor &#8744; subj = Hat then {READ,LOCK,EXECUTE }      
          else user_define_rule (Label_to_string subj) (Label_to_string obj) &quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ReferenceMonitor</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39;&#8658;Subj &#8658; Obj &#8658; Request &#8658; decision&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ReferenceMonitor s subj obj r &#8801; 
         if (access_rl r) &#8712; (smk_access_rules) (smk_of_subjlabel s subj) (smk_of_objectlabel s obj)
           then allow 
        else deny&quot;</span></span></span><span>
</span><span>              
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;task_security s t&#8801; the (t_security s (cred t))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;task_real_security s t&#8801; the (t_security s (real_cred t))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inode_security s inode = the(i_security s inode)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_pid s task &#8801; SOME pid . (tasks s) pid = Some task&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_inum s inode &#8801; SOME inum . (inodes s) inum = Some inode&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_sbnum s sb &#8801; SOME i . (k_superblock s) i= Some sb&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_of_task_struct</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;Task &#8658; smack_known&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_task_struct s t &#8801; smk_of_task (task_security s t)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;current_task s = the( (tasks s)(current s)) &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;current_security s = task_security s (current_task s)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_of_current</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smack_known&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_current s &#8801; smk_of_task( task_security s (current_task s))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_inode_transmutable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  inode &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_inode_transmutable s isp &#8801;
           let sip = (the(i_security  s isp)) in  
           if (smk_iflags sip AND SMK_INODE_TRANSMUTE) &#8800; 0 then 1 
           else 0&quot;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Present a pointer to the smack label entry in an inode blob.
 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_of_inode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; inode &#8658; smack_known&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_of_inode s inode &#8801;  smk_inode(inode_security s inode) &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_bu_note</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; string &#8658;smack_known &#8658;smack_known &#8658; int &#8658; int &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; smk_bu_note s note sskp oskp m rc &#8801; 
            if (SECURITY_SMACK_BRINGUP conf) then 0 
            else if rc &#8804; 0 then rc else 0
        &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_bu_current</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; string &#8658;smack_known  &#8658; int &#8658; int &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; smk_bu_current s note oskp m rc &#8801; 
          if (SECURITY_SMACK_BRINGUP conf) then 0 
          else if rc &#8804; 0 then rc else 0&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_bu_task</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task &#8658; int &#8658; int &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; smk_bu_task s otp m rc &#8801; 
        if (SECURITY_SMACK_BRINGUP conf) then 
          if rc &#8804; 0 then rc 
          else
            if rc &gt;SMACK_UNCONFINED_OBJECT then 0 
            else rc  
        else rc&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_bu_inode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  inode &#8658; int &#8658; int &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; smk_bu_inode s inode m rc &#8801; if (SECURITY_SMACK_BRINGUP conf) then 0 else rc&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_bu_file</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Files &#8658; int &#8658; int &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; smk_bu_file s f m rc &#8801; if (SECURITY_SMACK_BRINGUP conf) then 0 else rc&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_bu_credfile</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Cred &#8658;Files &#8658; int &#8658; int &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; smk_bu_credfile s cred&#39; f m rc &#8801; if (SECURITY_SMACK_BRINGUP conf) then 0 else rc&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_privileged_cred</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int &#8658; Cred &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_privileged_cred cap c &#8801; False&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the((tasks s) (current s))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_privileged</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;int &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_privileged s cap &#8801; 
          if flags (the((tasks s) (current s))) = PF_KTHREAD then True
          else smack_privileged_cred cap (current_cred (the((tasks s) (current s)))) &quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>d_backing_inode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry &#8658;  inode option&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;d_backing_inode s upper &#8801;((inodes s)(d_inode upper))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_inode s inum = inodes s inum&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_dentry s dname &#8801; sdentry s dname&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>file_inode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Files &#8658;  inode&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;file_inode f &#8801; f_inode f&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>word32</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;32 word&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>word8</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;8 word&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>byte</span><span> </span><span class="delimiter">=</span><span> </span><span>word8</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(PTRACE_MODE_READ AND PTRACE_MODE_ATTACH) = (0x00 :: byte)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>PTRACE_MODE_READ_def</span><span> </span><span>PTRACE_MODE_ATTACH_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; (PTRACE_MODE_READ AND PTRACE_MODE_ATTACH)::&#39;a::len word&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint (PTRACE_MODE_READ AND PTRACE_MODE_ATTACH)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint (PTRACE_MODE_READ AND PTRACE_MODE_ATTACH) = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>PTRACE_MODE_READ_def</span><span> </span><span>PTRACE_MODE_ATTACH_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>smack_rules</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_rule list&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_access_entry</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;string &#8658; string &#8658; list_head &#8658;(State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_access_entry s subj obj r = do 
         may &#8592; return(-ENOENT);  
         may &#8592; return((if ((may AND MAY_WRITE) = MAY_WRITE) then  (may OR MAY_LOCK) 
                        else ((may))));
         return may
      od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_access_out_audit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_known &#8658; smack_known &#8658; int &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_access_out_audit subj obj rc &#8801; 
        if (SECURITY_SMACK_BRINGUP conf) &#8743; rc &lt; 0 then
         let rc = if obj = smack_unconfined then SMACK_UNCONFINED_OBJECT else  rc;
             rc = if subj = smack_unconfined then SMACK_UNCONFINED_SUBJECT else  rc
       in rc
        else rc

 &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_access</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smack_known  &#8658; smack_known &#8658; int 
                                 &#8658; smk_audit_info option &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_access s subj obj requests a &#8801; 
      do
        
        rc&#8592;(if subj = smack_known_star then
               let rc = -EACCES 
               in return(smk_access_out_audit subj  obj rc)   
            else 
            if obj =smack_known_web &#8744; subj = smack_known_web 
            then return(smk_access_out_audit subj  obj 0)
            else 
            if obj = smack_known_star then 
               return(smk_access_out_audit subj  obj 0)
            else 
            if smk_known subj = smk_known obj then 
               return(smk_access_out_audit subj  obj 0)
            else if (requests AND MAY_ANYREAD = requests) &#8744; (requests AND MAY_LOCK = requests) 
                 then return(smk_access_out_audit subj  obj 0)
                 else do
                        may&#8592; smk_access_entry s (smk_known subj) (smk_known obj) (smk_rules subj);
                        if may &#8804; 0 &#8744; (requests AND may) &#8800; requests then 
                           return(smk_access_out_audit subj  obj  (-EACCES))
                        else  if (SECURITY_SMACK_BRINGUP conf) &#8743; (may AND MAY_BRINGUP &#8800; 0)  then 
                                  return(smk_access_out_audit subj  obj  SMACK_BRINGUP_ALLOW ) 
                               else 
                                 return(smk_access_out_audit subj  obj 0)
                        od);
        return rc
      od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_tskacc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; task_smack &#8658; smack_known &#8658; int 
                                 &#8658; smk_audit_info &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_tskacc s tsp obj m a &#8801; 
      do
        sbj_known &#8592; return (smk_of_task tsp);
        ad &#8592; return (Some a);
        rc &#8592; smk_access s sbj_known obj m ad;
        rc &#8592; (if rc &#8805; 0 then 
              do may &#8592; smk_access_entry s (smk_known sbj_known) (smk_known obj) (smk_rule tsp) ;
                 rc&#39;&#8592; (if may &lt; 0 &#8744; (m AND may) = m then return rc 
                        else return(-EACCES)
                       );
                 return rc&#39;
              od
              else return rc);
        rc &#8592; (if rc &#8800; 0 &#8743; (smack_privileged s CAP_MAC_OVERRIDE) then return 0 
              else return rc
              );     
        return rc
      od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_curacc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;smack_known &#8658; int &#8658;smk_audit_info&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_curacc s obj m a &#8801; 
      do
        rc &#8592; smk_tskacc s (current_security s) obj  m a;
        return rc
      od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>new_task_smack</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_known &#8658; smack_known &#8658;nat &#8658; task_smack option&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;new_task_smack  task forked gfp&#39; &#8801;
         (SOME t. &#8704;rule m label .if t = None then t = None  
                          else t = Some (&#10631;smk_task = task,
                                          smk_forked = forked,
                                          smk_rule = rule,
                                          smk_rules_lock = m,
                                          smk_relabel = label&#10632; ))
        &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>new_inode_smack</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_known &#8658; inode_smack option&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;new_inode_smack  skp &#8801;
         (SOME t. &#8707;mp lock forked  rcu .if t = None then t = None  
                          else t = Some (&#10631;smk_inode = skp,
                                          smk_itask = forked,
                                          smk_mmap = mp,
                                          smk_lock = lock,
                                          smk_iflags = 0,
                                          smk_rcu = rcu&#10632; ))
        &quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_copy_rules</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;list_head &#8658; list_head &#8658;nat&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_copy_rules s nhead ohead g &#8801; 
      do
        rc &#8592; return( 0);
        return rc
      od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_copy_relabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smack_known list &#8658; smack_known list 
                                       &#8658; nat &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_copy_relabel s nhead ohead g &#8801; 
      do
        rc &#8592; return( 0);
        return rc
      od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_from_secid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u32 &#8658; (State&#39;,smack_known option) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_from_secid  secid&#39; &#8801;
  do 
    a&#39; &#8592; return(0);
    (a&#39;, result) &#8592; whileLoop 
    (&#955;(a&#39;, result) secid&#39;. a&#39; &lt; length(smack_known_list))
    (&#955;(a&#39; ,result) . ((if smk_secid (smack_known_list ! a&#39;) = secid&#39;
                       then return (a&#39; + 1, Some ( (smack_known_list ! a&#39;))) 
                       else return (a&#39; + 1, Some smack_known_huh))))  
                            (a&#39;, Some smack_known_huh);
  return result
  od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>smack_known_hash</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_known list&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_find_entry</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;string &#8658; (State&#39;,smack_known option) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_find_entry  str &#8801;
  do 
    a&#39; &#8592; return(0);
    (a&#39;, result) &#8592; whileLoop 
    (&#955;(a&#39;, result) b&#39;. a&#39; &lt; length(smack_known_list))
    (&#955;(a&#39; ,result) . ((if smk_known (smack_known_hash ! a&#39;) = str
                       then return (a&#39; + 1, Some ( (smack_known_list ! a&#39;))) 
                       else return (a&#39; + 1, None))))  
                            (a&#39;,  None);
  return result
  od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SOCKET_I&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; inode &#8658;  socket_alloc &quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SOCKET_I&#39; i &#8801;   SOME sk.  skvfs_inode sk = i &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SOCKET_I</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; inode &#8658;   socket &quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SOCKET_I i &#8801;   socket (SOCKET_I&#39; i)  &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_ptrace_mode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mode &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_ptrace_mode m &#8801; 
    if (m AND PTRACE_MODE_ATTACH) &#8800; 0 
    then  MAY_READWRITE 
    else 
    if (m AND PTRACE_MODE_READ) &#8800; 0 
    then  MAY_READ
    else 0&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
*lsm hooks
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_ptrace_rule_check</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;Task &#8658; smack_known &#8658; nat &#8658; string &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_ptrace_rule_check  s tracer tracee_known m func&#39; &#8801; do
           tracercred &#8592; return(task_cred tracer);
           tsp &#8592; return(the(t_security s tracercred));
           tracer_known &#8592; return(smk_of_task tsp);
           saip &#8592; (if (int m AND PTRACE_MODE_NOAUDIT) &#8800;0 then
                        return (SOME x::smk_audit_info option . True)
                    else 
                        return (None)
                   );
           rc &#8592; (if (((int m) AND PTRACE_MODE_ATTACH) &#8800; 0) &#8743; (
                     ((smack_ptrace_rule shared) = SMACK_PTRACE_EXACT) &#8744; 
                      ((smack_ptrace_rule shared) = SMACK_PTRACE_DRACONIAN))
                  then 
                       if smk_known tracer_known = smk_known tracee_known 
                       then return 0
                       else 
                       if (smack_ptrace_rule shared) = SMACK_PTRACE_DRACONIAN 
                       then return (-EACCES)
                       else 
                       if smack_privileged_cred CAP_SYS_PTRACE tracercred 
                       then return 0
                       else return (-EACCES)
                     else do
                             rc &#8592; smk_tskacc s tsp tracee_known (smk_ptrace_mode m) (the saip);
                             return rc
                          od
                  );
           return rc
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_ptrace_access_check</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;Task &#8658; nat &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_ptrace_access_check s ctp m &#8801; 
      do
        skp &#8592; return(smk_of_task_struct s ctp);
        r &#8592; smk_ptrace_rule_check s (current_task s)  skp m &#39;&#39;smack_ptrace_access_check&#39;&#39;;
        return(r)
      od
&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_ptrace_traceme</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;Task &#8658;(State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_ptrace_traceme s ptp &#8801;
       do
          rc &#8592; return(SOME x:: int .True);
          skp &#8592; return (smk_of_current s);
          rc &#8592;smk_ptrace_rule_check s ptp skp PTRACE_MODE_ATTACH &#39;&#39;smack_ptrace_traceme&#39;&#39;;
          return (rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_syslog</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span class="string"><span class="delete"><span class="delete">&quot;smack_syslog s typefrom&#8801;
      do
      skp &#8592;return(smk_of_current s);
      slabel &#8592; return(smack_syslog_label shared);
      rc &#8592; ( if smack_privileged s CAP_MAC_OVERRIDE 
              then return 0 
              else 
              if slabel &#8800; skp 
              then return (uminus EACCES) 
              else return 0
            );
      return(rc)
      od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pol_tab s &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(pol_tab s c)((c,t) := a)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sorted_list_of_set&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SOME ta . &#8704;p obj. p &#8712; taskset &#8743; tab = tab((p,obj):= {}) &#8743; ta =ta(p:=tab)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; ta(p:= SOME tab . &#8704;p obj. p &#8712; taskset &#8743; tab = tab((p,obj):= {}))&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cursp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; process_id list&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cursp s &#8801; sorted_list_of_set {t .&#8704;p .tasks s = (tasks s)(t := Some p) }&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>createObjChgTab</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Subj &#8658; Obj &#8658;(Subj,Obj) policy_table&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;createObjChgTab s subj object&#39; &#8801; 
      let taskset = {t .&#8704;sb .tasks s = (tasks s)(t := Some sb) };
          subjlabel = smk_of_subjlabel s subj;
          objlabel = smk_of_objectlabel s object&#39;;
          right = smk_access_rules  subjlabel objlabel;
          tab = SOME tab . &#8704;p . p &#8712; taskset &#8743; tab = tab((p,object&#39;):= right)          
      in
        SOME ta . &#8704;p. p &#8712; taskset &#8743; ta =ta(p:=tab)
      &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>update_access_tab</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; process_id &#8658; Obj&#8658; State&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;update_access_tab s subj obj  &#8801; 
         let tab =  (pol_tab s);
         subjlabel =  (smk_of_subjlabel s subj);
         objectlabel =  (smk_of_objectlabel s obj);
         right = (smk_access_rules  subjlabel objectlabel);
         access =  ((pol_tab s subj)((subj,obj) := right))  
         in s&#10631;pol_tab := (pol_tab s)(subj :=access)&#10632;
        &quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>update</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Obj &#8658; (State&#39;, nat) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;update s obj &#8801;
  do 
    a&#39; &#8592; return(0);
    (a&#39;, result) &#8592; whileLoop 
    (&#955;(a&#39;, result) s. a&#39; &lt; length(cursp s))
    (&#955;(a&#39; ,result) . ( return (a&#39;+1,update_access_tab s (cursp s ! a&#39;) obj)))  
                            (a&#39;,  s);
  return a&#39;
  od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Superblock Hooks&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_sb_alloc_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; super_block &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span class="string"><span class="delete"><span class="delete">&quot;smack_sb_alloc_security s sb &#8801;
      do
      sbsp &#8592;return(SOME x :: superblock_smack option. True);
      rc &#8592; (if sbsp = None  
             then return (uminus ENOMEM)
             else do
                  sbsp&#8592;return( &#10631;smk_root = smack_known_floor,
                                 smk_floor = smack_known_floor,
                                 smk_hat = smack_known_hat,
                                 smk_default = smack_known_floor,
                                 smk_flags = 0 &#10632;
                              );
                   modify(&#955;s .s&#10631;sb_security := (sb_security s)(sb := Some sbsp )&#10632;);     
               return 0
               od);
      return(rc)
      od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_sb_free_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; super_block &#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_sb_free_security s sb &#8801; do
                   modify(&#955;s .s&#10631;sb_security := (sb_security s)(sb := None )&#10632;);
         return()
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_sb_copy_data</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; string&#8658;string &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_sb_copy_data s orig smackopts &#8801; do
         otheropts &#8592;return(SOME x :: string. True);
         r &#8592; (if length(otheropts) = 0 
               then return (uminus ENOMEM) 
               else return 0);
         return(r)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_parse_opts_str</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; string&#8658; opts &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_parse_opts_str s options opt &#8801; do
         r &#8592; (if length(options) = 0 then return 0 else return(uminus ENOMEM));
         return(r)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_set_mnt_opts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; super_block&#8658; opts &#8658; nat &#8658; nat&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_set_mnt_opts s sb opt kern_flags set_kern_flags &#8801; do
      
         root &#8592; return(s_root sb);
         inode &#8592; return(d_backing_inode s (the((sdentry s) root)));
         sp &#8592; return(the(sb_security s sb));
         num_opts &#8592; return (num_mnt_opts opt);
         rc &#8592; (if (smk_flags sp AND SMK_SB_INITIALIZED) &#8800; 0 
                then return 0 
                else if &#172;(smack_privileged s CAP_MAC_ADMIN) &#8743; num_opts &#8800; 0  
                      then return (-EPERM)
                      else return 0
                );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_ret s m= fst(the_run_state m s) &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_security_mnt_opts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; opts&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_security_mnt_opts s &#8801; opts s &quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_sb_kern_mount</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; super_block&#8658; int &#8658; string&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_sb_kern_mount s sb  f data &#8801; do
         options &#8592; (return data);
         rc &#8592;(if length(data) = 0 then ( smack_set_mnt_opts s sb (get_security_mnt_opts s) 0  0) 
               else do 
                  rc &#8592; smack_parse_opts_str s options (opts s);
                  rc&#8592; (if rc = 0  then return rc 
                        else ( smack_set_mnt_opts s sb (get_security_mnt_opts s) 0  0)
                      );
                 return rc
                    od
              );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_sb_statfs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_sb_statfs s d &#8801; do
         sbp &#8592; return(the (sb_security s (d_sb d)));
         ad &#8592; return (SOME x :: smk_audit_info .True);
         rc &#8592; smk_curacc s (smk_floor sbp) MAY_READ ad;
         rc &#8592; return(smk_bu_current s &#39;&#39;statfs&#39;&#39; (smk_floor sbp) MAY_READ rc );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; BPRM hooks&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ptrace_parent</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;Task &#8658; Task option&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ptrace_parent s tsk&#39; &#8801; if unlikely (ptrace tsk&#39;) then Some (the((tasks s) (parent tsk&#39;))) else None&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_bprm_set_creds</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; linux_binprm &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_bprm_set_creds s bprm &#8801; do
         inode &#8592; return(file_inode(lfiles bprm));
         bsp &#8592; return (the((t_security s) (lcred bprm)));
         rc &#8592; (if called_set_creds bprm &#8800; 0 then return 0 else
                do
                   isp &#8592; return ( the(i_security s inode));
                   if (the(smk_itask isp)) = (smk_task bsp) then return 0 else 
                   do
                      sbsp &#8592; return(the((sb_security s)(i_sb inode)));
                      if ((smk_flags sbsp) AND SMK_SB_UNTRUSTED) &#8800; 0 &#8743; 
                           (the(smk_itask isp) &#8800; smk_root sbsp)
                      then return 0 else
                       if (unsafe bprm AND LSM_UNSAFE_PTRACE) &#8800; 0  then 
                          do
                              rc &#8592; return 0;
                              tracer &#8592; return(ptrace_parent s (get_cur_task s));
                              rc &#8592; (if tracer &#8800; None then 
                              do
                                 rc &#8592; smk_ptrace_rule_check s (the tracer) (the(smk_itask isp))
                                             PTRACE_MODE_ATTACH &#39;&#39;smack_bprm_set_creds&#39;&#39;;
                                 return rc
                              od 
                              else return rc);
                              if rc &#8800; 0 then return rc
                              else do
                                    modify(&#955;s .s&#10631;t_security := 
                                                (t_security s)((lcred bprm) :=
                                                 Some(bsp&#10631;smk_task:= the(smk_itask isp)&#10632;))&#10632;
                                          );
                                     return 0
                                   od
                          od
                       else if (unsafe bprm) &#8800; 0 then return (-EPERM) 
                            else   
                                return 0
                   od
                od                
          );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inode hooks&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_alloc_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  inode &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_alloc_security s inode &#8801; do
         skp &#8592; (return (smk_of_current s));
         i_s &#8592; return(new_inode_smack skp);
         modify(&#955;s .s&#10631;i_security := (i_security s)(inode :=  i_s )&#10632;);
         rc &#8592;(if (i_security s inode )= None 
               then return (uminus ENOMEM) 
              else return 0
              );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_free_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; inode &#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_free_security s inode &#8801; do 
          modify(&#955;s .s&#10631;i_security := (i_security s)(inode :=  None )&#10632;);
         return ()
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_init_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  inode &#8658; inode &#8658; string &#8658;
                                         string &#8658; string &#8658;int&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_init_security s inode dir qstr name value len&#39; &#8801; do
         skp &#8592; (return (smk_of_current s));
         issp &#8592; (return (the(i_security s inode)));
         isp &#8592; return(smk_of_inode s inode);
         dsp &#8592; return(smk_of_inode s dir);
         rc &#8592;(if length(value) &#8800; 0 &#8743; len&#39; &#8800; 0 then 
                  do
                   may &#8592; smk_access_entry s (smk_known skp) (smk_known dsp) (smk_rules skp);
                   rc &#8592; (if ((may &gt; 0 &#8743; (may AND MAY_TRANSMUTE) &#8800; 0) &#8743; (smk_inode_transmutable s dir) &#8800; 0) 
                          then do
                                f &#8592; return (bitOR (smk_iflags issp) SMK_INODE_CHANGED );
                                 modify(&#955;s .s&#10631;i_security := (i_security s)(inode :=  Some (issp&#10631;smk_iflags := f &#10632;))&#10632;);
                                value &#8592; return(smk_known dsp); 
                                if length(value) = 0 
                                then  return (uminus ENOMEM) 
                                else return 0
                               od 
                          else 
                          if length(smk_known isp) = 0 
                          then  return (uminus ENOMEM)  
                          else return 0
                );
                  return (rc) 
                  od
               else return 0);
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_link</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry &#8658; inode &#8658; dentry &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_link s old dir new &#8801; do
         isp &#8592; (return (smk_of_inode s (the(d_backing_inode s old))));
         ad &#8592; return (SOME x :: smk_audit_info .True);
         rc &#8592; return (smk_bu_inode s (the(d_backing_inode s old)) MAY_WRITE 
                                   ((get_ret s (smk_curacc s isp  MAY_WRITE ad))));
         rc &#8592; (if rc = 0 &#8743; d_is_positive new  
               then return (smk_bu_inode s (the(d_backing_inode s new)) MAY_WRITE 
                                   ((get_ret s (smk_curacc s isp  MAY_WRITE ad))))
               else return rc);
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_unlink</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  inode &#8658;dentry&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_unlink s dir d &#8801; do
         ip&#8592; return(the(d_backing_inode s d));
         ad &#8592; return (SOME x :: smk_audit_info .True);
         rc &#8592; smk_curacc s (smk_of_inode s ip) MAY_WRITE ad;
         rc &#8592; return(smk_bu_inode s ip MAY_WRITE rc );
         rc &#8592; (if rc = 0
               then do
                     rc &#8592; smk_curacc s (smk_of_inode s dir) MAY_WRITE ad;
                     return(smk_bu_inode s dir MAY_WRITE rc )
                    od
               else return rc);
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_rmdir</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  inode &#8658;dentry&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_rmdir s dir d &#8801; do
         ip&#8592; return(the(d_backing_inode s d));
         ad &#8592; return (SOME x :: smk_audit_info .True);
         rc &#8592; smk_curacc s (smk_of_inode s ip) MAY_WRITE ad;
         rc &#8592; return(smk_bu_inode s ip MAY_WRITE rc );
         rc &#8592; (if rc = 0
               then do
                     rc &#8592; smk_curacc s (smk_of_inode s dir) MAY_WRITE ad;
                     return(smk_bu_inode s dir MAY_WRITE rc )
                    od
               else return rc);
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_rename</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  inode &#8658;dentry &#8658;  inode &#8658; dentry&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_rename s old_inode old_dentry new_indoe new_dentry &#8801; do
         isp&#8592; return(the(d_backing_inode s old_dentry));
         ad &#8592; return (SOME x :: smk_audit_info .True);
         rc &#8592; smk_curacc s (smk_of_inode s isp) MAY_READWRITE ad;
         rc &#8592; return(smk_bu_inode s isp MAY_READWRITE rc );
         rc &#8592; (if rc = 0 &#8743; d_is_positive(new_dentry)
               then do
                     rc &#8592; smk_curacc s (smk_of_inode s isp) MAY_READWRITE ad;
                     return(smk_bu_inode s (the(d_backing_inode s new_dentry)) MAY_READWRITE rc )
                    od
               else return rc);
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_permission</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  inode &#8658;int&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_permission s i fmask &#8801; do
         sbsp &#8592; (return  (the(sb_security s (i_sb i))));
         no_block &#8592; return(fmask AND MAY_NOT_BLOCK);
         f &#8592; return (fmask AND 15);
         rc&#8592; (if f = 0 then 
                  return 0 
               else if ((smk_flags sbsp) AND SMK_SB_UNTRUSTED) &#8800; 0 &#8743;
                       (smk_of_inode s i) &#8800; (smk_root sbsp) then return (uminus(EACCES))
                        else  if no_block &#8800; 0 then return (-ECHILD) else 
                    do
                       ad &#8592; return (SOME x :: smk_audit_info .True);
                       mask &#8592; return (nat f);
                       rc &#8592; smk_curacc s (smk_of_inode s i) mask ad;
                       rc &#8592; return(smk_bu_inode s i mask rc ); return rc
                    od
                    );    
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_setattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry &#8658;iattr &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_setattr s d attrs &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         rc&#8592; (if ((ia_valid attrs) AND  ATTR_FORCE)  &#8800; 0 then 
                  return 0 
               else  do
                     rc &#8592; smk_curacc s (smk_of_inode s (the(d_backing_inode s d))) MAY_WRITE ad;
                     return(smk_bu_inode s (the(d_backing_inode s d)) MAY_WRITE rc )
                    od);
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_getattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; path&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_getattr s p &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         inode &#8592;return (the(d_backing_inode s (p_dentry p)));
         rc &#8592; smk_curacc s (smk_of_inode s inode) MAY_READ ad;
         rc &#8592; return(smk_bu_inode s inode MAY_READ rc );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>xattr_ret</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry &#8658;xattr &#8658;string&#8658; int &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xattr_ret s dentry name value size&#39; flags&#39; &#8801; do
         ns &#8592; return (s_user_ns (d_sb dentry));
         rc &#8592; (if name = XATTR_NAME_SMACKTRANSMUTE &#8743; value &#8800; &#39;&#39;true&#39;&#39;
                then return (-EINVAL)
                else
                  cap_inode_setxattr  s dentry name value size&#39; flags&#39;
                );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>set_check_priv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xattr &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set_check_priv name &#8801; case name of XATTR_NAME_SMACK  &#8658; 1 |
                                            XATTR_NAME_SMACKIPIN &#8658; 1 |
                                            XATTR_NAME_SMACKIPOUT &#8658; 1 |
                                            XATTR_NAME_SMACKEXEC &#8658; 1 |
                                            XATTR_NAME_SMACKMMAP &#8658; 1 |
                                            XATTR_NAME_SMACKTRANSMUTE &#8658; 1 |
                                            _ &#8658; 0
&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>set_check_import</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xattr &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set_check_import name &#8801; case name of XATTR_NAME_SMACK  &#8658; 1 |
                                              XATTR_NAME_SMACKIPIN &#8658; 1 |
                                              XATTR_NAME_SMACKIPOUT &#8658; 1 |
                                              XATTR_NAME_SMACKEXEC &#8658; 1 |
                                              XATTR_NAME_SMACKMMAP &#8658; 1 |
                                              _ &#8658; 0
&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>set_check_star</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xattr &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set_check_star name &#8801; case name of XATTR_NAME_SMACKEXEC &#8658; 1 |
                                            XATTR_NAME_SMACKMMAP &#8658; 1 |
                                            _ &#8658; 0&quot;</span></span></span><span> 
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
definition smk_parse_smack :: &quot;string &#8658; int &#8658; char&quot;
  where &quot;smk_parse_smack str len&#39;&#8801; 
        let len = if len&#39; &#8804; 0 then int(length(str)) + 1 else len&#39;
        in
        if str ! 0 = CHR &#39;&#39;_&#39;&#39;  then char_of (-EINVAL) else char_of 1
        &quot;
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_import_entry</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; string &#8658; int&#8658; (State&#39;, smack_known option) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_import_entry s str len&#39; &#8801; do
         rc &#8592; return (Some(SOME x :: smack_known  .True));       
      
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_setxattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry &#8658;xattr &#8658;string&#8658; int &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_setxattr s dentry name value size&#39; flags&#39; &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         skp &#8592; return (SOME x :: smack_known option. True);
         check_priv &#8592; return (set_check_priv name);
         check_import &#8592; return(set_check_import name);
         check_star &#8592; return (set_check_star name);
         rc &#8592; xattr_ret  s dentry name value size&#39; flags&#39;;
         rc &#8592; (if (rc = 0) &#8743; check_import &#8800; 0 then 
               do 
                  skp &#8592; (
                          if size&#39; &gt; 0 then smk_import_entry s value size&#39;
                          else return None
                        );
                  if (skp = None) &#8744; 
                     (check_star &#8800; 0 &#8743; ((the(skp) = smack_known_star) &#8744; (the(skp) = smack_known_web))) 
                    then return (-EINVAL) 
                  else return 0
               od 
              else 
                return rc
               );
         inode &#8592;return (the(d_backing_inode s dentry));
         rc &#8592; smk_curacc s (smk_of_inode s inode) MAY_WRITE ad;
         rc &#8592; return(smk_bu_inode s inode MAY_WRITE rc );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_post_setxattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry &#8658;xattr &#8658;string&#8658; int &#8658; int &#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_post_setxattr s dentry name value size&#39; flags&#39; &#8801; do
         skp &#8592; return (SOME x :: smack_known .True);
         inode &#8592;return (the(d_backing_inode s dentry));
         isp &#8592; return (the(i_security s inode));
         if name = XATTR_NAME_SMACKTRANSMUTE then
         do
            modify(&#955;s .s&#10631;i_security := (i_security s)
                          (inode :=  Some(isp&#10631; smk_iflags := 
                            (bitOR (smk_iflags isp)  SMK_INODE_TRANSMUTE)&#10632;) )&#10632;);
            return()
         od else
            case name of XATTR_NAME_SMACK &#8658; 
              do 
              skp&#8592; smk_import_entry s value size&#39;;
              if skp &#8800; None then 
                  do modify(&#955;s .s&#10631;i_security := (i_security s)(inode :=  Some(isp&#10631; smk_inode := the skp&#10632;) )&#10632;);
                     return()
                 od else return ()
              od |
                      XATTR_NAME_SMACKEXEC &#8658;
              do 
              skp&#8592; smk_import_entry s value size&#39;;
              if skp &#8800; None then 
                  do modify(&#955;s .s&#10631;i_security := (i_security s)(inode :=  Some(isp&#10631; smk_itask := skp&#10632;) )&#10632;);
                     return()
                 od else return ()
              od |
                    XATTR_NAME_SMACKMMAP &#8658;
              do 
              skp&#8592; smk_import_entry s value size&#39;;
              if skp &#8800; None then 
                  do modify(&#955;s .s&#10631;i_security := (i_security s)(inode :=  Some(isp&#10631; smk_mmap :=  skp&#10632;) )&#10632;);
                     return()
                 od else return ()
              od  
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_getxattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry &#8658;xattr&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_getxattr s dentry name  &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         inode &#8592;return (the(d_backing_inode s dentry));
         rc &#8592; smk_curacc s (smk_of_inode s inode) MAY_READ ad;
         rc &#8592; return(smk_bu_inode s inode MAY_READ rc );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>xatrr_remove</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xattr &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xatrr_remove name &#8801; case name of XATTR_NAME_SMACK  &#8658; True |
                                            XATTR_NAME_SMACKIPIN &#8658; True|
                                            XATTR_NAME_SMACKIPOUT &#8658; True |
                                            XATTR_NAME_SMACKEXEC &#8658; True |
                                            XATTR_NAME_SMACKMMAP &#8658; True |
                                            XATTR_NAME_SMACKTRANSMUTE &#8658; True |
                                            _ &#8658; False&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span>sysConfig</span><span> </span><span class="delimiter">=</span><span> </span><span>CONFIG_USER_NS</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>privileged_wrt_inode_uidgid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ns &#8658; inode &#8658; bool&quot;</span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*undo *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;privileged_wrt_inode_uidgid ns i &#8801; True&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>capable_wrt_inode_uidgid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; =&gt; inode &#8658; int &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;capable_wrt_inode_uidgid s i cap &#8801; let ns = user_ns (current_cred (get_cur_task s)) in  
                              (ns_capable ns cap) &#8743; privileged_wrt_inode_uidgid ns i
&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cap_inode_removexattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry &#8658;xattr &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cap_inode_removexattr s dentry name  &#8801; do
         ns &#8592; return (s_user_ns (d_sb dentry));
         rc &#8592; (if name &#8800; XATTR_SECURITY_PREFIX then return 0 else
               if name = XATTR_NAME_CAPS then 
                 do
                    inode&#8592; return (d_backing_inode s dentry);
                    if inode = None then return (-EINVAL) else
                      if &#172;(capable_wrt_inode_uidgid s (the inode) CAP_SETFCAP) then return (-EPERM)
                      else
                      return 0
                 od
               else 
                if &#172;(ns_capable ns CAP_SYS_ADMIN) then return (-EPERM)
                else
                return 0
              );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_removexattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry &#8658;xattr&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_removexattr s dentry name  &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         rc &#8592; (if xatrr_remove name  then if &#172;(smack_privileged s CAP_MAC_ADMIN) then return (-EPERM)
               else return 0 
               else cap_inode_removexattr s dentry name);
         rc &#8592; (if rc &#8800; 0 then return rc else
                do
                   inode &#8592;return (the(d_backing_inode s dentry));
                   rc &#8592; smk_curacc s (smk_of_inode s inode) MAY_READ ad;
                   rc &#8592; return(smk_bu_inode s inode MAY_READ rc ); 
                    if rc &#8800; 0 then return rc
                    else 
                    do 
                        inode &#8592; return(the(d_backing_inode s dentry));
                        isp &#8592; return (the(i_security s inode));
                        if name = XATTR_NAME_SMACK then
                        do
                          sbp &#8592; return(d_sb dentry);
                          sbsp &#8592; return(the(sb_security s sbp));
                          modify(&#955;s .s&#10631;i_security := (i_security s)(inode :=  Some(isp&#10631; smk_inode :=  smk_default sbsp&#10632;) )&#10632;);
                          return 0
                        od
                        else 
                        if name = XATTR_NAME_SMACKEXEC then do
                           modify(&#955;s .s&#10631;i_security := (i_security s)(inode :=  Some(isp&#10631; smk_itask :=  None&#10632;) )&#10632;);
                           return 0
                          od
                        else
                        if name = XATTR_NAME_SMACKMMAP then do
                            modify(&#955;s .s&#10631;i_security := (i_security s)(inode :=  Some(isp&#10631; smk_mmap :=  None&#10632;) )&#10632;);
                            return 0
                         od
                        else if name = XATTR_NAME_SMACKTRANSMUTE then do
                              iflags &#8592; return(smk_iflags isp AND (NOT SMK_INODE_TRANSMUTE));
                              modify(&#955;s .s&#10631;i_security := (i_security s)(inode :=  Some(isp&#10631; smk_iflags :=  iflags&#10632;) )&#10632;);
                              return 0
                         od
                        else return 0
                        
                        
                    od
                od);
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;kstrdup str &#8801; if length(str) = 0 then None else Some str&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_getsecurity</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; inode &#8658;xattr&#8658; Void&#8658; bool&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_getsecurity s inode name buffer alloc  &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         isp &#8592; return (SOME x :: smack_known .True);
         ip &#8592; return (inode);
         rc &#8592; (if name = XATTR_SMACK_SUFFIX then 
               do
                 isp &#8592; return(smk_of_inode s inode);
                 return (length(smk_known isp))
               od 
                else do
                        sbp &#8592; return(i_sb ip);
                        if (s_magic sbp &#8800; SOCKFS_MAGIC) then return(-EOPNOTSUPP)
                        else do
                               sock &#8592; return (SOCKET_I ip);
                               ssp &#8592; return (the(sk_security s (the(sk sock ))));
                               rc &#8592;( if name = XATTR_SMACK_IPIN then 
                                      do isp&#8592; return(smk_in ssp);
                                          if alloc then do buffer &#8592; return(kstrdup (smk_known isp));
                                                           if buffer = None then return (ENOMEM)
                                                           else return(int (length(smk_known isp)))
                                                        od else return(int (length(smk_known isp)))
                                      od else
                                      if name = XATTR_SMACK_IPOUT then
                                          do isp&#8592; return(smk_out ssp);
                                          if alloc then do buffer &#8592; return(kstrdup (smk_known isp));
                                                           if buffer = None then return (-ENOMEM)
                                                           else return(int (length(smk_known isp)))
                                                        od else return(int (length(smk_known isp)))
                                      od
                                     else return ( -EOPNOTSUPP)
                             ); return rc
                             od
                          
                    od
  );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#10631;i_security := (i_security s)(inode := Some(nsp&#10631;smk_inode:= (the(skp)),
                                        smk_iflags :=(bitOR (smk_iflags nsp) SMK_INODE_INSTANT )&#10632;) )&#10632;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_setsecurity</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; inode &#8658;xattr&#8658; Void&#8658; nat &#8658; int&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_setsecurity s inode name value size&#39; flg   &#8801; do
         nsp &#8592; return (the ((i_security s) inode));
         value &#8592; return(SOME x. String x = value);
         skp &#8592; return (SOME x :: smack_known .True);
         rc &#8592; (if length(value) = 0 &#8744; size&#39; &gt; SMK_LONGLABEL &#8744; size&#39; = 0  then 
                 return (-EINVAL)
                else do
                        skp &#8592; smk_import_entry s value size&#39;;
                        if skp = None then return (-ENOMEM) else
                        if (name = XATTR_SMACK_SUFFIX) then
                         do
                           modify(&#955;s .s&#10631;i_security := (i_security s)(inode := Some(nsp&#10631;smk_inode:= (the(skp)),
                                        smk_iflags :=(bitOR (smk_iflags nsp) SMK_INODE_INSTANT )&#10632;) )&#10632;);
                           return 0
                         od 

                        else  if (s_magic (i_sb inode) &#8800; SOCKFS_MAGIC) then return(-EOPNOTSUPP)
                        else do
                               sock &#8592; return (SOCKET_I inode);
                               ssp &#8592; return (the(sk_security s (the(sk sock) )));
                               rc &#8592;( if name = XATTR_SMACK_IPIN then 
                                      do isp&#8592; return(smk_in ssp);
                                           modify(&#955;s .s);
                                         return 0
                                      od else
                                      if name = XATTR_SMACK_IPOUT then
                                          do isp&#8592; return(smk_out ssp);
                                         return 0
                                      od
                                     else return ( -EOPNOTSUPP)
                             ); return rc
                             od          
                    od
  );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_listsecurity</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; inode &#8658;Void&#8658;int&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_listsecurity s inode buffer buffer_size  &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         len &#8592; return(17);
         return(len)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_getsecid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  inode &#8658;int&#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_getsecid s inode secid&#39;  &#8801; do
         skp &#8592; return (smk_of_inode s inode);
         secid &#8592; return(smk_secid skp);
         return()
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;file hooks&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_file_name s f &#8801; SOME n . files s n = Some f&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span>  </span><span>smackfile</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Files&quot;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* &#8208;&#8208; update s (File (get_file_name s file&#39;)); *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_file_alloc_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smackfile&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_file_alloc_security s file&#39;  &#8801; do
         f&#8592; return (smk_of_current s); 
         fsp &#8592; return (f_security s file&#39;);
         if fsp &#8800; None then return (-EEXIST) 
         else do
         modify(&#955;s .s&#10631;f_security := (f_security s)(file&#39; := Some f)&#10632;);
         rc &#8592; return(0);
         return(rc)
         od
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_file_free_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smackfile&#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_file_free_security s file&#39;  &#8801; do
         fsp &#8592; return (f_security s file&#39;);
         if fsp = None then return () 
         else do
         modify(&#955;s .s&#10631;f_security := (f_security s)(file&#39; := None)&#10632;);
         return() od
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_file_ioctl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smackfile &#8658; IOC_DIR &#8658; nat&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_file_ioctl s file&#39; cmd arg  &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         inode &#8592; return(file_inode file&#39;);
          
          rc&#8592;(if unlikely(IS_PRIVATE(inode)) then return 0 else 
               do
                   rc &#8592; (case cmd of IOC_WRITE &#8658;
                              do 
                                rc &#8592; smk_curacc s (smk_of_inode s inode) MAY_WRITE ad;
                                return(smk_bu_file s file&#39; MAY_WRITE rc ) 
                              od |
                                      IOC_READ &#8658; 
                              do 
                                rc &#8592; smk_curacc s (smk_of_inode s inode) MAY_READ ad;
                                return(smk_bu_file s file&#39; MAY_READ rc )
                              od | _ &#8658; return 0);
                   return rc
               od);
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_file_lock</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smackfile &#8658; nat &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_file_lock s file&#39; cmd  &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         inode&#8592; return(file_inode(file&#39;));
         rc&#8592;(if unlikely(IS_PRIVATE(inode)) then return 0 else 
               do
                   rc &#8592; smk_curacc s (smk_of_inode s inode) MAY_LOCK ad;
                   return(smk_bu_file s file&#39; MAY_LOCK rc )
               od);
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_file_fcntl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smackfile &#8658; nat &#8658;nat&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_file_fcntl s file&#39; cmd arg &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         inode&#8592; return(file_inode(file&#39;));
         rc&#8592;(if unlikely(IS_PRIVATE(inode)) then return 0 else 
               if cmd =F_SETLK &#8744; cmd = F_SETLKW then 
                      do
                         rc &#8592; smk_curacc s (smk_of_inode s inode) MAY_LOCK ad;
                         return(smk_bu_file s file&#39; MAY_LOCK rc )
                      od
                   else if cmd = F_SETOWN &#8744; cmd = F_SETSIG then
                         do
                            rc &#8592; smk_curacc s (smk_of_inode s inode) MAY_WRITE ad;
                            return(smk_bu_file s file&#39; MAY_WRITE rc )
                         od
                        else 
                          return 0 
               );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_mmap_file</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smackfile option  &#8658; nat &#8658;nat &#8658; nat&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_mmap_file s file&#39; reqprot prot  flags&#39; &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         rc &#8592; (if file&#39; = None &#8744; (unlikely(IS_PRIVATE(file_inode(the(file&#39;))))) 
                then return 0 
                else do 
                       isp &#8592;  return(the(i_security s (file_inode(the(file&#39;)))));
                       if smk_mmap isp = None then return 0 else
                        do
                          sbsp &#8592; return(the( (sb_security s) (i_sb (file_inode( the (file&#39;))))));
                          if (smk_flags sbsp AND SMK_SB_UNTRUSTED) &#8800; 0 &#8743; (the(smk_mmap isp) &#8800; smk_root sbsp)
                          then return (-EACCES) 
                          else do
                                  mkp &#8592; return(the(smk_mmap isp));
                                  tsp &#8592; return(current_security s);
                                  skp &#8592; return(smk_of_current s);
                                  return 0
                               od    
                        od   
                      od
         );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>dac_mmap_min_addr</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>init_user_ns</span><span> </span><span class="delimiter">::</span><span> </span><span>ns</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cap_capable_boby</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Cred &#8658; ns &#8658;int &#8658;int&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cap_capable_boby s c ns cap audit &#8801; do         
         rc &#8592;(if ns = user_ns c then 
                  if (cap_raised (cap_effective c) cap) &#8800; 0 then return 0 else return (-EPERM)
               else 
                  if ns_level ns &#8804; ns_level (user_ns c) then return ( -EPERM)
                  else if  uid_eq (owner ns) (euid c)
                       then return 0 else return (-EPERM)
            );
         return rc
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cap_capable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Cred &#8658; ns &#8658;int &#8658;int&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cap_capable s c targ_ns cap audit &#8801; do         
         ns &#8592; return(targ_ns);  
         return(0)
        od&quot;</span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* do *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cap_mmap_addr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; nat&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cap_mmap_addr s addr &#8801; do
         ret&#8592; return (0);
         ret &#8592; (if addr &lt; dac_mmap_min_addr then do
                 ret &#8592;  cap_capable s (current_cred (get_cur_task s))  init_user_ns CAP_SYS_RAWIO  SECURITY_CAP_AUDIT; 
                 return ret
                 od
                 else return ret);
         return(ret)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_file_set_fowner</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smackfile&#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_file_set_fowner s file&#39; &#8801; do
         f&#8592; return (smk_of_current s);
          modify(&#955;s .s&#10631;f_security := (f_security s)(file&#39; := Some f)&#10632;);  
         return()
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>container_of_smack</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fown_struct &#8658; smackfile&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span class="string"><span class="delete"><span class="delete">&quot;container_of_smack fown  &#8801; SOME f . fown = f_owner f&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_file_send_sigiotask</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task &#8658; fown_struct &#8658;int&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_file_send_sigiotask s tsk&#39; fown signum &#8801; do 
          skp &#8592; return (SOME x :: smack_known .True);
          tkp &#8592; return (smk_of_task (the((t_security s) (current_cred tsk&#39;))) );
          file&#39; &#8592; return (container_of_smack fown);
          skp &#8592; return(the(f_security s file&#39;));
          rc &#8592; smk_access s skp tkp MAY_DELIVER None;
          rc &#8592; return(smk_bu_note s &#39;&#39;sigiotask&#39;&#39; skp tkp MAY_DELIVER rc);
          tcred &#8592; return(task_cred(tsk&#39;));
          rc &#8592; (if rc &#8800; 0 &#8743; (smack_privileged_cred CAP_MAC_OVERRIDE tcred)
                 then return 0 
                  else return rc);
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_file_receive</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smackfile&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_file_receive s file&#39; &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         may &#8592; return 0;
         inode&#8592; return(file_inode( file&#39;));
         rc&#8592;(if unlikely(IS_PRIVATE(inode)) then return 0 else 
               do 
                  rc &#8592; (if (s_magic (i_sb inode)) = nat SOCKFS_MAGIC  then 
                        do  
                          sock &#8592; return(SOCKET_I inode);
                          ssp &#8592; return(the(sk_security s (the(sk sock))));
                          tsp &#8592; return(current_security s );
                          rc &#8592; smk_access s (smk_task tsp) (smk_out ssp) MAY_WRITE (Some ad) ;
                          rc &#8592; return(smk_bu_file s file&#39; may rc);
                          rc &#8592; (if rc &lt; 0 then return rc
                                 else 
                                 do 
                                  rc &#8592; smk_access s (smk_in ssp) (smk_task tsp) MAY_WRITE (Some ad) ;
                                  rc &#8592; return(smk_bu_file s file&#39; may rc); return rc
                                 od
                                );
                          return rc   
                        od else if (f_mode file&#39; AND FMODE_READ) &#8800; 0 then 
                                do 
                                    may &#8592; return (MAY_READ);
                                    rc &#8592; smk_curacc s (smk_of_inode s inode) may ad;
                                    rc &#8592; return(smk_bu_file s file&#39; MAY_LOCK rc );
                                    return rc
                                
                                od else  if(f_mode file&#39; AND FMODE_WRITE) &#8800; 0 then 
                                do 
                                    may &#8592; return (bitOR may MAY_READ);
                                    rc &#8592; smk_curacc s (smk_of_inode s inode) may ad;
                                    rc &#8592; return(smk_bu_file s file&#39; MAY_LOCK rc );
                                    return rc
                                
                                od else 
                                      do
                                        rc &#8592; smk_curacc s (smk_of_inode s inode) may ad;
                                        rc &#8592; return(smk_bu_file s file&#39; MAY_LOCK rc );
                                        return rc
                                      od
                        );
                 
                   return(rc)
               od);
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_file_open</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smackfile&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_file_open s file&#39; &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         inode&#8592; return(file_inode( file&#39;));
         tsp &#8592; return(the(t_security s (f_cred file&#39;)));
         rc&#8592;( 
               do 
                   rc &#8592; smk_tskacc s tsp (smk_of_inode s inode) MAY_READ ad;
                   return(smk_bu_credfile s (f_cred file&#39;) file&#39;  MAY_READ rc )
               od);
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; task hooks &#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_cred_alloc_blank</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Cred &#8658; nat &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_cred_alloc_blank s cred&#39; gfp&#39; &#8801; do
         tsp &#8592; return (SOME x :: task_smack .True);
         t&#8592; return (SOME x :: smack_known .True);
         tsp&#8592; return(new_task_smack t t gfp&#39;);
         rc&#8592;( if tsp = None then return (-ENOMEM)
               else 
               do 
                modify(&#955;s .s&#10631;t_security := (t_security s)(cred&#39; := tsp )&#10632;);
                return 0
               od   
               );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_cred_free</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Cred &#8658;(State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_cred_free s cred&#39; &#8801; do
         tsp &#8592; return (SOME x :: task_smack .True);
          modify(&#955;s .s&#10631;t_security := (t_security s)(cred&#39; := None )&#10632;);
          return()
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_cred_prepare</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Cred &#8658;Cred &#8658; nat&#8658;(State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_cred_prepare s new old g &#8801; do
         old_tsp &#8592; return (the ((t_security s) old));
         new_tsp &#8592;return (SOME x :: task_smack .True);
         new_tsp &#8592; return(new_task_smack (smk_task old_tsp) (smk_task old_tsp) g );
         rc&#8592; (if new_tsp = None then return (-ENOMEM) 
              else do 
                     new_tsp&#39; &#8592; return(the(new_task_smack (smk_task old_tsp) (smk_task old_tsp) g));
                     modify(&#955;s .s&#10631;t_security := (t_security s)(new := new_tsp )&#10632;);
                     rc&#8592; (smk_copy_rules s (smk_rule new_tsp&#39;) (smk_rule old_tsp) g );
                     rc&#8592;( if rc &#8800; 0 then return rc else
                     do
                        rc&#8592; (smk_copy_relabel s (smk_relabel new_tsp&#39;) (smk_relabel old_tsp) g);
                        if rc &#8800; 0 then return rc 
                        else
                          return 0
                     od);
                     return rc
                   od
  );
          return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_cred_getsecid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Cred &#8658;u32&#8658;(State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_cred_getsecid s c seci &#8801; do
          skp &#8592; return (SOME x:: smack_known. True);
          skp&#8592;  return (smk_of_task (the (t_security s c)));
          seci &#8592; return(smk_secid skp);
          return()
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_kernel_act_as</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Cred &#8658;u32&#8658;(State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_kernel_act_as s cred&#39; seci &#8801; do
          new_tsp &#8592; return (the(t_security s cred&#39;));
          i&#8592; smack_from_secid  seci;
          modify(&#955;s .s&#10631;t_security := (t_security s)(cred&#39; := Some (new_tsp&#10631;smk_task := the i&#10632;) )&#10632;);
          return(0)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_kernel_create_files_as</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Cred &#8658; inode&#8658;(State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_kernel_create_files_as s new inode&#39; &#8801; do
          isp&#8592; return (the(i_security s inode&#39;));
          tsp &#8592; return (the(t_security s new));
           modify(&#955;s .s&#10631;t_security := (t_security s)(new := Some (tsp&#10631;smk_forked := smk_inode isp,smk_task := smk_forked tsp&#10632;) )&#10632;);
          return(0)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_cred_transfer</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Cred &#8658;Cred&#8658;(State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_cred_transfer s new old &#8801; do
          old_tsp&#8592; return (the(t_security s old));
          new_tsp &#8592; return (the(t_security s new));
          modify(&#955;s .s&#10631;t_security := (t_security s)
                      (new := Some (new_tsp&#10631;smk_forked := smk_task old_tsp,
                                            smk_task :=smk_task old_tsp  &#10632;) )&#10632;);
          return()
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_curacc_on_task</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task &#8658; int &#8658; string&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_curacc_on_task s p access&#39; caller&#39; &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         skp&#8592; return(smk_of_task_struct s p);
         rc&#8592;( do 
                   rc &#8592; smk_curacc s skp access&#39; ad;
                   return(smk_bu_task s p access&#39; rc )
               od);
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_task_setpgid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task &#8658; int &#8658;  (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_task_setpgid s p pgid  &#8801; do
         rc &#8592; smk_curacc_on_task s p MAY_WRITE &#39;&#39;smack_task_setpgid&#39;&#39;;   
         return(rc)od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_task_getpgid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task  &#8658;  (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_task_getpgid s p   &#8801; do
         rc &#8592; smk_curacc_on_task s p MAY_READ &#39;&#39;smack_task_getpgid&#39;&#39;;   
         return(rc)od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_task_getsid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task &#8658;  (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_task_getsid s p   &#8801; do
         rc &#8592; smk_curacc_on_task s p MAY_READ &#39;&#39;smack_task_getsid&#39;&#39;;   
         return(rc)od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_task_getsecid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task &#8658; nat &#8658;  (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_task_getsecid s p secid&#39;  &#8801; do
         skp&#8592; return(smk_of_task_struct s p);
         secid&#39;&#8592; return(smk_secid skp);
         return()od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_task_setnice</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task &#8658; int &#8658;  (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_task_setnice s p nice  &#8801; do
         rc &#8592; smk_curacc_on_task s p MAY_WRITE &#39;&#39;smack_task_setnice&#39;&#39;;   
         return(rc)od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_task_setioprio</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task &#8658; int &#8658;  (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_task_setioprio s p ioprio  &#8801; do
         rc &#8592; smk_curacc_on_task s p MAY_WRITE &#39;&#39;smack_task_setioprio&#39;&#39;;   
         return(rc)od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_task_getioprio</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task  &#8658;  (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_task_getioprio s p   &#8801; do
         rc &#8592; smk_curacc_on_task s p MAY_READ &#39;&#39;smack_task_getioprio&#39;&#39;;   
         return(rc)od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_task_setscheduler</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task &#8658;  (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_task_setscheduler s p   &#8801; do
         rc &#8592; smk_curacc_on_task s p MAY_WRITE &#39;&#39;smack_task_setscheduler&#39;&#39;;   
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_task_getscheduler</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task &#8658;  (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_task_getscheduler s p   &#8801; do
         rc &#8592; smk_curacc_on_task s p MAY_READ &#39;&#39;smack_task_setscheduler&#39;&#39;;   
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_task_movememory</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task &#8658;  (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_task_movememory s p   &#8801; do
         rc &#8592; smk_curacc_on_task s p MAY_WRITE &#39;&#39;smack_task_movememory&#39;&#39;;   
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_task_kill</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task &#8658;siginfo &#8658; int &#8658; Cred option&#8658;  (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_task_kill s p info sig cred&#39; &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         skp&#8592; return (SOME x :: smack_known .True);
         tkp &#8592; return(smk_of_task_struct s p);
         rc &#8592;(if sig = 0 then return 0 else  if cred&#39; = None then
                        do rc &#8592;(smk_curacc s tkp  MAY_DELIVER  ad);
                          return(smk_bu_task s p MAY_DELIVER rc) od
                       else do 
                              ad &#8592; return (Some ad);
                              skp &#8592; return (smk_of_task (current_security s));
                              rc &#8592; smk_access s skp tkp MAY_DELIVER ad;
                              rc &#8592; return (smk_bu_note s &#39;&#39;USB signal&#39;&#39; skp tkp MAY_DELIVER rc) ;
                              return rc
                            od
          );
         return(rc)
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_task_to_inode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task &#8658;  inode &#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_task_to_inode s p i  &#8801; do
         isp &#8592; return (the(i_security s i));
         skp &#8592; return(smk_of_task_struct s p);
         f &#8592; return(bitOR (smk_iflags isp)  SMK_INODE_INSTANT);
         modify(&#955;s .s&#10631;i_security  := (i_security s) (i := Some (isp&#10631;smk_inode := skp, smk_iflags := f&#10632; ))&#10632; );
         return()od
        &quot;</span></span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prepare_creds</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; State&#39; &#215; Cred option&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span class="string"><span class="delete"><span class="delete">&quot;prepare_creds s  &#8801; let task = get_cur_task s;
                               new = SOME x:: Cred. True;
                               old = cred task in
                       if fst(the_run_state( (smack_cred_prepare s new old 0)) s) &lt; 0 then (s,None)
                       else (s,Some new) &quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;kern_ipc_perm&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_msg_id</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  msg_msg&#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_msg_id s msg &#8801; SOME id . (msg_msgs s) id = Some msg&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_msg_queue_id</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_msg_queue_id s msg &#8801; SOME id . (msg_queues s) id = Some msg&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_flags_to_may</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_flags_to_may flag &#8801; let may = 0 in 
          if (flag AND S_IRUGO) &#8800; 0 
          then (bitOR may  MAY_READ) 
          else  
          if (flag AND S_IWUGO) &#8800; 0
          then (bitOR may MAY_WRITE)
          else 
          if (flag AND S_IXUGO) &#8800; 0
          then (bitOR may MAY_EXEC)
          else may&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_ipc_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; kern_ipc_perm &#8658; smack_known&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_ipc_security s ipc&#39; &#8801; (the((ipc_security s) ipc&#39;))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_ipc_permission</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_ipc_permission s ipp flag  &#8801; do
         ad &#8592; return (SOME x :: smk_audit_info .True);
         iskp &#8592; return (get_ipc_security s ipp);
         may &#8592; return(smack_flags_to_may flag);
         rc &#8592; smk_curacc s iskp may ad;
         rc&#8592; return(smk_bu_current s &#39;&#39;svipc&#39;&#39; iskp  may rc);
         return(rc)
  od&quot;</span></span></span><span>
</span><span>
</span><span>                                                   
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_ipc_getsecid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; nat &#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_ipc_getsecid s ipp flag  &#8801; do
         iskp &#8592; return (get_ipc_security s  ipp);
         secid &#8592; return(smk_secid iskp);
         return()od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_msg_msg_alloc_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  msg_msg &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_msg_msg_alloc_security s msg  &#8801; do
         skp &#8592; return (smk_of_current s );
         msgs &#8592; return (msg_security s msg);
         if msgs &#8800; None then return(-EEXIST)
         else do
         modify(&#955;s .s&#10631;msg_security := (msg_security s)(msg := Some skp)&#10632;);
         return(0)
         od
      od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_msg_msg_free_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  msg_msg &#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_msg_msg_free_security s msg  &#8801; do      
          msgs &#8592; return (msg_security s msg);
          if msgs = None then return ()
          else do
          modify(&#955;s .s&#10631;msg_security := (msg_security s)(msg := None)&#10632;);
          return()
         od
      od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_of_ipc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; State&#39;&#8658;kern_ipc_perm =&gt; smack_known&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_of_ipc s isp &#8801; get_ipc_security s isp&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_ipc_alloc_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_ipc_alloc_security s isp  &#8801; do
         skp &#8592; return (smk_of_current s );
           modify(&#955;s .s&#10631;ipc_security := (ipc_security s)(isp:= Some skp)&#10632;);
         return(0)
      od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_ipc_free_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_ipc_free_security s isp  &#8801; do
            modify(&#955;s .s&#10631;ipc_security := (ipc_security s)(isp:= None)&#10632;);
         return()
      od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_curacc_shm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_curacc_shm s isp access &#8801; do 
                                           ssp &#8592; return( smack_of_ipc s isp );
                                           ad &#8592; return( SOME x :: smk_audit_info .True);
                                           rc &#8592; smk_curacc s ssp access ad ;
                                           rc &#8592; return(smk_bu_current s &#39;&#39;shm&#39;&#39; ssp access rc);
                                           return rc
                                        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_shm_associate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_shm_associate s isp shmflg &#8801; do 
                                           may &#8592; return( smack_flags_to_may shmflg );
                                           rc &#8592; smk_curacc_shm s isp may;
                                           return rc
                                        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_shm_shmctl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; IPC_CMD &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_shm_shmctl s isp cmd &#8801; 
        do 
        rc &#8592; (case cmd of SHM_STAT =&gt; smk_curacc_shm s isp MAY_READ |
                           SHM_STAT_ANY &#8658; smk_curacc_shm s isp MAY_READ |               
                           IPC_STAT &#8658; smk_curacc_shm s isp MAY_READ |
                           SHM_LOCK &#8658; smk_curacc_shm s isp MAY_READWRITE |
                           SHM_UNLOCK &#8658; smk_curacc_shm s isp MAY_READWRITE |
                           IPC_SET &#8658; smk_curacc_shm s isp MAY_READWRITE |
                           IPC_RMID &#8658; smk_curacc_shm s isp MAY_READWRITE |
                           IPC_INFO &#8658; return 0 |
                           MSG_INFO &#8658; return 0 |
                           _ &#8658; return (-EINVAL)
               );
        return rc
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_shm_shmat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658;string&#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_shm_shmat s ipc&#39; shmaddr shmflg &#8801; do 
                                           may &#8592; return( smack_flags_to_may shmflg );
                                           rc &#8592; smk_curacc_shm s ipc&#39; may;
                                           return rc
                                        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_curacc_sem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_curacc_sem s isp access &#8801; do 
                                           ssp &#8592; return( smack_of_ipc s isp );
                                           ad &#8592; return( SOME x :: smk_audit_info .True);
                                           rc &#8592; smk_curacc s ssp access ad ;
                                           rc &#8592; return(smk_bu_current s &#39;&#39;sem&#39;&#39; ssp access rc);
                                           return rc
                                        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_sem_associate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_sem_associate s isp shmflg &#8801; do 
                                           may &#8592; return( smack_flags_to_may shmflg );
                                           rc &#8592; smk_curacc_sem s isp may;
                                           return rc
                                        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_sem_semctl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; IPC_CMD &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_sem_semctl s isp cmd &#8801; 
        do 
        rc &#8592; (case cmd of GETPID =&gt; smk_curacc_sem s isp MAY_READ |
                           GETNCNT &#8658; smk_curacc_sem s isp MAY_READ |
                           GETZCNT &#8658; smk_curacc_sem s isp MAY_READ |
                           GETVAL =&gt; smk_curacc_sem s isp MAY_READ |
                           GETALL &#8658; smk_curacc_sem s isp MAY_READ |
                           SEM_STAT &#8658; smk_curacc_sem s isp MAY_READ |
                           SEM_STAT_ANY &#8658; smk_curacc_sem s isp MAY_READ |
                           IPC_STAT &#8658; smk_curacc_sem s isp MAY_READ |
                           SETVAL &#8658; smk_curacc_sem s isp MAY_READWRITE |
                           SETALL &#8658; smk_curacc_sem s isp MAY_READWRITE |
                           IPC_SET &#8658; smk_curacc_sem s isp MAY_READWRITE |
                           IPC_RMID &#8658; smk_curacc_sem s isp MAY_READWRITE |
                           IPC_INFO &#8658; return 0 |
                           MSG_INFO &#8658; return 0 |
                           _ &#8658; return (-EINVAL)
               );
        return rc
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_sem_semop</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; sembuf &#8658; nat &#8658;int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_sem_semop s isp sops nsops alter &#8801; do 
                                           rc &#8592; smk_curacc_sem s isp MAY_READWRITE;
                                           return rc
                                        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_curacc_msq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_curacc_msq s isp access &#8801; do 
                                           msp &#8592; return( smack_of_ipc s isp );
                                           ad &#8592; return( SOME x :: smk_audit_info .True);
                                           rc &#8592; smk_curacc s msp access ad ;
                                           rc &#8592; return(smk_bu_current s &#39;&#39;msq&#39;&#39; msp access rc);
                                           return rc
                                        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_msg_queue_associate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_msg_queue_associate s isp msqflg &#8801; do 
                                           may &#8592; return( smack_flags_to_may msqflg );
                                           rc &#8592; smk_curacc_msq s isp may;
                                           return rc
                                        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_msg_queue_msgctl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658; IPC_CMD &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_msg_queue_msgctl s isp cmd &#8801; 
        do 
        rc &#8592; (case cmd of IPC_STAT =&gt; smk_curacc_msq s isp MAY_READ |
                           MSG_STAT &#8658; smk_curacc_msq s isp MAY_READ |
                           MSG_STAT_ANY &#8658; smk_curacc_msq s isp MAY_READ |
                           IPC_SET &#8658; smk_curacc_msq s isp MAY_READWRITE |
                           IPC_RMID &#8658; smk_curacc_msq s isp MAY_READWRITE |
                           IPC_INFO &#8658; return 0 |
                           MSG_INFO &#8658; return 0 |
                           _ &#8658; return (-EINVAL)
               );
        return rc
        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_msg_queue_msgsnd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658;  msg_msg &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_msg_queue_msgsnd s isp msg msqflg &#8801; do 
                                           may &#8592; return( smack_flags_to_may msqflg );
                                           rc &#8592; smk_curacc_msq s isp may;
                                           return rc
                                        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_msg_queue_msgrcv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  kern_ipc_perm &#8658;  msg_msg &#8658; Task&#8658;int&#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_msg_queue_msgrcv s isp msg p long msqflg &#8801; do 
                                           rc &#8592; smk_curacc_msq s isp MAY_READWRITE;
                                           return rc
                                        od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249; key &#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_key_id</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  key&#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_key_id s k &#8801; SOME id . (keys s) id = Some k&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_key_alloc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  key &#8658; Cred &#8658; nat &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_key_alloc s k c flg &#8801; do 
                         skp &#8592; return( smk_of_task (the((t_security s) c) ));
                          modify(&#955;s .s&#10631;key_security := (key_security s)(k :=  Some skp )&#10632;);
                          return 0
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_key_free</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  key  &#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_key_free s k  &#8801; do 
                         
                          modify(&#955;s .s&#10631;key_security := (key_security s)(k :=  None )&#10632;);
                          return ()
                          od&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;KEY_NEED_ALL &#8801; 63&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>key_ref_to_ptr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; key_ref_t =&gt; key option&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;key_ref_to_ptr s key_ref &#8801; (keys s) key_ref&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_key_permission</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; key_ref_t&#8658; Cred &#8658; nat &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_key_permission s key_ref c perm  &#8801; do 
                         tkp &#8592; return( Some(smk_of_task (the((t_security s) c) )));
                         ad &#8592; return( SOME x :: smk_audit_info .True);
                         request &#8592; return 0;
                         rc &#8592; (if (int perm) AND (NOT KEY_NEED_ALL) &#8800; 0 
                                then return (-EINVAL) 
                                else
                                  do
                                     keyp &#8592; return(key_ref_to_ptr s key_ref);
                                     rc &#8592; (if keyp = None then return (-EINVAL)
                                     else if (key_security s)(the keyp) = None then
                                           return 0
                                          else if tkp = None then
                                               return (-EACCES)
                                               else 
                                                if smack_privileged_cred CAP_MAC_OVERRIDE c then 
                                                  return 0 else 
                                                  do
                                                     request &#8592; (if ((int perm) AND 11) &#8800; 0 
                                                                  then return (bitOR request MAY_READ )
                                                                 else if ((int perm) AND 30) &#8800; 0 
                                                                       then  return (bitOR request MAY_WRITE )
                                                                 else 
                                                                    return 0
                                                                );
                                                      rc &#8592; smk_access s (the tkp) (the ((key_security s)(the keyp))) request (Some ad);
                                                      rc &#8592; return(smk_bu_note s &#39;&#39;key access&#39;&#39; (the tkp) (the ((key_security s)(the keyp))) request rc);
                                                      return rc
                                                  od
                                            );
                                     return rc
                                  od
                                );
                         
                          return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_key_getsecurity</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658;  key &#8658; string&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_key_getsecurity s k  buffer&#8801; do 
                          skp &#8592; return(key_security s k);
                          rc &#8592; (if skp = None then return 0 else 
                                   do 
                                      skp &#8592; return (the skp);
                                      copy &#8592; return (kstrdup (smk_known skp)); 
                                      if copy = None then return (-ENOMEM) else return (length(the(copy))+1)
                                   od
                              );
                          return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;sock&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>smacksock</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; sock&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>smacksocket</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; socket&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_socket_id</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smacksocket&#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_socket_id s sock &#8801; SOME id . (sockets s) id = Some sock&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_unix_stream_connect</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smacksock &#8658; smacksock &#8658; smacksock&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_unix_stream_connect s sock other newsk&#8801; do 
                          ssp &#8592; return(the(sk_security s sock));
                          osp &#8592; return(the(sk_security s other));
                          nsp &#8592; return(the(sk_security s newsk));
                          ad &#8592; return( SOME x :: smk_audit_info .True);
                          ad &#8592; return(Some ad);
                          rc &#8592; (if &#172;(smack_privileged s CAP_MAC_OVERRIDE) then 
                                   do
                                      skp &#8592; return (smk_out ssp);
                                      okp &#8592; return (smk_in osp);
                                      rc &#8592; smk_access s skp okp MAY_WRITE ad;
                                      rc &#8592; return(smk_bu_note s &#39;&#39;UDS connect&#39;&#39; skp okp MAY_WRITE rc);
                                      if rc = 0 then 
                                      do
                                           okp &#8592; return (smk_out osp);
                                           skp &#8592; return (smk_in ssp);
                                           rc &#8592; smk_access s okp skp MAY_WRITE ad;
                                           rc &#8592; return(smk_bu_note s &#39;&#39;UDS connect&#39;&#39; okp skp MAY_WRITE rc);
                                           return rc
                                      od else
                                     return rc
                                   od 
                                 else 
                                   return 0
                              );
                          return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_unix_may_send</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; socket &#8658; socket &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_unix_may_send s sock other &#8801; do 
                          ssp &#8592; return(the(sk_security s (the(sk sock))));
                          osp &#8592; return(the(sk_security s (the(sk other))));
                          ad &#8592; return( SOME x :: smk_audit_info .True);
                          ad &#8592; return(Some ad);
                          rc &#8592; (if (smack_privileged s CAP_MAC_OVERRIDE) then return 0 else
                                   do
                                      skp &#8592; return (smk_out ssp);
                                      okp &#8592; return (smk_in osp);
                                      rc &#8592; smk_access s skp okp MAY_WRITE ad;
                                      rc &#8592; return(smk_bu_note s &#39;&#39;UDS send&#39;&#39; skp okp MAY_WRITE rc);
                                     return rc
                                   od                                
                              );
                          return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>netlbl_sock_setattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sock &#8658; Sk_Family&#8658; netlbl_lsm_secattr &#8658;int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;netlbl_sock_setattr sk&#39; family secattr &#8801; -ENOSYS&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_netlabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; sock &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_netlabel s sock labeled &#8801; do 
                          ssp &#8592; return(the(sk_security s sock));
                          skp &#8592; return( SOME x :: smack_known .True);
                          ad &#8592; return( SOME x :: smk_audit_info .True);
                          ad &#8592; return(Some ad);
                          rc &#8592; (if (smk_out ssp =  (smack_net_ambient shared) 
                                              &#8744; labeled = SMACK_UNLABELED_SOCKET ) 
                                 then return 0 else
                                   do
                                      skp &#8592; return (smk_out ssp);
                                      rc &#8592; return(netlbl_sock_setattr sock (sk_family sock) (smk_netlabel skp) );
                                     return rc
                                   od                                
                              );
                          return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_socket_post_create</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smacksocket &#8658; Sk_Family 
                                               &#8658; int &#8658; int &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_socket_post_create s sock family type&#39; protocols kern &#8801; do 
                          ssp &#8592; return(sk sock);
                          rc &#8592; (if sk sock =  None then return 0 
                                 else 
                                  if family &#8800; PF_INET then 
                                      return 0
                                  else 
                                      smack_netlabel s (the(sk sock)) SMACK_CIPSO_SOCKET
                                );
                          return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_socket_socketpair</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smacksocket &#8658; smacksocket &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_socket_socketpair s socka sockb &#8801; do 
                          asp &#8592; return(the(sk_security s(the(sk socka))));
                          bsp &#8592; return(the(sk_security s (the(sk sockb))));
                          ask &#8592; return( the(sk socka));
                          bsk &#8592; return( the(sk sockb));
                          modify(&#955;s .s&#10631;sk_security := (sk_security s)(ask :=  Some(asp&#10631;smk_packet := Some(smk_out bsp)&#10632;))&#10632;);
                          modify(&#955;s .s&#10631;sk_security := (sk_security s)(bsk :=  Some(bsp&#10631;smk_packet := Some(smk_out asp)&#10632;))&#10632;);
                          rc &#8592; return(0);
                          return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_ipv6_port_label</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smacksocket &#8658; sockaddr &#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_ipv6_port_label s sock address &#8801;  return ()&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_socket_bind</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; socket &#8658; sockaddr &#8658;int&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_socket_bind s sock address addrlen &#8801; do   
                          socka &#8592; return(sk sock);                   
                          if socka &#8800; None &#8743; (sk_family (the(sk sock))) = PF_INET6 then
                          do
                            smk_ipv6_port_label s sock address;
                            return 0
                          od
                          else
                             return 0
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ipv4host_label_find</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat  &#8658;in_addr&#8658; (State&#39;,smack_known option) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ipv4host_label_find a&#39; siap &#8801;
  do (a&#39;, result) &#8592; whileLoop 
    (&#955;(a&#39;, result) siap. a&#39; &lt; length(smk_net4addr_list))
    (&#955;(a&#39; ,result) . ((if (int (s_addr (net4_smk_host (smk_net4addr_list ! a&#39;)))) =
                          ( int(s_addr siap) AND (int(s_addr (net4_smk_mask (smk_net4addr_list ! a&#39;)))))
                       then return (a&#39; + 1, Some (net4_smk_label (smk_net4addr_list ! a&#39;))) 
                       else return (a&#39; + 1, None))))  
                            (a&#39;, None);
  return result
  od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_ipv4host_label</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; sockaddr_in &#8658; (State&#39;, smack_known option) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_ipv4host_label s sip  &#8801; do    
                          siap &#8592; return(sin_addr sip);                     
                          rc &#8592; ipv4host_label_find 0 siap;
                          return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_netlabel_send</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; sock &#8658; sockaddr_in &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_netlabel_send s sock sap  &#8801; do     
                          skp &#8592; return (SOME x :: smack_known  .True);
                          hkp &#8592; return (SOME x :: smack_known  .True);                     
                          ssp &#8592; return(the(sk_security s sock));
                          ad &#8592; return( SOME x :: smk_audit_info .True);
                          hkp &#8592; smack_ipv4host_label s sap;
                          rc &#8592; (if hkp &#8800; None then 
                                 do
                                    sk_lbl &#8592; return SMACK_UNLABELED_SOCKET;
                                    skp &#8592; return (smk_out ssp);
                                    rc &#8592; smk_access s skp  (the hkp)  MAY_WRITE (Some ad);
                                    rc &#8592; return(smk_bu_note s &#39;&#39;IPv4 host check&#39;&#39; skp (the hkp) MAY_WRITE rc);
                                    if rc &#8800; 0 then return rc 
                                    else smack_netlabel s sock sk_lbl
                                 od
                                 else do
                                        sk_lbl &#8592; return SMACK_CIPSO_SOCKET;
                                        smack_netlabel s sock sk_lbl
                                      od 
                                );
                          return rc
                          
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_ipv6_localhost</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sockaddr_in6 &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_ipv6_localhost sip &#8801; True&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_ipv6host_label</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; sockaddr_in6 &#8658; (State&#39;, smack_known option) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_ipv6host_label s sip &#8801; do    
                          rc &#8592; return (SOME x :: smack_known option  .True);
                          rc &#8592; (if smk_ipv6_localhost sip then return (None) 
                                 else return rc );
                          return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_ipv6_check</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smack_known &#8658; smack_known 
                                     &#8658; sockaddr_in6 &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_ipv6_check s subj obj addr act  &#8801; do    
                           ad &#8592; return( SOME x :: smk_audit_info .True);
                           rc &#8592; smk_access s subj  obj  MAY_WRITE (Some ad);
                           rc &#8592; return(smk_bu_note s &#39;&#39;IPv6 check&#39;&#39; subj obj MAY_WRITE rc);
                           return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smk_ipv6_port_check</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; sock &#8658;sockaddr_in6 &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* list_for *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smk_ipv6_port_check s sock addr act  &#8801; do    
                           ad &#8592; return( SOME x :: smk_audit_info .True);
                           ssp &#8592; return(the(sk_security s sock));
                           skp &#8592; (if act = SMK_RECEIVING then smack_ipv6host_label s addr 
                                   else return (Some(smk_out ssp)));
                           obj &#8592; (if act = SMK_RECEIVING then return (Some(smk_in ssp))
                                   else smack_ipv6host_label s addr);
                  
                           rc &#8592; (if skp = None &#8743; obj = None 
                                  then smk_ipv6_check s (the skp) (the obj) addr act 
                                  else
                                      do 
                                        skp &#8592; (if skp = None then 
                                                  return (smack_net_ambient shared) 
                                                else 
                                                  return (the skp)
                                               );
                                        obj &#8592; (if obj = None then 
                                                  return (smack_net_ambient shared) 
                                                else 
                                                  return (the obj));
                                        rc &#8592;(if(&#172;(smk_ipv6_localhost addr)) then 
                                                smk_ipv6_check s ( skp) ( obj) addr act 
                                              else if act =  SMK_RECEIVING 
                                                    then return 0 
                                                   else 
                                                    smk_ipv6_check s skp obj addr act
                                         );
                                        return rc
                                      od
                                  );
                           return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sockaddr_to_sockaddr_in</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sockaddr =&gt; sockaddr_in&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sockaddr_to_sockaddr_in sap &#8801; ( SOME x :: sockaddr_in .True)&quot;</span></span></span><span>
</span><span>                                                     
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_socket_connect</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smacksocket &#8658; sockaddr&#8658;int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_socket_connect s sock sap addrlen &#8801; do                          
                          rc &#8592; return(0);
                          sk &#8592; return (sk sock);
                          ssp &#8592; return(the(sk_security s(the(sk))));
                          sap &#8592;  return( SOME x :: sockaddr_in .True);
                          sip &#8592;  return( SOME x :: sockaddr_in6 .True);
                          rc &#8592; (if sk = None then return 0 else do
                                  sk_family &#8592; return(sk_family (the(sk)));
                                  case sk_family of PF_INET &#8658; 
                                      do 
                                         ret &#8592; smack_netlabel_send s (the sk) sap;
                                         return ret
                                      od |         PF_INET6 &#8658; 
                                      do
                                         rsp &#8592; smack_ipv6host_label s sip;
                                         ret &#8592; smk_ipv6_check s (smk_out ssp) (the rsp) sip SMK_CONNECTING;
                                         return ret
                                      od | _ &#8658; return rc
                          od);
                          return rc    
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>getSockaddr_in</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Msghdr_name option &#8658; sockaddr_in option&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;getSockaddr_in  name &#8801; let e = SOME e.  Sockaddr_in e = the name in Some e&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;getSockaddr_in6  name &#8801; let e = SOME e.  Sockaddr_in6 e = the name in Some e&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;getSockaddr_in (msg_name msg)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_socket_sendmsg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smacksocket &#8658; msghdr&#8658;int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_socket_sendmsg s sock msg size&#39; &#8801; do                          
                          rc &#8592; return(0);
                          sip &#8592; return(getSockaddr_in (msg_name msg)); 
                          sap &#8592; return (getSockaddr_in6 (msg_name msg));
                          sk &#8592; return (the(sk sock));
                          ssp &#8592; return(the(sk_security s(sk)));
                          sk_family &#8592; return(sk_family sk);
                          rc &#8592; (if sip = None then return 0 else
                                  
                                  case sk_family of PF_INET &#8658; 
                                      do 
                                         ret &#8592; smack_netlabel_send s sk (the sip);
                                         return ret
                                      od |         PF_INET6 &#8658; 
                                      do
                                         rc &#8592;(if SMACK_IPV6_SECMARK_LABELING conf then 
                                         do
                                         rsp &#8592; smack_ipv6host_label s  (the sap);
                                         if rsp &#8800; None then 
                                         do
                                         ret &#8592; smk_ipv6_check s (smk_out ssp) (the rsp) (the sap) SMK_CONNECTING;
                                         return ret od else return rc
                                         od 
                                        else return rc);
                                         rc &#8592; (if SMACK_IPV6_PORT_LABELING conf then 
                                                do
                                                   ret &#8592; smk_ipv6_port_check s sk (the sap) SMK_SENDING;
                                                   return ret
                                                od 
                                                else 
                                                  return rc
                                                );
                                         return rc
                                      od | _ &#8658; return rc
                                  
                                );
                          return rc
                          
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>netlbl_skbuff_getattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sk_buff &#8658; Sk_Family &#8658; netlbl_lsm_secattr &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;netlbl_skbuff_getattr skb family secattr &#8801; (-ENOSYS)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_socket_sock_rcv_skb</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; sock &#8658; sk_buff&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_socket_sock_rcv_skb s sock skb &#8801; do                          
                          rc &#8592; return(0);
                          ssp &#8592; return(the(sk_security s sock));
                          sk_family &#8592; return(sk_family sock);
                          ad &#8592; return( SOME x :: smk_audit_info .True);
                          sadd &#8592; return( SOME x :: sockaddr_in6 .True);
                          secattr &#8592; return( SOME x :: netlbl_lsm_secattr .True);
                          family &#8592;(if sk_family = PF_INET6 &#8743; protocol skb = ETH_P_IP 
                                     then return(PF_INET)
                                    else return sk_family
                                  );
                          rc &#8592; (   
                                  case family of PF_INET &#8658;                                        
                                         if CONFIG_SECURITY_SMACK_NETFILTER conf then 
                                             if secmark skb &#8800; 0 then 
                                             do 
                                                skp&#8592; smack_from_secid (secmark skb);
                                                rc &#8592; smk_access s (the skp) (smk_in ssp) MAY_WRITE (Some ad);
                                                rc &#8592; return(smk_bu_note s &#39;&#39;IPv4 delivery&#39;&#39; (the skp) (smk_in ssp) MAY_WRITE rc);
                                                return rc
                                             od
                                             else  
                                              return (netlbl_skbuff_getattr skb family secattr)
                                          
                                         else
                                           return (netlbl_skbuff_getattr skb family secattr)
                                          
                                       |         PF_INET6 &#8658; 
                                      do
                                        skp&#8592; (if SMACK_IPV6_SECMARK_LABELING conf then 
                                                  if (secmark skb) &#8800; 0 then smack_from_secid (secmark skb)
                                                  else
                                                  smack_ipv6host_label s sadd
                                               else return( None));
                                        skp &#8592; (if skp = None then return (smack_net_ambient shared) 
                                                else return (the skp));
                                        rc &#8592; (if SMACK_IPV6_SECMARK_LABELING conf then
                                               do
                                                rc &#8592; smk_access s ( skp) (smk_in ssp) MAY_WRITE (Some ad);
                                                rc &#8592; return(smk_bu_note s &#39;&#39;IPv6 delivery&#39;&#39; ( skp) (smk_in ssp) MAY_WRITE rc);
                                                return rc
                                               od
                                               else if SMACK_IPV6_PORT_LABELING conf 
                                                    then smk_ipv6_port_check s sock sadd SMK_RECEIVING
                                                    else return rc
                                              );  
                                        return rc
                                      od | _ &#8658; return rc
                                  
                                );
                          return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_copy_to_user</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;string =&gt; string =&gt; nat =&gt; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span class="string"><span class="delete"><span class="delete">&quot;smack_copy_to_user from to n &#8801; let to = take n from in if(length to )= 0 then 1 else 0&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_put_user</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int =&gt; int  =&gt; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span class="string"><span class="delete"><span class="delete">&quot;smack_put_user x ptr &#8801; let x = ptr  in 0&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_socket_getpeersec_stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; socket &#8658; string&#8658;int &#8658;nat &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_socket_getpeersec_stream s sock optval optlen len&#39;&#8801; do                          
                          ssp &#8592; return(the(sk_security s (the(sk sock))));
                          rcp &#8592; return(&#39;&#39;&#39;&#39;);
                          slen &#8592; return(1);
                          rc &#8592; return (0);
                          sk &#8592; return (sk sock);
                          sk_family &#8592; return(sk_family (the sk));
                          rcp &#8592; (if (smk_packet ssp) &#8800; None 
                                  then return (smk_known (the(smk_packet ssp)))
                                 else return rcp);
                          slen &#8592; (if (smk_packet ssp) &#8800; None 
                                   then return (length((smk_known (the(smk_packet ssp))))+1) 
                                 else return slen);
                          rc &#8592; (if slen &gt; len&#39; then return (-ERANGE)
                                 else if (smack_copy_to_user optval rcp slen) &#8800; 0 
                                        then return (-EFAULT)
                                        else if (smack_put_user slen optlen &#8800; 0) 
                                              then return (-EFAULT) 
                                              else return rc
                                );
                          return rc    
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_from_secattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; netlbl_lsm_secattr &#8658; socket_smack &#8658; (State&#39;, smack_known ) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_from_secattr s sap ssp &#8801; do                          
                          rc &#8592; return( SOME x :: smack_known .True);      
                          return rc    
                          od&quot;</span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* do *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_socket_getpeersec_stream_t</span><span> </span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; socket &#8658; Sk_Family &#8658;netlbl_lsm_secattr &#8658;sk_buff &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_socket_getpeersec_stream_t s sock family secattr skb&#8801; do                          
                          sid &#8592; (if sk sock &#8800; None then 
                                    do
                                    ssp &#8592; return(the(sk_security s (the(sk sock))));
                                   
                                    rc &#8592; return (netlbl_skbuff_getattr skb family secattr);
                                    if rc = 0 then do skp&#8592; smack_from_secattr s secattr ssp; 
                                                  return (smk_secid skp)od else return 0
                                    od
                                  else return (0));                         
                          return sid    
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_socket_getpeersec_dgram</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; socket &#8658; sk_buff option&#8658;u32 &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_socket_getpeersec_dgram s sock skb secid&#39;&#8801; do                          
                          ssp &#8592; return(the(sk_security s (the(sk sock))));
                          family &#8592; return(PF_UNSPEC);
                          skb &#8592; return (the skb);
                          family &#8592; (if (protocol skb) = ETH_P_IP then return PF_INET 
                                    else if(CONFIG_IPV6 conf &#8743; (protocol skb) = ETH_P_IPV6)
                                         then return PF_INET6
                                    else if (family = PF_UNSPEC ) then 
                                            return (sk_family (the(sk sock)))
                                          else return family
                                    );
                          secattr &#8592; return( SOME x :: netlbl_lsm_secattr .True);
                          sid &#8592; (case family of PF_UNIX &#8658; return(smk_secid (smk_out ssp)) |
                                                 PF_INET &#8658; 
                                    (if CONFIG_SECURITY_SMACK_NETFILTER conf then 
                                       do
                                          sid &#8592; return(secmark skb);
                                          if (sid &#8800; 0) then return sid 
                                          else smack_socket_getpeersec_stream_t s sock family secattr skb
                                       od
                                    else 
                                       smack_socket_getpeersec_stream_t s sock family secattr skb)|
                                      PF_INET6 &#8658; if SMACK_IPV6_SECMARK_LABELING conf then return (secmark skb)
                                                  else return 0
                                 );
                          secid &#8592; return sid;
                          rc &#8592; if sid = 0 then return(-EINVAL)
                                else return (0);     
                          return rc    
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_sk_alloc_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; sock &#8658; int&#8658; gfp_t &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_sk_alloc_security s sock family flgs&#8801; do                          
                          skp &#8592; return(smk_of_current s);
                          ssp &#8592; return(sk_security s ( sock));
                          rc &#8592; return (0);
                          f &#8592; return ( flags (get_cur_task s) );
                          rc&#8592; (if ssp = None then return (-ENOMEM)
                                else if (f = PF_KTHREAD) then 
                                     do
                                       
                                       modify(&#955;s .s&#10631;sk_security := (sk_security s)(sock :=  
                                              Some(&#10631;smk_out = smack_known_web,
                                                    smk_in = smack_known_web,
                                                    smk_packet = None &#10632;))&#10632;); 
                                       return rc
                                     od
                                     else
                                       do
                                       
                                       modify(&#955;s .s&#10631;sk_security := (sk_security s)(sock :=  
                                                 Some(&#10631;smk_out = smack_known_web,
                                                       smk_in = smack_known_web,
                                                       smk_packet = None &#10632;))&#10632;); 
                                       return rc
                                     od
                              );
                         
                          return rc 
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_sk_free_security</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; sock &#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_sk_free_security s sock &#8801; do                                             
            modify(&#955;s .s&#10631;sk_security := (sk_security s)(sock :=  None)&#10632;); 
            return()
 od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_sock_graft</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; sock &#8658; socket &#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_sock_graft s sock parent&#39;&#8801; do                          
                          ssp &#8592; return(the(sk_security s ( sock)));
                          skp &#8592; return(smk_of_current s);
                          rc &#8592; ( if sk_family sock &#8800; PF_INET &#8743; sk_family sock &#8800; PF_INET6
                                        then return()
                                        else do
                                         modify(&#955;s .s&#10631;sk_security := (sk_security s)(sock := 
                                                      Some(ssp&#10631;smk_in := skp,smk_out := skp &#10632;))&#10632;);      
                                        return()
                                        od
                                 );
                          
                          return rc 
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>netlbl_req_setattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;request_sock =&gt; netlbl_lsm_secattr &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;netlbl_req_setattr req secattr &#8801; (-ENOSYS)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inet_conn_request</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; sock &#8658; sk_buff &#8658; request_sock &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inet_conn_request s sock skb req&#8801; do    
                          family &#8592; return(sk_family sock);                      
                          ssp &#8592; return(the(sk_security s ( sock)));
                          ad &#8592; return( SOME x :: smk_audit_info .True);
                          secattr &#8592; return( SOME x :: netlbl_lsm_secattr .True);
                          family &#8592; (if CONFIG_IPV6 conf &#8743; family = PF_INET6  &#8743; protocol skb = ETH_P_IP 
                                     then return(PF_INET) else return family);
                          rc &#8592; ( if &#172;(CONFIG_IPV6 conf &#8743; family = PF_INET6 &#8743; protocol skb = ETH_P_IP)
                                        then return(0)
                                        else 
                                          if CONFIG_SECURITY_SMACK_NETFILTER conf then do
                                            skp&#8592; (if secmark skb &#8800; 0 then 
                                                    smack_from_secid (secmark skb)
                                                   else return (None));
                                             rc &#8592; smk_access s (the skp) (smk_in ssp) MAY_WRITE (Some ad);
                                             rc &#8592; return(smk_bu_note s &#39;&#39;IPv4 connect&#39;&#39; (the skp) (smk_in ssp) MAY_WRITE rc);
                                             rc &#8592; (if rc &#8800; 0 then return rc else 
                                                       do
                                                          addr &#8592; return(SOME x:: sockaddr_in. True);
                                                          hskp &#8592; smack_ipv4host_label s addr ;
                                                          if hskp = None 
                                                          then 
                                                            return(netlbl_req_setattr req (smk_netlabel (the skp))) 
                                                          else 
                                                            return rc
                                                       od
                                                   );
                                             return rc
                                             od
                                             else  
                                              return 0   
                                 );
                          
                          return rc 
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inet_csk_clone</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; sock &#8658; request_sock &#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inet_csk_clone s sock req &#8801; do                          
                          ssp &#8592; return(the(sk_security s ( sock)));
                          skp &#8592; return(smk_of_current s);
                          (if peer_secid req &#8800; 0 
                                        then do skp &#8592; smack_from_secid (peer_secid req);
                                           modify(&#955;s .s&#10631;sk_security := (sk_security s)(sock := 
                                                      Some(ssp&#10631;smk_packet := skp &#10632;))&#10632;) od
                                        else 
                                         modify(&#955;s .s&#10631;sk_security := (sk_security s)(sock := 
                                                      Some(ssp&#10631;smk_packet := None &#10632;))&#10632;)      
                                        
                                        
                                 );                          
                          return () 
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; audit hook &#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_audit_rule_init</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; u32 &#8658; enum_audit &#8658; string &#8658; string&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_audit_rule_init s field op rulestr vrule &#8801; do 
                       skp &#8592; smk_import_entry s rulestr 0;                         
                       rc &#8592; (if field &#8800; AUDIT_SUBJ_USER &#8743; field &#8800; AUDIT_OBJ_USER 
                              then return (-EINVAL)
                              else if op &#8800; Audit_equal &#8743; op &#8800; Audit_not_equal then return (-EINVAL)
                                   else if skp = None then return (-ENOMEM) 
                                         else do rule &#8592; return(smk_known (the(skp)));
                                                 return 0 
                                              od
                            );                    
                       return rc
                       od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_audit_rule_known</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; audit_krule&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_audit_rule_known s krule &#8801;
   do 
    a&#39; &#8592; return(0);
    (a&#39;, result) &#8592; whileLoop 
    (&#955;(a&#39;, result) secid&#39;. a&#39; &lt; (field_count krule))
    (&#955;(a&#39; ,result) . ((if atype ( (afields krule) ! a&#39;) = AUDIT_SUBJ_USER &#8744; 
                          atype ( (afields krule) ! a&#39;) = AUDIT_OBJ_USER
                       then return (a&#39; + 1, 1) 
                       else return (a&#39; + 1, 0))))  
                            (a&#39;, 0);
  return result
  od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_audit_rule_match</span><span> </span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; u32 &#8658; u32&#8658;enum_audit &#8658; string&#8658;audit_context &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_audit_rule_match s  secid&#39; field op vrule actx &#8801; do 
                       rule &#8592; return(vrule);              
                       rc &#8592; (if unlikely (length(rule)) then return(-ENOENT) else
                              if field &#8800; AUDIT_SUBJ_USER &#8743; field &#8800; AUDIT_OBJ_USER then return 0
                              else do
                                      skp &#8592; smack_from_secid secid&#39;;
                                      if op = Audit_equal then if rule = smk_known (the skp) 
                                                                  then return 1 
                                                               else return 0
                                      else if op = Audit_not_equal then if rule &#8800; smk_known (the skp) 
                                                                        then return 1 else return 0
                                      else return 0
                                   od
                            );                    
                       return rc
                       od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;other&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_getprocattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; Task &#8658; string &#8658; string &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_getprocattr s p name value &#8801; do                          
                          skp &#8592; return (smk_of_task_struct s p);
                          cp &#8592; return(kstrdup (smk_known skp));
                          rc &#8592; (if length(the cp) = 0 then return (uminus ENOMEM) 
                                else return (length (the cp)));
                          return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_d_instantiate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry &#8658; inode option &#8658; (State&#39;, unit) nondet_monad&quot;</span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* undo*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_d_instantiate s opt_dentry inode &#8801; do                          
                          skp &#8592; return (smk_of_current s );

                          rc &#8592; (if inode = None then return ()
                                else do
                                        isp &#8592; return(the(i_security s (the inode)));
                                        if (smk_iflags isp AND SMK_INODE_INSTANT) &#8800; 0 then return()
                                        else do
                                                sbp &#8592; return(i_sb (the inode));
                                                sbsp &#8592; return(the(sb_security s sbp));
                                                 return()
                                             od
                                     od
                                
                                );
                          return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_setprocattr_known</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; smack_known list &#8658;smack_known&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_setprocattr_known s relabellist skp &#8801;
   do 
    a&#39; &#8592; return(0);
    (a&#39;, result) &#8592; whileLoop 
    (&#955;(a&#39;, result) secid&#39;. a&#39; &lt; (length relabellist))
    (&#955;(a&#39; ,result) . ((if  ( relabellist ! a&#39;) = skp 
                       then return (a&#39; + 1, 0) 
                       else return (a&#39; + 1, (-EPERM)))))  
                            (a&#39;, (-EPERM));
  return result
  od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_setprocattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; string &#8658; string &#8658; int &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_setprocattr s name value size&#39;&#8801; do  
                          tsp &#8592; return(current_security s);                        
                          rc &#8592; (if &#172;(smack_privileged s CAP_MAC_ADMIN) &#8743; length(smk_relabel tsp) = 0
                                then return (uminus EPERM) 
                                else 
                                if length(value) =0 &#8744; size&#39; = 0 &#8744; size&#39; &#8805; SMK_LONGLABEL 
                                then return (-EINVAL)
                                else if name &#8800; &#39;&#39;current&#39;&#39; 
                                     then return (-EINVAL) else
                                do
                                   skp &#8592; smk_import_entry s value size&#39;;
                                   if skp = None then return (-ENOMEM)
                                   else if (the skp) = smack_known_web &#8744; (the skp) = smack_known_star
                                        then return (-EINVAL)
                                        else if &#172;(smack_privileged s CAP_MAC_ADMIN) then
                                        do  
                                           rc &#8592; smack_setprocattr_known s (smk_relabel tsp) (the skp);
                                           return rc
                                        od 
                                            else
                                                do
                                                    new &#8592; return(snd(prepare_creds s));
                                                    if new = None then return (-ENOMEM) else
                                                    return size&#39;
                                                od
                                od
                                );
                          return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_ismaclabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; xattr &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_ismaclabel s name  &#8801; do                          
                         
                          rc &#8592; (if name = XATTR_SMACK_SUFFIX  then return (1) 
                                else return (0));
                          return rc
                          od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_secid_to_secctx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; u32 &#8658;string &#8658;u32 &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_secid_to_secctx s secid&#39; secdata seclen  &#8801; do                          
                          skp &#8592; smack_from_secid secid&#39;;
                          secdata &#8592; (if length(secdata) &#8800; 0 then return (smk_known (the skp)) 
                                else return secdata);
                          seclen &#8592; return (length(smk_known (the skp)));
                          return 0
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_secctx_to_secid</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39;  &#8658;string &#8658;u32 &#8658;u32&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_secctx_to_secid s secdata seclen  secid&#39; &#8801; do                          
                          skp &#8592; smk_find_entry secdata;
                          secid&#39; &#8592; (if skp = None then return (smk_secid (the skp)) 
                                else return (0));
                          return 0
                          od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_notifysecctx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39;  &#8658;inode &#8658;string &#8658;u32&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_notifysecctx s inode ctx ctxlen &#8801; 
          smack_inode_setsecurity s  inode XATTR_SMACK_SUFFIX (String ctx) ctxlen 0 &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vfs_setxattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry  &#8658;string &#8658;string &#8658; int &#8658; int&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;vfs_setxattr s dentry  name value size&#39; flgs &#8801; return 0 &quot;</span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* undo *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_bad_inode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inode &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_bad_inode inode &#8801; True &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vfs_setxattr_noperm&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry  &#8658;string &#8658;string &#8658; int &#8658; int&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;vfs_setxattr_noperm&#39; s dentry name value size&#39; flgs &#8801; do
              inode &#8592; return(get_inode s (d_inode dentry));
              error &#8592; return (-EAGAIN);
              inode &#8592; (if name &#8800; &#39;&#39;security.&#39;&#39; then do 
                        f &#8592; return ((int(i_flags (the inode))) AND (NOT S_NOSEC));
                        indoe &#8592; return((the inode)&#10631; i_flags := (nat f)&#10632;);
                        return (inode )                                
                        od
                        else return(inode));
              error &#8592; (if (int(i_opflags (the inode)) AND IOP_XATTR) &#8800; 0 
                        then 
                                vfs_setxattr s dentry  name value size&#39; flgs  
                             
                        else 
                             if is_bad_inode (the inode)  then return(-EIO)
                             else if (error = (-EAGAIN)) then
                                  return (-EOPNOTSUPP)   
                                  else return error
                             
                        );
              return error
           od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_setsecctx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39;  &#8658;dentry &#8658;string &#8658;u32&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_setsecctx s dentry ctx ctxlen &#8801; 
          vfs_setxattr_noperm&#39; s  dentry &#39;&#39;security.SMACK64&#39;&#39; ctx ctxlen 0 &quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_getsecctx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39;  &#8658;inode &#8658;string &#8658;u32&#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_getsecctx s inode ctx ctxlen &#8801; do 
          skp &#8592; return(smk_of_inode s inode);
          ctx &#8592; return(smk_known skp);
          ctxlen &#8592; return(length(smk_known skp));
          return 0
      od&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_copy_up</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry &#8658;Cred option &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_copy_up s dentry new&#8801; do 
          new_creds &#8592; return(new);
          rc &#8592; (if new_creds = None then
                 do 
                    new_creds &#8592; return(snd(prepare_creds s));
                    if new_creds = None then return (-ENOMEM) else 
                      do
                         tsp &#8592; return( t_security s (the new_creds));
                         isp &#8592; return (i_security s (the(get_inode s (d_inode (the(get_dentry s (d_parent dentry)))))));
                         skp &#8592; return(smk_inode (the isp));
                         modify(&#955;s .s&#10631;t_security := (t_security s)((the new_creds) := Some (the tsp &#10631; smk_task :=  skp &#10632; ))&#10632;);
                         new &#8592; return(new_creds);
                         return 0
                      od
                 od 
                else 
                return 0);
          
          return rc
      od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_inode_copy_up_xattr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39;  &#8658;xattr &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_inode_copy_up_xattr s name &#8801; if name = XATTR_NAME_SMACK then return 1
                                            else return (-EOPNOTSUPP) &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_dentry_create_files_as</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39; &#8658; dentry &#8658;mode &#8658;string &#8658;Cred &#8658;Cred &#8658; (State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_dentry_create_files_as s dentry mode&#39; name old new&#8801; do 
          otsp &#8592; return(the( t_security s old));
          ntsp &#8592; return(the( t_security s new));
          modify(&#955;s .s&#10631;t_security := (t_security s)(new := Some ( ntsp &#10631; smk_task :=  smk_task otsp &#10632; ))&#10632;);
          isp &#8592; return (the(i_security s (the(get_inode s (d_inode (the(get_dentry s (d_parent dentry))))))));
          if (smk_iflags isp AND SMK_INODE_TRANSMUTE) &#8800; 0 then 
          do  
             may &#8592; smk_access_entry s (smk_known (smk_task otsp)) (smk_known (smk_inode isp)) (smk_rules (smk_task otsp));
             (if may &gt; 0 &#8743; ((may AND MAY_TRANSMUTE) &#8800; 0) then 
                  modify(&#955;s .s&#10631;t_security := (t_security s)(new := Some ( ntsp &#10631; smk_task :=  smk_task otsp &#10632; ))&#10632;)
              else
                  modify(&#955;s .s&#10631;t_security := (t_security s)(new := Some ( ntsp &#10631; smk_task :=  smk_inode isp &#10632; ))&#10632;));
              return 0
          od
          else return 0
      od&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* smack_init - initialize the smack system *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>smack_init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;State&#39;&#8658;(State&#39;, int) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smack_init s &#8801; do
         cred&#39; &#8592; return (SOME x :: Cred .True);
         tsp &#8592; return (SOME x :: task_smack .True);
         cred&#39; &#8592; return (current_cred (current_task s));
         
         return(0)
        od&quot;</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
