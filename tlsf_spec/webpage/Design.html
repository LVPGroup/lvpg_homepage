<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Design (repository version)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Design</h1>

<span class="command">theory</span> <span class="name">Design</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Word/Word.html"><span class="name">Word</span></a> <a href="Log_Nat.html"><span class="name">Log_Nat</span></a> <a href="Lattice.html"><span class="name">Lattice</span></a> <a href="../../Lib/Lib/NonDetMonadVCG.html"><span class="name">NonDetMonadVCG</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Design</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HOL-Word.Word&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HOL-Library.Log_Nat&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HOL-Lattice.Lattice&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;HOL.Lattices&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Lib.NonDetMonadVCG&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span> </span><span>smt_solver</span><span> </span><span class="delimiter">=</span><span> </span><span>z3</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span> </span><span>smt_timeout</span><span> </span><span class="delimiter">=</span><span> </span><span>300</span><span> </span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span> </span><span>z3_options</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;-memory:1000&quot;</span></span></span><span> </span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>nat</span><span> </span><span class="delimiter">::</span><span> </span><span>leq</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>leq_nat_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p &#8849; q &#8801; (p::nat) &#8804; q&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>nat</span><span> </span><span class="delimiter">::</span><span> </span><span>quasi_order</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8849; x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leq_nat_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8849; y &#10233; y &#8849; z &#10233; x &#8849; z&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leq_nat_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>nat</span><span> </span><span class="delimiter">::</span><span> </span><span>partial_order</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>nat</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8849; y &#10233; y &#8849; x &#10233; x = y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leq_nat_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>nat</span><span> </span><span class="delimiter">::</span><span> </span><span>lattice</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;inf. is_inf x y inf&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_inf_def</span><span> </span><span>leq_nat_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Lattices.inf x y) &#8804; x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Lattices.inf x y)&#8804; y&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;z. z &#8804; x &#8743; z &#8804; y &#10230; z &#8804; (Lattices.inf x y)) &quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;inf&#8804;x. inf &#8804; y &#8743; (&#8704;z. z &#8804; x &#8743; z &#8804; y &#10230; z &#8804; inf)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sup. is_sup x y sup&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_sup_def</span><span> </span><span>leq_nat_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Lattices.sup x y) &#8805; x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#8804; (Lattices.sup x y)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;z. x &#8804; z &#8743; y &#8804; z &#10230; (Lattices.sup x y) &#8804; z) &quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sup&#8805;x. y &#8804; sup &#8743; (&#8704;z. x &#8804; z &#8743; y &#8804; z &#10230; sup &#8804; z)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>bhdr_t</span><span> </span><span class="delimiter">=</span><span> </span><span>Bhdr</span><span> </span><span class="delimiter">(</span><span>s_addr</span><span class="delimiter">:</span><span>nat</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>e_addr</span><span class="delimiter">:</span><span>nat</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* [prev_hdr impl with function type] BLOCK_STATE(free[False]|used[True]) PREV_STATE(prev_free[False]|prev_used[True]) addr_lft addr_rht *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>b_size</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_t &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b_size (Bhdr s e) = (1 + e - s)&quot;</span></span></span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* notice plus one should be ahead of minus s *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* type_synonym bitmap_t = &quot;nat &#8658; bool&quot; *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>word32</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;32 word&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>bitmap_t</span><span> </span><span class="delimiter">=</span><span> </span><span>word32</span><span>
</span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;we declare fl to get finite the set of all the free blocks in a segregation matrix
   l defines the logarithm in base 2 for the second level segregation list 
   sm is the logarithm in base 2 for the small block size, which will give the base size for
  first level segregations list for indexes bigger than 0. Index 0 will contain the free blocks 
  of size smaller than sm. 
  min block gives the minimum size block. This is included to discard those allocations of size 
 smaller than min block, otherwise the implementation would include behaviours not contained in
 the specification &#8250;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span>  </span><span>Sys_Config</span><span> </span><span class="delimiter">=</span><span>
</span><span>
</span><span>  </span><span>l</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span>sm</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span>min_block</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span>overhead</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span>mem_size</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>
</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* small :: nat
 min_block_size::nat
 POOL_SIZE :: nat
 align::nat *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>conf</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">specification</span></span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;conf&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span>mbiggerl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm conf &#8805; l conf&quot;</span></span></span><span> 
</span><span>  </span><span>min_block_gt_overhead</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_block conf &gt; overhead conf&quot;</span></span></span><span>
</span><span>  </span><span>oh_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;overhead conf &gt; 0&quot;</span></span></span><span> 
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* given oh = 0, a well formed block might be (0,0). Splitting this block with size 0 results in (0,0) and (0,0), which increases the
    total size of the memory. This is one of the disadvantages using nat! *)</span></span></span></span></span><span>
</span><span>  </span><span>total_mem_gt_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mem_size conf &gt; 0&quot;</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* so that we can prove all_blocks in finite *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10631; l = 0,  sm = 0, min_block = 2, overhead = 1,mem_size = 1&#10632;&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* definition l ::&quot;nat &#8658; nat&quot;
  where &quot;l sl_v &#8801;  nat ((bitlen sl_v) - 1)&quot;
  lemma &quot;l 37 = 5&quot;
proof-
  have &quot;bitlen 37 = 6&quot; 
  by (auto simp: bitlen_le_iff_power bitlen_ge_iff_power intro!: antisym)
  then show ?thesis
    unfolding l_def by auto
qed

*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sl</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sl cfg &#8801; 2 ^ (l cfg) &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>sl_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>bhdr_matrix_t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat &#8658; bhdr_t set&quot;</span></span></span><span>
</span><span>                             
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span>state_t</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>bhdr_matrix_f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_matrix_t&quot;</span></span></span><span>
</span><span>  </span><span>alloced_bhdr_s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_t set&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>block_alloced</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; state_t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr &#963; &#8801; &#8707;e_addr. (Bhdr addr e_addr) &#8712; (alloced_bhdr_s &#963;)&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_alloced_block</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; state_t &#8658; bhdr_t&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr &#963; &#8801; THE b. &#8707;e_addr. b = (Bhdr addr e_addr) &#8743; b &#8712; (alloced_bhdr_s &#963;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>set_bhdr_matrix</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_matrix_t &#8658; nat &#8658; nat &#8658; bhdr_t set &#8658; bhdr_matrix_t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set_bhdr_matrix m i j v &#8801; m(i:= (m i)(j:= v))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>insert_block_bhdr_matrix</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_matrix_t &#8658; nat &#8658; nat &#8658; bhdr_t  &#8658; bhdr_matrix_t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert_block_bhdr_matrix m i j b &#8801; set_bhdr_matrix m i j (insert  b (m i j))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>free_blocks</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; state_t &#8658; bhdr_t set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;free_blocks cfg &#963; &#8801; &#8899;{x. (&#8707;f s. s &lt; sl cfg &#8743; x = (bhdr_matrix_f &#963;) f s)}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>free_blocks_mat</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; bhdr_matrix_t &#8658; bhdr_t set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;free_blocks_mat cfg m &#8801; &#8899;{x. (&#8707;f s. s &lt; sl cfg &#8743; x = m f s)}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;free_blocks conf s = free_blocks_mat conf (bhdr_matrix_f s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_def</span><span> </span><span>free_blocks_mat_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>all_blocks</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; state_t &#8658; bhdr_t set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;all_blocks cfg &#963; &#8801; free_blocks cfg &#963; &#8746; alloced_bhdr_s &#963;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prev_hdr_s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; bhdr_t &#8658;  state_t &#8658; bhdr_t option&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;prev_hdr_s cfg b &#963; &#8801; 
   (let s = {b&#39;. (&#8704;s_addr e_addr. b = Bhdr s_addr e_addr &#10230; 
                      (&#8707;s_addr&#39; e_addr&#39;. b&#39; = Bhdr s_addr&#39; e_addr&#39; &#8743; 
                        b&#39; &#8712; all_blocks cfg &#963; &#8743; e_addr&#39; + 1 + overhead conf = s_addr)) } in
    if s = {} then None else Some (THE x. x &#8712; s))&quot;</span></span></span><span>
</span><span>     </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Cardinality brings in some complexity *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prev_free_hdr_s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; bhdr_t &#8658; state_t  &#8658; bhdr_t option&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s cfg b &#963; &#8801; 
  (let s = {b&#39;. (&#8704;s_addr e_addr. b = Bhdr s_addr e_addr &#10230; 
                      (&#8707;s_addr&#39; e_addr&#39;. b&#39; = Bhdr s_addr&#39; e_addr&#39; &#8743; 
                        b&#39; &#8712; free_blocks cfg &#963; &#8743; e_addr&#39; + 1 + overhead conf = s_addr)) } in
   if s = {} then None else Some (THE x. x &#8712; s))&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>suc_hdr_s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658;  bhdr_t &#8658; state_t  &#8658; bhdr_t option&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_s cfg b &#963; &#8801; 
  (let s = {b&#39;. (&#8704;s_addr e_addr. b = Bhdr s_addr e_addr &#10230; 
                      (&#8707;s_addr&#39; e_addr&#39;. b&#39; = Bhdr s_addr&#39; e_addr&#39; &#8743; 
                        b&#39; &#8712; all_blocks cfg &#963; &#8743; e_addr + 1 + overhead conf = s_addr&#39;)) } in
   if s = {} then None else Some (THE x. x &#8712; s))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>suc_hdr_free_s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; bhdr_t &#8658; state_t &#8658;  bhdr_t option&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s cfg b &#963; &#8801; 
    (let s = {b&#39;. (&#8704;s_addr e_addr. b = Bhdr s_addr e_addr &#10230; 
                      (&#8707;s_addr&#39; e_addr&#39;. b&#39; = Bhdr s_addr&#39; e_addr&#39; &#8743; 
                        b&#39; &#8712; free_blocks cfg &#963; &#8743; e_addr + 1 + overhead conf = s_addr&#39;)) } in
    if s = {} then None else Some (THE x. x &#8712; s))&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_alloc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_t &#8658; state_t &#8658; bool&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_alloc b &#963; &#8801; b &#8712; alloced_bhdr_s &#963;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_free</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; bhdr_t &#8658; state_t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_free cfg b &#963; &#8801; b &#8712; free_blocks cfg &#963;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>size_l1</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;size_l1  i &#8801; 2 ^ i &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>size_small_l1</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;size_small_l1 cfg i &#8801; 
   let size_i = if (i=0) then 2 else size_l1 i in  
       size_i * 2^(sm cfg -1)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>small_level_i_l_i&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;i&#39; &#10233; size_small_l1 cfg i &#8804; size_small_l1 cfg i&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>i&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i=i&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;i&#39;&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;size_small_l1 cfg i &#8804; size_small_l1 cfg i&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;size_small_l1 cfg i&#39; &#8804; size_small_l1 cfg (Suc i&#39;)&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>small_level_Suci_lt_Suci&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;i&#39; &#10233; size_small_l1 cfg (Suc i) &lt; size_small_l1 cfg (Suc i&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>i&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i=i&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;i&#39;&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;size_small_l1 cfg (Suc i) &lt; size_small_l1 cfg (Suc i&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;size_small_l1 cfg (Suc i&#39;) &lt; size_small_l1 cfg (Suc (Suc i&#39;))&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>range_l1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat &#8658; (nat&#215;nat) &quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range_l1 cfg 0 = (0, (size_small_l1 cfg 0) -1)&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range_l1 cfg (Suc n) = (size_small_l1 cfg (Suc n) ,2*size_small_l1 cfg (Suc n) - 1)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_small_level_gt_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc 0 &lt; size_small_l1 cfg n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span> </span><span>Suc_lessI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_g_1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x &gt; Suc 0 &#10233; n&gt;1 &#10233; x &lt; n*x - 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>add.commute</span><span> </span><span>mult_eq_if</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>range_l1_fst_lt_snd</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;fst (range_l1 cfg i) &lt; snd (range_l1 cfg i)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_g_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_small_level_gt_1</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_rang_i_eq_fst_rang_suc_i</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;snd (range_l1 cfg n) + 1 = fst (range_l1 cfg (Suc  n))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>range_level1_disj</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i &#8800; i&#39; &#10233; range_l1 cfg i &#8800; range_l1 cfg i&#39;&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>i&#39;</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>range_l1_def</span><span> </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>range_l1_snd_i_lt_fst_i&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; i&#39; &#10233; snd (range_l1 cfg i) &lt; fst (range_l1 cfg i&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&#39; - i -1&quot;</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&#39; = Suc i&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snd_rang_i_eq_fst_rang_suc_i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_add_one</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc i &lt; i&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = i&#39; - (Suc i) - 1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (range_l1 cfg (Suc i)) &lt; fst (range_l1 cfg i&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;snd (range_l1 cfg i) &lt; fst (range_l1 cfg (Suc i))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snd_rang_i_eq_fst_rang_suc_i</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_add_one</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>range_l1_fst_lt_snd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>range_l1_i_not_0</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&gt;0&quot;</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* sm cfg &#8805; sl cfg seems not necessary *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (range_l1 cfg i) = 2^(i + (sm cfg -1))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i= Suc i&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_pred&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (range_l1 cfg i) = (size_small_l1 cfg i)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>power_add</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>range_l1_i_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span class="string"><span class="delete"><span class="delete">&quot;fst (range_l1 cfg 0) = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>size_l2</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat &#8658;  nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;size_l2 cfg i  &#8801;(size_small_l1 cfg i) div (sl cfg)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>l2_i_j</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat &#8658; nat &#8658;  nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i j &#8801; fst (range_l1 cfg i)+(size_l2 cfg i)*j&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_level1_not_0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (range_l1 conf (Suc i)) &#8800; 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">,</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>power2gt0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a&#8804;b &#10233; 0&lt;a &#10233;((2::nat)^b div 2^a) &gt; 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Euclidean_Division.div_eq_0_iff</span><span> </span><span>div_positive</span><span> </span><span>gr0I</span><span> 
</span><span>            </span><span>nat_power_less_imp_less</span><span> </span><span>pos2</span><span> </span><span>power_not_zero</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>power2gt</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a&#8804;b &#10233; ((2::nat)^b div 2^a) &gt; 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>power2gt0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>power2gt1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a&#8804;b &#10233; c&gt;0 &#10233; ((c*((2::nat)^b)) div 2^a) &gt; 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>power2gt</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>div_less</span><span> </span><span>nat_mult_less_cancel1</span><span> </span><span>neq0_conv</span><span> </span><span>pos2</span><span> </span><span>td_gal_lt</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_l2_not_0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg &#10233; size_l2 cfg i&#8800;0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_l2_def</span><span> </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>nat_power_eq_Suc_0_iff</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>   
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred</span><span> </span><span>gr0I</span><span> </span><span>le_zero_eq</span><span> </span><span>power2gt</span><span> </span><span>power_Suc</span><span> </span><span>zero_le</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg&quot;</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>power2gt1</span><span> </span><span>Euclidean_Division.div_eq_0_iff</span><span> </span><span>le_Suc_eq</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>power_greater_mod_zero</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(i::nat)&#8805;j&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(2::nat)^i mod 2^j = 0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i= k+j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_add_diff_inverse2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(2::nat)^ ( k + j) = 2^ (k)* 2^j &quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>power_add</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>power_div_neutro</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(2::nat) * 2 ^ k * 2 ^ (sm cfg - Suc 0) div 2 ^ l cfg * 2 ^ l cfg = 2 * 2 ^ k * 2 ^ (sm cfg - Suc 0)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l cfg&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l cfg = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l cfg = Suc k&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>power_greater_mod_zero</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Suc_neq_Zero</span><span> </span><span>Suc_pred</span><span> </span><span>add.right_neutral</span><span> </span><span>assms</span><span> </span><span>div_mult_mod_eq</span><span> </span><span>gr0I</span><span> </span><span>le_zero_eq</span><span> </span><span>mod_mult_self2_is_0</span><span>
</span><span>    </span><span>power_Suc</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>16</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_l2_m_zero0</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i=0&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(size_l2 cfg i) = 2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_l2_def</span><span> </span><span>size_small_l1_def</span><span> </span><span>Let_def</span><span> </span><span>size_l1_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_l2_m_not_zero0</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &gt; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i=0&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(size_l2 cfg i) = (2^((sm cfg ) - (l cfg)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_l2_def</span><span> </span><span>size_small_l1_def</span><span> </span><span>Let_def</span><span> </span><span>size_l1_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>power_diff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_l2_i_not0</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&gt;0&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(size_l2 cfg i) = (2^(i + (sm cfg - 1) - (l cfg)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_l2_def</span><span> </span><span>size_small_l1_def</span><span> </span><span>Let_def</span><span> </span><span>size_l1_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Suc_neq_Zero</span><span> </span><span>Suc_pred</span><span> </span><span>a1</span><span> </span><span>add.commute</span><span> </span><span>add_Suc_right</span><span> 
</span><span>          </span><span>diff_Suc_Suc</span><span> </span><span>leD</span><span> </span><span>le_add1</span><span> </span><span>less_le_trans</span><span> </span><span>less_or_eq_imp_le</span><span> 
</span><span>          </span><span>linorder_neqE_nat</span><span> </span><span>numeral_2_eq_2</span><span> </span><span>power_add</span><span> </span><span>power_diff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_l2_m_not0_i_not0</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&gt;0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(sm cfg)= (Suc n)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(size_l2 cfg i) = (2^(i + n - (l cfg)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>size_l2_i_not0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span class="delimiter">]</span><span>  </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2_i_j_next</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i j + (size_l2 cfg i) = l2_i_j cfg i (Suc j)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_i_j_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2_i_j_pow2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg &#10233; j &lt; (sl cfg) &#10233; 
     l2_i_j cfg 0 j = ((2^(sm cfg - (l cfg)))*j)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_i_j_def</span><span> </span><span>size_l2_def</span><span> </span><span>size_small_l1_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_less_SucD</span><span> </span><span>le_zero_eq</span><span> </span><span>less_numeral_extra</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>      </span><span>less_trans_Suc</span><span> </span><span>power_diff</span><span> </span><span>power_eq_if</span><span> </span><span>zero_neq_numeral</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2_0_j_sm_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&lt;(sl cfg)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = 0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg 0 j = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>l2_i_j_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2_0_suc_j_sm_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&lt;(sl cfg)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = 0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg 0 (j+1) = 2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_i_j_def</span><span> </span><span>size_l2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_small_l1_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2_0_j_sm_not_0</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>            </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &gt; 0&quot;</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg 0 j = ((2^(sm cfg - (l cfg)))*j)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span>l2_i_j_def</span><span> </span><span>size_l2_m_not_zero0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2_Suc_i_j</span><span class="delimiter">:</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg (Suc i) j = 2^(Suc i + (sm cfg -1)) + ((2^(Suc i +(sm cfg -1) - (l cfg)))*j)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>l2_i_j_def</span><span> </span><span>range_l1_i_not_0</span><span> </span><span>size_l2_i_not0</span><span> </span><span>zero_less_Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2_ij_lt_ij&#39;</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg &#10233; j&lt;j&#39; &#10233; l2_i_j cfg i j &lt; l2_i_j cfg i j&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l2_i_j_next</span><span>  </span><span>size_l2_not_0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_i_j_def</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_l2_i_first_l1_Suc_i</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg &quot;</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i ((sl cfg) ) =  size_small_l1 cfg (Suc i)&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a00</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i=0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_i_j_def</span><span> </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span> </span><span>size_l2_def</span><span> </span><span>Let_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_pred</span><span> </span><span>div_by_Suc_0</span><span> </span><span>gr0I</span><span> </span><span>le_add_diff_inverse2</span><span> 
</span><span>      </span><span>le_zero_eq</span><span> </span><span>mult.right_neutral</span><span> </span><span>power_0</span><span> </span><span>power_Suc</span><span> </span><span>power_add</span><span> </span><span>power_diff</span><span> </span><span>zero_neq_numeral</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a00</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i = Suc k&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_i_j_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span> </span><span>size_l2_def</span><span> </span><span>Let_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>power_div_neutro</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_l2_i_eq_first_l2_Suc_i</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i (sl cfg)  = l2_i_j cfg (Suc i) 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last_l2_i_first_l1_Suc_i</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_i_j_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2_ij_lt_Suci0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j &lt; (sl cfg)&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i j &lt; l2_i_j cfg (Suc i) 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l2_ij_lt_ij&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span class="delimiter">]</span><span> </span><span>last_l2_i_eq_first_l2_Suc_i</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">]</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2_ij_lt_Sucij</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j &lt; (sl cfg)&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i j &lt; l2_i_j cfg (Suc i) j&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l2_ij_lt_ij&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>0</span><span> </span><span>j</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc i&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>l2_ij_lt_Suci0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nat.add_0_right</span><span> </span><span>dual_order.strict_trans1</span><span> 
</span><span>           </span><span>l2_i_j_def</span><span> </span><span>le_add1</span><span> </span><span>mult_0_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2_ij_lt_i&#39;j&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j &lt; (sl cfg)&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&#39; &lt; (sl cfg)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;i&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i j &lt; l2_i_j cfg i&#39; j&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i&#39;</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>l2_ij_lt_Sucij</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a00</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&#39; = Suc n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt; Suc n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i j &lt; l2_i_j cfg (Suc n) j&#39; &quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>a00</span><span> </span><span>l2_ij_lt_Sucij</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l2_ij_lt_Sucij</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a1</span><span> </span><span>a1&#39;</span><span> </span><span>less_antisym</span><span> </span><span>less_trans</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>range_l2</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat &#8658; nat &#8658; (nat&#215;nat)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;range_l2 cfg i j  &#8801; 
  (l2_i_j cfg i j, 
    l2_i_j cfg i j + (size_l2 cfg i) - 1) &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>range_l2_disj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg &#10233;
       fst (range_l2 cfg i j) &#8804; snd (range_l2 cfg i j)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>range_l2_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>size_l2_not_0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nat.add_diff_assoc2</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_leI</span><span> </span><span>add.commute</span><span> </span><span>fst_conv</span><span> </span><span>gr0I</span><span> </span><span>le_add2</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_range_l2_i_j_less_fst_j&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg &#10233; j &lt; j&#39; &#10233;
     snd( range_l2 cfg n j) &lt; fst (range_l2 cfg n j&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>range_l2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_lessI</span><span> </span><span>Suc_pred</span><span> </span><span>add_gr_0</span><span> </span><span>fst_conv</span><span> </span><span>lessI</span><span> </span><span>less_add_same_cancel1</span><span> 
</span><span>  </span><span>less_imp_diff_less</span><span> </span><span>snd_conv</span><span> </span><span>l2_ij_lt_ij&#39;</span><span> </span><span>l2_i_j_next</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_range_l2_i_j_less_fst_i&#39;_j&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&lt; sl cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&#39;&lt; sl cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; i&#39;&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd( range_l2 cfg i j) &lt; fst (range_l2 cfg i&#39; j&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>range_l2_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i j + size_l2 cfg i = l2_i_j cfg i (Suc j)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>l2_i_j_next</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i j + size_l2 cfg i - Suc 0 &lt; l2_i_j cfg i (Suc j)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a0</span><span> </span><span>diff_Suc_less</span><span> </span><span>gr_zeroI</span><span> </span><span>size_l2_not_0</span><span> </span><span>zero_eq_add_iff_both_eq_0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i (Suc j)&#8804; l2_i_j cfg (Suc i) 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_lessI</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>less_or_eq_imp_le</span><span> </span><span>l2_ij_lt_ij&#39;</span><span> </span><span>last_l2_i_eq_first_l2_Suc_i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg (Suc i) 0 &#8804; l2_i_j cfg i&#39; j&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc i = i&#39;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a0</span><span> </span><span>l2_ij_lt_ij&#39;</span><span> </span><span>less_mono_imp_le_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_lessI</span><span> </span><span>a0</span><span> </span><span>a1&#39;</span><span> </span><span>a2</span><span> </span><span>l2_ij_lt_i&#39;j&#39;</span><span> </span><span>le_add1</span><span> </span><span>le_add_same_cancel1</span><span> </span><span>less_imp_le_nat</span><span> </span><span>less_trans</span><span> </span><span>order.strict_iff_order</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; l2_i_j cfg i j + size_l2 cfg i - Suc 0 &lt; l2_i_j cfg i&#39; j&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_range_l2_i_j_less_snd_i&#39;_j&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; i&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&lt; sl cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&#39;&lt; sl cfg&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd( range_l2 cfg i j) &lt; snd (range_l2 cfg i&#39; j&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snd_range_l2_i_j_less_fst_i&#39;_j&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span>a3</span><span> </span><span>a1</span><span class="delimiter">]</span><span> </span><span>range_l2_disj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_le_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_range_l2_i_j_less_snd_i&#39;_j&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; i&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&lt; sl cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&#39;&lt; sl cfg&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst( range_l2 cfg i j) &lt; snd (range_l2 cfg i&#39; j&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snd_range_l2_i_j_less_fst_i&#39;_j&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span>a3</span><span> </span><span>a1</span><span> </span><span class="delimiter">]</span><span> </span><span>range_l2_disj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_less_trans</span><span> </span><span>less_le_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_range_l2_i_j_less_fst_i&#39;_j&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; i&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&lt; sl cfg&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&#39;&lt; sl cfg&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst( range_l2 cfg i j) &lt; fst (range_l2 cfg i&#39; j&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snd_range_l2_i_j_less_fst_i&#39;_j&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span>a3</span><span> </span><span>a1</span><span class="delimiter">]</span><span> </span><span>range_l2_disj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dual_order.strict_trans2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>range_l2_in_l1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j &lt; sl cfg&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (range_l2 cfg i j) &#8805; fst (range_l1 cfg i) &#8743;
               snd (range_l2 cfg i j) &#8804; snd (range_l1 cfg i)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (range_l2 cfg i j) &#8804; snd (range_l1 cfg i)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>range_l2_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i j + size_l2 cfg i = l2_i_j cfg i (Suc j)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>l2_i_j_next</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i (Suc j)&#8804; l2_i_j cfg i (sl cfg)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>l2_ij_lt_ij&#39;</span><span> </span><span>less_mono_imp_le_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i (sl cfg) = fst (range_l1 cfg (Suc i))&quot;</span></span></span><span>      
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last_l2_i_first_l1_Suc_i</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg i j + size_l2 cfg i - Suc 0
    &#8804; snd (range_l1 cfg i)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>One_nat_def</span><span> </span><span>le_diff_conv</span><span> </span><span>snd_rang_i_eq_fst_rang_suc_i</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (range_l2 cfg i j) &#8805; fst (range_l1 cfg i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>l2_i_j_def</span><span> </span><span>range_l2_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>l1_set</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat &#8658;  nat set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l1_set cfg i &#8801; 
     let r = range_l1 cfg  i in
        {m. m&#8805; fst r &#8743; m&#8804; snd r}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l1_set_disj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&#8800;i&#39; &#10230; (l1_set cfg i  &#8745; l1_set cfg i&#39;) = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l1_set_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>dual_order.trans</span><span> </span><span>leD</span><span> </span><span>less_linear</span><span> </span><span>range_l1_snd_i_lt_fst_i&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>l2_set</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat &#8658; nat &#8658; nat set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_set cfg i j &#8801; 
         let r = range_l2 cfg i j in
            {m. m&#8805; fst r &#8743; m&#8804; snd r}&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>r_gt_sm_0_i</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r_gt_sm_0_i r &#8801; (floorlog 2 r - 1)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>r_lt_sm_gt_0_j</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat &#8658; nat&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r_lt_sm_gt_0_j cfg r &#8801; (r div 2 ^ (sm cfg - l cfg))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>r_gt_sm_gt_0_i</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat &#8658; nat&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r_gt_sm_gt_0_i cfg r &#8801; (Suc ((floorlog 2 r) - 1 - (sm cfg)))&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>r_gt_sm_gt_0_j</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat &#8658; nat&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r_gt_sm_gt_0_j cfg r &#8801; ((r - (fst (range_l1 cfg (Suc ((floorlog 2 r) - 1 - (sm cfg)))))) div (size_l2 cfg (Suc ((floorlog 2 r) - 1 - (sm cfg)))))&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_l2_in_l1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j &lt; sl cfg&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_set cfg i j &#8838; l1_set cfg i&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_set_def</span><span> </span><span>l1_set_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">;</span><span>meson</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>dual_order.strict_trans1</span><span> </span><span>leD</span><span> </span><span>le_less_linear</span><span> </span><span>range_l2_in_l1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2_set_disj</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg &#8743; j&lt;(sl cfg) &#8743; j1&lt;(sl cfg) &#8743; &#172;(i=i1 &#8743; j=j1) &#10230; 
         (l2_set cfg i j &#8745; l2_set cfg i1 j1) = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_set_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j=j1&quot;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i=i1&quot;</span></span></span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&gt;i1&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>leD</span><span> </span><span>less_le_trans</span><span> </span><span>sl_def</span><span> </span><span>snd_range_l2_i_j_less_fst_i&#39;_j&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dual_order.trans</span><span> </span><span>linorder_neqE_nat</span><span> </span><span>not_le</span><span> </span><span>sl_def</span><span> </span><span>snd_range_l2_i_j_less_fst_i&#39;_j&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j&gt;j1&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>leD</span><span> </span><span>less_le_trans</span><span> </span><span>snd_range_l2_i_j_less_fst_j&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>dual_order.trans</span><span> </span><span>leD</span><span> </span><span>linorder_neqE_nat</span><span> </span><span>snd_range_l2_i_j_less_fst_j&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&gt;i1&quot;</span></span></span><span class="delimiter">;</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j&gt;j1&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">;</span><span> </span><span>metis</span><span> </span><span>leD</span><span> </span><span>le_less</span><span> </span><span>less_le_trans</span><span> </span><span>linorder_neqE_nat</span><span> </span><span>sl_def</span><span> </span><span>snd_range_l2_i_j_less_fst_i&#39;_j&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>j_i_sm_0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r &#8804; 2 ^ sm cfg - Suc 0 &#10233;
    i = 0 &#10233;
    l cfg &#8804; sm cfg &#10233;
    0 &lt; sm cfg &#10233; 
    j = r div 2 ^ (sm cfg - l cfg) &#10233;
    j&lt;2 ^ l cfg &#8743;
       2 ^ (sm cfg - l cfg) * j &#8804; r &#8743;
       r &#8804; 2 ^ (sm cfg - l cfg) * j + 2 * 2 ^ (sm cfg - Suc 0) div 2 ^ l cfg - Suc 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred</span><span> </span><span>le_add_diff_inverse</span><span> </span><span>le_imp_less_Suc</span><span> </span><span>less_mult_imp_div_less</span><span> </span><span>power_add</span><span> </span><span>zero_less_numeral</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_neq_Zero</span><span> </span><span>Suc_pred</span><span> </span><span>add.commute</span><span> </span><span>add_gr_0</span><span> </span><span>dividend_less_times_div</span><span> </span><span>less_Suc_eq_le</span><span> 
</span><span>     </span><span>mult.commute</span><span> </span><span>numeral_2_eq_2</span><span> </span><span>power_diff</span><span> </span><span>power_minus_mult</span><span> </span><span>zero_less_Suc</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_e</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(D::nat)&#8800;0 &#10233; E&#8800;0 &#10233; A&#8804;B &#10233; (B - C) div E &lt; D &#10233; (A - C) div E &lt; D&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>diff_le_mono</span><span> </span><span>div_le_mono</span><span> </span><span>le_less_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_e&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(D::nat)&#8800;0 &#10233; E&#8800;0 &#10233; A&lt;B &#10233; (B - C) div E &lt; D &#10233; (A - C) div E &lt; D&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_e</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>less_imp_le_nat</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r_small</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8804; 2 * size_l1 i * 2 ^ (sm cfg - Suc 0) - Suc 0 &#10233; r &lt; 2 * size_l1 i * 2 ^ (sm cfg - Suc 0)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_l1_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">,</span><span>  </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred</span><span> </span><span>le_imp_less_Suc</span><span> </span><span>mult_pos_pos</span><span> </span><span>zero_less_numeral</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_le_lessD</span><span> </span><span>Suc_le_mono</span><span> </span><span>Suc_pred</span><span> </span><span>mult_pos_pos</span><span> </span><span>zero_less_numeral</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>B_dvd_A_imp_A_less_1_div_B_less_A_div_B</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8800;0 &#10233; (B::nat) dvd A &#10233; (A-1) div B &lt; A div B&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_mult_imp_div_less</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>j_less_2_power_l</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>    </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; sm cfg &quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;l cfg &#8804; sm cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(2::nat) * 2 ^ i * 2 ^ (sm cfg - Suc 0) &#8804; r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r &#8804; 4 * 2 ^ i * 2 ^ (sm cfg - Suc 0) - Suc 0&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(r - 2 * 2 ^ i * 2 ^ (sm cfg - Suc 0)) div
    (2 * 2 ^ i * 2 ^ (sm cfg - Suc 0) div 2 ^ l cfg)
    &lt; 2 ^ l cfg&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((2::nat) * 2 ^ i * 2 ^ (sm cfg - Suc 0) div 2 ^ l cfg)&#8800;0&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>power2gt</span><span> </span><span>power_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_pred</span><span> </span><span>div_2_gt_zero</span><span> </span><span>div_mult_mult1</span><span> </span><span>gr0I</span><span> </span><span>le_neq_implies_less</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>mult.commute</span><span> </span><span>mult_eq_1_iff</span><span> </span><span>mult_pos_pos</span><span> </span><span>nat_one_le_power</span><span> </span><span>numeral_eq_iff</span><span> </span><span>numerals</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>one_le_mult_iff</span><span> </span><span>one_le_numeral</span><span> </span><span>power2gt1</span><span> </span><span>power_minus_mult</span><span> </span><span>power_not_zero</span><span> </span><span>semiring_norm</span><span class="delimiter">(</span><span>85</span><span class="delimiter">)</span><span> </span><span>zero_less_numeral</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(2::nat) ^ l cfg &#8800;0&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(((4::nat) * 2 ^ i * 2 ^ (sm cfg - Suc 0) - Suc 0) - 2 * 2 ^ i * 2 ^ (sm cfg - Suc 0)) div
    (2 * 2 ^ i * 2 ^ (sm cfg - Suc 0) div 2 ^ l cfg)
    &lt; 2 ^ l cfg&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg&quot;</span></span></span><span class="delimiter">;</span><span>  </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i = 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = Suc x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l cfg &#8804; Suc x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(2 * 2 ^ x - Suc 0) div (2 * 2 ^ x div 2 ^ l cfg) &lt; 2 ^ l cfg&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>Suc_neq_Zero</span><span> </span><span>a0</span><span> </span><span>j_i_sm_0</span><span> </span><span>less_or_eq_imp_le</span><span> </span><span>numeral_2_eq_2</span><span> </span><span>power_Suc</span><span> </span><span>power_diff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i&#39;</span><span> </span><span>sm&#39;</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i = Suc i&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = Suc sm&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;l cfg &#8804; Suc sm&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((4::nat) * 2 ^ i&#39; * 2 ^ sm&#39; div 2 ^ l cfg) dvd 4 * (2 ^ i&#39; * 2 ^ sm&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l cfg&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>div_dvd_iff_mult</span><span> </span><span>le_imp_power_dvd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((4::nat) * (2 ^ i&#39; * 2 ^ sm&#39;)) div (4 * 2 ^ i&#39; * 2 ^ sm&#39; div 2 ^ l cfg) = 2 ^ l cfg&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>div_div_eq_right</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>a0</span><span> </span><span>add_diff_cancel_left&#39;</span><span> </span><span>dvd_mult</span><span> </span><span>dvd_triv_right</span><span> </span><span>even_numeral</span><span> 
</span><span>        </span><span>le_Suc_eq</span><span> </span><span>le_imp_power_dvd</span><span> </span><span>mult.assoc</span><span> </span><span>mult_dvd_mono</span><span> </span><span>plus_1_eq_Suc</span><span> 
</span><span>        </span><span>power_commutes</span><span> </span><span>power_minus_mult</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(4::nat) * (2 ^ i&#39; * 2 ^ sm&#39;) &#8800;0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(4 * (2 ^ i&#39; * 2 ^ sm&#39;) - Suc 0) div (4 * 2 ^ i&#39; * 2 ^ sm&#39; div 2 ^ l cfg) &lt; 2 ^ l cfg&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B_dvd_A_imp_A_less_1_div_B_less_A_div_B</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_e</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;4 * 2 ^ ia * 2 ^ sma &#8804; r &#10233;
    r &#8804; 4 * 2 ^ (ia + sma) + 4 * 2 ^ (ia + sma) * ((r - 4 * 2 ^ ia * 2 ^ sma) div (4 * 2 ^ ia * 2 ^ sma)) +
         4 * 2 ^ ia * 2 ^ sma -
         Suc 0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>nat</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nata</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;4 * 2 ^ nat * 2 ^ nata &#8804; r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(0::nat) &lt; 4 * 2 ^ nat * 2 ^ nata&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &lt; 4 * 2 ^ nat * 2 ^ nata + 4 * 2 ^ nat * 2 ^ nata * (r div (4 * 2 ^ nat * 2 ^ nata))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>dividend_less_times_div</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;4 * (2::nat) ^ (nat + nata) = 4 * 2 ^ nat * 2 ^ nata&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>power_add</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;4 * 2 ^ nat * 2 ^ nata * Suc 0 = 4 * 2 ^ nat * 2 ^ nata&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;4 * 2 ^ nat * 2 ^ nata * (r div (4 * 2 ^ nat * 2 ^ nata)) = 4 * 2 ^ nat * 2 ^ nata * Suc 0 + 4 * 2 ^ (nat + nata) * ((r - 4 * 2 ^ nat * 2 ^ nata) div (4 * 2 ^ nat * 2 ^ nata))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>div_if</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &lt; 4 * 2 ^ (nat + nata) + (4 * 2 ^ (nat + nata) * ((r - 4 * 2 ^ nat * 2 ^ nata) div (4 * 2 ^ nat * 2 ^ nata)) + 4 * 2 ^ nat * 2 ^ nata)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8804; 4 * 2 ^ (nat + nata) + 4 * 2 ^ (nat + nata) * ((r - 4 * 2 ^ nat * 2 ^ nata) div (4 * 2 ^ nat * 2 ^ nata)) + 4 * 2 ^ nat * 2 ^ nata - Suc 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2</span><span class="delimiter">:</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>  </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;la &#8804; sma&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span class="string"><span class="delete"><span class="delete">&quot;r &#8804; 2 * 2 ^ sma +
         (2 ^ sma div 2 ^ la +
          2 ^ sma div 2 ^ la * ((r - 2 * 2 ^ sma) div (2 ^ sma div 2 ^ la))) -
         Suc 0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(r - 2 * 2 ^ sma) &lt;  2 ^ sma div 2 ^ la +
          2 ^ sma div 2 ^ la * ((r - 2 * 2 ^ sma) div (2 ^ sma div 2 ^ la))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span>  </span><span>a0</span><span> </span><span>power2gt</span><span> </span><span>dividend_less_times_div</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8804; 2 * 2 ^ sma +
         (2 ^ sma div 2 ^ la +
          2 ^ sma div 2 ^ la * ((r - 2 * 2 ^ sma) div (2 ^ sma div 2 ^ la))) -
         Suc 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; la &#8804; sma&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;4 * 2 ^ ia * 2 ^ sma &#8804; r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r &#8804; 8 * 2 ^ ia * 2 ^ sma - Suc 0&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8804; 4 * (2 ^ ia * 2 ^ sma) +
         (2 * (2 ^ ia * 2 ^ sma) div 2 ^ la +
          2 * (2 ^ ia * 2 ^ sma) div 2 ^ la *
          ((r - 4 * 2 ^ ia * 2 ^ sma) div (2 * (2 ^ ia * 2 ^ sma) div 2 ^ la))) -
         Suc 0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0&lt;(2::nat) * (2 ^ ia * 2 ^ sma) div 2 ^ la&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>power2gt1</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>power_add</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(r - 4 * 2 ^ ia * 2 ^ sma) &lt; 
               (2 * (2 ^ ia * 2 ^ sma) div 2 ^ la + 2 * (2 ^ ia * 2 ^ sma) div 2 ^ la *
               ((r - 4 * 2 ^ ia * 2 ^ sma) div (2 * (2 ^ ia * 2 ^ sma) div 2 ^ la)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dividend_less_times_div</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>j_sm_gt_0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; 0 &lt; sm cfg &#10233;
    range_l1 cfg (Suc i) =
    (size_l1 (Suc i) * (2::nat) ^ (sm cfg - Suc 0), 2 * size_l1 (Suc i) * 2 ^ (sm cfg - Suc 0) - Suc 0) &#10233;
    l cfg &#8804; sm cfg &#10233;
    size_l1 (Suc i) * 2 ^ (sm cfg - Suc 0) &#8804; r &#10233;
    r &#8804; 2 * size_l1 (Suc i) * 2 ^ (sm cfg - Suc 0) - Suc 0 &#10233;
    j = (r - (fst (range_l1 cfg (Suc i)))) div (size_l2 cfg (Suc i)) &#10233;
    j&lt;2 ^ l cfg &#8743; l2_i_j cfg (Suc i) j &#8804; r &#8743; r &#8804; l2_i_j cfg (Suc i) j + size_l2 cfg (Suc i) - Suc 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>l2_Suc_i_j</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_l2_def</span><span> </span><span>size_l1_def</span><span> </span><span>j_less_2_power_l</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg&quot;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l cfg&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_leE</span><span> </span><span>le_add2</span><span> </span><span>plus_1_eq_Suc</span><span>  </span><span>power_add</span><span> </span><span>power_diff</span><span>  </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>le_add_diff_inverse</span><span> </span><span>nat_add_left_cancel_le</span><span> </span><span>plus_1_eq_Suc</span><span> 
</span><span>                </span><span>power_Suc0_right</span><span> </span><span>power_add</span><span>  </span><span>times_div_less_eq_dividend</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>le_add_diff_inverse</span><span> </span><span>nat_add_left_cancel_le</span><span> </span><span>plus_1_eq_Suc</span><span> 
</span><span>                </span><span>power_Suc0_right</span><span> </span><span>power_add</span><span>  </span><span>times_div_less_eq_dividend</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_add_diff_inverse</span><span> </span><span>mult.assoc</span><span> </span><span>nat_add_left_cancel_le</span><span>  </span><span>times_div_less_eq_dividend</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>One_nat_def</span><span> </span><span>add_leE</span><span> </span><span>le_add2</span><span> </span><span>le_add_diff_inverse</span><span> </span><span>mult.assoc</span><span> </span><span>nat_add_left_cancel_le</span><span> </span><span>plus_1_eq_Suc</span><span> </span><span>power_Suc0_right</span><span> </span><span>power_add</span><span> </span><span>power_diff</span><span> </span><span>times_div_less_eq_dividend</span><span> </span><span>zero_neq_numeral</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>l2_Suc_i_j</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg&quot;</span></span></span><span class="delimiter">;</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l cfg&quot;</span></span></span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_leE</span><span> </span><span>le_add2</span><span> </span><span>plus_1_eq_Suc</span><span>   </span><span>power_add</span><span> </span><span>power_diff</span><span>  </span><span>Groups.add_ac</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>  </span><span>add.commute</span><span>  </span><span>dividend_less_times_div</span><span> </span><span>leD</span><span>   </span><span>not_less_eq_eq</span><span> </span><span>power2gt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>sma</span><span> </span><span>la</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>l2</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ia</span><span> </span><span>sma</span><span> </span><span>la</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>l3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_l1_in_l2_sm_0_i_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;l1_set cfg 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = 0&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0&lt; sl cfg &#8743; r &#8712; l2_set cfg 0 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_set_def</span><span> </span><span>Let_def</span><span> </span><span>range_l2_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>range_l1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;range_l1 cfg 0 = (0, 2^(Suc ((sm cfg -1))) -1)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_small_l1_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8805; 0 &#8743; r &#8804; 2^(Suc ((sm cfg -1))) -1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l1_set_def</span><span> </span><span>Let_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg 0 0 &#8804; r &#8743; 
                   r &#8804; l2_i_j cfg 0 0 + size_l2 cfg 0 - Suc 0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span>range_l1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_l2_def</span><span> </span><span>size_small_l1_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>l2_i_j_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg 0 0 &#8804; r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8804; l2_i_j cfg 0 0 + size_l2 cfg 0 - Suc 0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_l1_in_l2_sm_gt_0_i_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;l1_set cfg 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &gt; 0&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r div 2 ^ (sm cfg - l cfg) &lt; sl cfg &#8743; r &#8712; l2_set cfg 0 (r div 2 ^ (sm cfg - l cfg))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_set_def</span><span> </span><span>Let_def</span><span> </span><span>range_l2_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>range_l1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;range_l1 cfg 0 = (0, 2^(Suc ((sm cfg -1))) -1)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_small_l1_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8805; 0 &#8743; r &#8804; 2^(Suc ((sm cfg -1))) -1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l1_set_def</span><span> </span><span>Let_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot; r div 2 ^ (sm cfg - l cfg)&lt;2 ^ l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg 0 ( r div 2 ^ (sm cfg - l cfg)) &#8804; r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8804; l2_i_j cfg 0 ( r div 2 ^ (sm cfg - l cfg)) + size_l2 cfg 0 - Suc 0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span>range_l1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_l2_def</span><span> </span><span>size_small_l1_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>l2_0_j_sm_not_0</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_i_sm_0</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_l1_in_l2_sm_0_i_gt_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;l1_set cfg (Suc i)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = 0&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; sl cfg &#8743; r &#8712; l2_set cfg (Suc i) 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_set_def</span><span> </span><span>Let_def</span><span> </span><span>range_l2_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>range_l1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;range_l1 cfg (Suc i) = (size_l1 (Suc i) * 2^((sm cfg -1)), (2*size_l1 (Suc i) * 2^(sm cfg -1)) - 1)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_small_l1_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r &#8805; size_l1 (Suc i) * 2^((sm cfg -1)) &#8743; 
                   r &#8804; (2*size_l1 (Suc i) * 2^(sm cfg -1)) - 1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l1_set_def</span><span> </span><span>Let_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot; l2_i_j cfg (Suc i) 0 &#8804; r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot; r &#8804; l2_i_j cfg (Suc i) 0 + size_l2 cfg (Suc i) - Suc 0&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>range_l1</span><span> </span><span>a0</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>l2_i_j_def</span><span> </span><span>size_l1_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_l2_i_not0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_l1_in_l2_sm_gt_0_i_gt_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;l1_set cfg (Suc i)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &gt; 0&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(r - (fst (range_l1 cfg (Suc i)))) div (size_l2 cfg (Suc i)) &lt; sl cfg &#8743; 
                r &#8712; l2_set cfg (Suc i) ((r - (fst (range_l1 cfg (Suc i)))) div (size_l2 cfg (Suc i)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_set_def</span><span> </span><span>Let_def</span><span> </span><span>range_l2_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>range_l1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;range_l1 cfg (Suc i) = (size_l1 (Suc i) * 2^((sm cfg -1)), (2*size_l1 (Suc i) * 2^(sm cfg -1)) - 1)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_small_l1_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r &#8805; size_l1 (Suc i) * 2^((sm cfg -1)) &#8743; 
                   r &#8804; (2*size_l1 (Suc i) * 2^(sm cfg -1)) - 1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>calculation</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l1_set_def</span><span> </span><span>Let_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot; (r - size_small_l1 cfg (Suc i)) div size_l2 cfg (Suc i) &lt; 2 ^ l cfg &#8743; 
         l2_i_j cfg (Suc i) ((r - size_small_l1 cfg (Suc i)) div size_l2 cfg (Suc i)) &#8804; r &#8743;
         r &#8804; l2_i_j cfg (Suc i) ((r - size_small_l1 cfg (Suc i)) div size_l2 cfg (Suc i)) +
         size_l2 cfg (Suc i) - Suc 0&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>range_l1</span><span> </span><span>a0</span><span> </span><span>a2</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>j_sm_gt_0</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_l1_in_l2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8712;l1_set cfg i&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;j&lt; sl cfg. r &#8712; l2_set cfg i j&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a00</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i=0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>set_l1_in_l2_sm_0_i_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sma</span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a00</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i=0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = Suc sma&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>set_l1_in_l2_sm_gt_0_i_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ia</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a00</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i=Suc ia&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>set_l1_in_l2_sm_0_i_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ia</span><span> </span><span>sma</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a00</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i=Suc ia&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = Suc sma&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>set_l1_in_l2_sm_gt_0_i_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tlsf_matrix</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; bhdr_matrix_t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tlsf_matrix cfg t &#8801; 
        &#8704;i j. j&lt;(sl cfg) &#10230; 
            (&#8704;b. b &#8712; t i j &#10230; (b_size b) &#8712; l2_set cfg i j)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>block_in_range0</span><span class="delimiter">:</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;tlsf_matrix cfg t&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>      </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; t 0 j&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&lt;(sl cfg)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = 0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b_size b &#8805;  0 &#8743; ( b_size b &#8804; 2 - 1)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(b_size b) &#8805; l2_i_j cfg 0 j&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(b_size b) &#8804; (l2_i_j cfg 0 (Suc j) -1)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span>a1</span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tlsf_matrix_def</span><span> </span><span>l2_set_def</span><span> </span><span>range_l2_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span>l2_i_j_next</span><span>  </span><span>less_imp_le_nat</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a3</span><span> </span><span>a4</span><span> </span><span>l2_0_suc_j_sm_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>block_in_range1</span><span class="delimiter">:</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;tlsf_matrix cfg t&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>              </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; t 0 j&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&lt;(sl cfg)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &gt; 0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b_size b &#8805;  ((2^(sm cfg - (l cfg)))*j) &#8743; ( b_size b &#8804; ((2^(sm cfg - (l cfg)))*(Suc j)) - 1)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(b_size b) &#8805; l2_i_j cfg 0 j&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(b_size b) &#8804; (l2_i_j cfg 0 (Suc j) -1)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span>a1</span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tlsf_matrix_def</span><span> </span><span>l2_set_def</span><span> </span><span>range_l2_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span>l2_i_j_next</span><span>  </span><span>less_imp_le_nat</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a0</span><span> </span><span>a4</span><span> </span><span>l2_0_j_sm_not_0</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>block_in_range0&#39;</span><span class="delimiter">:</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;tlsf_matrix cfg t&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; t (Suc i) j&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&lt;(sl cfg)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b_size b &#8805; 2^(Suc i + (sm cfg -1)) + ((2^(Suc i+(sm cfg -1) - (l cfg)))*j) &#8743; 
           ( b_size b &#8804; 2^(Suc i + (sm cfg -1)) + ((2^(Suc i+(sm cfg - 1) - (l cfg)))*(j+1)) - 1)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(b_size b) &#8805; l2_i_j cfg (Suc i) j&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(b_size b) &#8804; (l2_i_j cfg (Suc i) (Suc j) -1)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span>a1</span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tlsf_matrix_def</span><span> </span><span>l2_set_def</span><span> </span><span>range_l2_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span>l2_i_j_next</span><span>  </span><span>less_imp_le_nat</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a0</span><span> </span><span>l2_Suc_i_j</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r_sm_gt_0_r_lt_2_sm</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>            </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &gt; 0&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8712; l2_set cfg 0 (r div (2^((sm cfg ) - (l cfg))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_set_def</span><span> </span><span>Let_def</span><span> </span><span>range_l2_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg 0 (r div 2 ^ (sm cfg - l cfg)) &#8804; r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l2_i_j cfg 0 (r div 2 ^ (sm cfg - l cfg)) = 
        ((2^(sm cfg - (l cfg)))*(r div 2 ^ (sm cfg - l cfg)))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l2_0_j_sm_not_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8804; l2_i_j cfg 0 (r div 2 ^ (sm cfg - l cfg)) +
         size_l2 cfg 0 -
         Suc 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l2_0_j_sm_not_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>add.commute</span><span> 
</span><span>              </span><span>add_gr_0</span><span> </span><span>dividend_less_times_div</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>size_l2_m_not_zero0</span><span> 
</span><span>              </span><span>zero_less_numeral</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r_l11</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>     </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &gt; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(floorlog 2 r) - 1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8805;sm cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8805; 2^(sm cfg)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;x&#39;. x = sm cfg + x&#39; &#8743; 
          r &#8805; size_small_l1 cfg (Suc x&#39;) &#8743;
          r &lt; size_small_l1 cfg (Suc (Suc x&#39;))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>F</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172; r&lt; 2^(sm cfg)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rgt2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8805;2&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>F</span><span> </span><span>le_less_linear</span><span> </span><span>less_2_cases</span><span> </span><span>nat_less_le</span><span> 
</span><span>               </span><span>nat_one_le_power</span><span> </span><span>nat_power_eq_Suc_0_iff</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;2^(floorlog 2 r - 1) &#8804; r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rtop</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r &lt; 2^(floorlog 2 r)&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>floorlog_bounds</span><span> </span><span>rgt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(sm cfg) + x&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_Suc_ex</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; size_small_l1 cfg (Suc x&#39;) &#8804; r&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>a4</span><span> </span><span>calculation</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_small_l1_def</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>a1</span><span> </span><span>add_Suc_right</span><span> </span><span>add_eq_if</span><span> </span><span>mult.commute</span><span> </span><span>neq0_conv</span><span> </span><span>power_add</span><span> </span><span>size_l1_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; r &lt; size_small_l1 cfg (Suc (Suc x&#39;))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtop</span><span> </span><span>a2</span><span> </span><span>a4</span><span> </span><span>a1</span><span> </span><span>x&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>size_small_l1_def</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred</span><span> </span><span>add.commute</span><span> </span><span>add_Suc_right</span><span> </span><span>add_gr_0</span><span> </span><span>le0</span><span> </span><span>less_nat_zero_code</span><span> 
</span><span>            </span><span>nat_less_le</span><span> </span><span>power_add</span><span> </span><span>size_l1_def</span><span> </span><span>zero_less_diff</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r_l1</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &gt; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8805; 2^(sm cfg)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;x x&#39;. x = sm cfg + x&#39; &#8743; r &#8712; l1_set cfg (Suc x&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>F</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172; r&lt; 2^(sm cfg)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rgt2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8805;2&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>F</span><span> </span><span>le_less_linear</span><span> </span><span>less_2_cases</span><span> </span><span>nat_less_le</span><span> 
</span><span>             </span><span>nat_one_le_power</span><span> </span><span>nat_power_eq_Suc_0_iff</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(floorlog 2 r) - 1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xgt0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&gt;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rgt2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>floorlog_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_gt_sm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8805;sm cfg&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>x</span><span> </span><span>rgt2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>floorlog_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_log2_of_power</span><span> </span><span>le_nat_floor</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>suc</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x = Suc x&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr0_implies_Suc</span><span> </span><span>xgt0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;2^(floorlog 2 r - 1) &#8804; r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rtop</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r &lt; 2^(floorlog 2 r)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>floorlog_bounds</span><span> </span><span>rgt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r_l11</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>x</span><span> </span><span>x_gt_sm</span><span> </span><span>a2</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l1_set_def</span><span>  </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>Suc_leI</span><span> </span><span>Suc_neq_Zero</span><span> </span><span>add_le_imp_le_diff</span><span> 
</span><span>            </span><span>mult.commute</span><span> </span><span>mult.left_commute</span><span> </span><span>numeral_2_eq_2</span><span> </span><span>power_Suc2</span><span> 
</span><span>           </span><span>size_l1_def</span><span> </span><span>size_small_l1_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>i_index_r_sm_gt_0</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &gt; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8805; 2^(sm cfg)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8712; l1_set cfg (Suc ((floorlog 2 r) - 1 - (sm cfg)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>F</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172; r&lt; 2^(sm cfg)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rgt2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8805;2&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>F</span><span> </span><span>le_less_linear</span><span> </span><span>less_2_cases</span><span> </span><span>nat_less_le</span><span> 
</span><span>             </span><span>nat_one_le_power</span><span> </span><span>nat_power_eq_Suc_0_iff</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(floorlog 2 r) - 1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xgt0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&gt;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rgt2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>floorlog_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_gt_sm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8805;sm cfg&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>x</span><span> </span><span>rgt2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>floorlog_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_log2_of_power</span><span> </span><span>le_nat_floor</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>suc</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x = Suc x&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr0_implies_Suc</span><span> </span><span>xgt0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;2^(floorlog 2 r - 1) &#8804; r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rtop</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r &lt; 2^(floorlog 2 r)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>floorlog_bounds</span><span> </span><span>rgt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r_l11</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>x</span><span> </span><span>x_gt_sm</span><span> </span><span>a2</span><span class="delimiter">]</span><span> </span><span>x</span><span> </span><span>a0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l1_set_def</span><span>  </span><span>Let_def</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_l1_def</span><span> </span><span>size_small_l1_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>i_index_r_sm_gt_0_r_lt_2</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &gt; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&lt; 2^(sm cfg)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8712; l1_set cfg 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l1_set_def</span><span> </span><span>Let_def</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; Suc (Suc 0) ^ sm cfg&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>zero_less_Suc</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8800; 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>gr_implies_not_zero</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8712; {m. fst (range_l1 cfg 0) &#8804; m &#8743; m &#8804; snd (range_l1 cfg 0)}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_small_l1_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_pred</span><span> </span><span>f1</span><span> </span><span>a2</span><span> </span><span>f3</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>numeral_2_eq_2</span><span> </span><span>power_eq_if</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>i_index_r_sm_eq_0</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8805; 2^(sm cfg)+1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8712; l1_set cfg ( ((floorlog 2 r) - 1 ))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>F</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172; r&lt; 2^(sm cfg)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rgt2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8805;2&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(floorlog 2 r) - 1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xgt0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&gt;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rgt2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>floorlog_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_gt_sm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8805;sm cfg&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>x</span><span> </span><span>rgt2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>floorlog_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_log2_of_power</span><span> </span><span>le_nat_floor</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>suc</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x = Suc x&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr0_implies_Suc</span><span> </span><span>xgt0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;2^(floorlog 2 r - 1) &#8804; r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rtop</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r &lt; 2^(floorlog 2 r)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>floorlog_bounds</span><span> </span><span>rgt2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;2 * 2 ^ x&#39; &#8804; r&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc</span><span> </span><span>x</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8804; 2 * 2 ^ x&#39; + size_l2 cfg (Suc x&#39;) - Suc 0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtop</span><span>  </span><span>suc</span><span> </span><span>x</span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span>  </span><span>Suc_leI</span><span> </span><span>xgt0</span><span> </span><span>suc</span><span> 
</span><span>              </span><span>add.commute</span><span> </span><span>add_cancel_right_right</span><span> </span><span>add_le_imp_le_diff</span><span> </span><span>a0</span><span> </span><span>a1</span><span> 
</span><span>              </span><span>diff_is_0_eq</span><span> </span><span>diff_zero</span><span> </span><span>gr_implies_not0</span><span> </span><span>le_add1</span><span> </span><span>le_add2</span><span> </span><span>mult_2</span><span> </span><span>plus_1_eq_Suc</span><span> 
</span><span>              </span><span>power_Suc</span><span> </span><span>power_eq_if</span><span> </span><span>size_l2_i_not0</span><span> </span><span>zero_less_diff</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>a0</span><span> </span><span>a1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l1_set_def</span><span>  </span><span>Let_def</span><span>  </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l1_set_def</span><span>  </span><span>Let_def</span><span>  </span><span>size_small_l1_def</span><span> </span><span>size_l1_def</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_l2_i_not0</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>i_index_r_sm_eq_0_r_lt_2</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&lt; 2^(sm cfg)+1&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8712; l1_set cfg 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l1_set_def</span><span> </span><span>Let_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_small_l1_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_r_in_l2_sm_0_r_lt_sm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&lt; 2^(sm cfg)+1&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; sl cfg &#8743; 
               r &#8712; l2_set cfg 0 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_index_r_sm_eq_0_r_lt_2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>set_l1_in_l2_sm_0_i_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>_</span><span> </span><span>a1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_r_in_l2_sm_0_r_geqt_sm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8805; 2^(sm cfg)+1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; sl cfg &#8743; r &#8712; l2_set cfg (r_gt_sm_0_i r) 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_index_r_sm_eq_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>set_l1_in_l2_sm_0_i_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>_</span><span> </span><span>a1</span><span class="delimiter">]</span><span> </span><span>a2</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>le_0_eq</span><span> </span><span>less_Suc0</span><span> </span><span>power_0</span><span> </span><span>set_l1_in_l2</span><span> </span><span>sl_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_r_in_l2_sm_gt_0_r_lt_sm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &gt; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&lt; 2^(sm cfg)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(r_lt_sm_gt_0_j cfg r) &lt; sl cfg &#8743; 
               r &#8712; l2_set cfg 0 (r_lt_sm_gt_0_j cfg r)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_index_r_sm_gt_0_r_lt_2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>set_l1_in_l2_sm_gt_0_i_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>_</span><span> </span><span>a1</span><span class="delimiter">]</span><span> </span><span>a2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_r_in_l2_sm_gt_0_r_gt_sm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &gt; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8805; 2^(sm cfg)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(r_gt_sm_gt_0_j cfg r)  &lt; sl cfg &#8743; 
               r &#8712; l2_set cfg (r_gt_sm_gt_0_i cfg r) (r_gt_sm_gt_0_j cfg r)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_index_r_sm_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>set_l1_in_l2_sm_gt_0_i_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>_</span><span> </span><span>a1</span><span class="delimiter">]</span><span> </span><span>a2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_r_in_l2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;i j. j &lt; sl cfg &#8743; r &#8712; l2_set cfg i j&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = 0&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a00</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&lt; 2^(sm cfg)+1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>all_r_in_l2_sm_0_r_lt_sm</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>True</span><span> </span><span>a00</span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a00</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#8805;2^(sm cfg)+1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>all_r_in_l2_sm_0_r_geqt_sm</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a00</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &gt;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&lt; 2^(sm cfg)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>all_r_in_l2_sm_gt_0_r_lt_sm</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a00</span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;2^sm cfg &#8804; r&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>all_r_in_l2_sm_gt_0_r_gt_sm</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a00</span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mapping_insert_spec</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat &#8658; (nat &#215; nat) set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert_spec cfg r &#8801; {(i,j). j &lt; sl cfg &#8743; r &#8712; l2_set cfg i j}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2_set_not_empty</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg &#10233; l2_set cfg i j&#8800;{}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_set_def</span><span> </span><span>range_l2_def</span><span> </span><span>Let_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;l cfg &#8804; sm cfg&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;size_l2 cfg i &gt; 0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>size_l2_not_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;x&#8805;l2_i_j cfg i j. x &#8804; l2_i_j cfg i j + size_l2 cfg i - Suc 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_singleton_elements</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; is_singleton A &#10233; A={} &#8744; (&#8707;i j i&#39; j&#39;. (i&#8800;i&#39; &#8744; j&#8800;j&#39;) &#8743; 
            (i,j)&#8712; A &#8743; (i&#39;,j&#39;) &#8712; A)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_singleton_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>insertI1</span><span> </span><span>insert_absorb</span><span> </span><span>old.prod.exhaust</span><span> </span><span>singleton_insert_inj_eq&#39;</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>singleton_mapping_insert_spec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg&#8805; l cfg&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_singleton (mapping_insert_spec cfg r) &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert_spec cfg r &#8800; {}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mapping_insert_spec_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_r_in_l2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;i j. (i,j)&#8712; mapping_insert_spec cfg r &#8743;  
              (&#8704;i&#39; j&#39;. (i&#39;,j&#39;) &#8712; mapping_insert_spec cfg r &#10230;
                       i=i&#39; &#8743; j=j&#39;)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>calculation</span><span> </span><span>l2_set_disj</span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mapping_insert_spec_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>linorder_neqE_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>not_singleton_elements</span><span class="delimiter">)</span><span>   
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>next_block</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; (nat&#215;nat) &#8658; (nat&#215;nat)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next_block cfg x &#8801; if Suc (snd x) &lt; (sl cfg) then (fst x, (snd x + 1))
                            else ((fst x)+1, 0)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>block_lt</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::wellorder&#215;&#39;a) &#8658; (&#39;a&#215;&#39;a) &#8658; bool&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&lt;<span class="hidden">&#8681;</span><sub>b</sub>&quot;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_lt  x y &#8801; 
   (fst x &lt; fst y) &#8744; (fst x = fst y &#8743; snd x &lt; snd y)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>block_let</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::wellorder&#215;&#39;a) &#8658; (&#39;a&#215;&#39;a) &#8658; bool&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8804;<span class="hidden">&#8681;</span><sub>b</sub>&quot;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_let  x y &#8801; x=y &#8744; block_lt x y &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>block_gt</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::wellorder&#215;&#39;a) &#8658; (&#39;a&#215;&#39;a) &#8658; bool&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&gt;<span class="hidden">&#8681;</span><sub>b</sub>&quot;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_gt x y &#8801; &#172; (block_let x y)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>block_get</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::wellorder&#215;&#39;a) &#8658; (&#39;a&#215;&#39;a) &#8658; bool&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8805;<span class="hidden">&#8681;</span><sub>b</sub>&quot;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_get x y &#8801; &#172; (block_lt x y)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>wellorder_Least_lemma</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_lt_tran</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a &lt;<span class="hidden">&#8681;</span><sub>b</sub> b &#10233; b &lt;<span class="hidden">&#8681;</span><sub>b</sub> c &#10233; a &lt;<span class="hidden">&#8681;</span><sub>b</sub> c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>block_lt_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_let_tran</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a &#8804;<span class="hidden">&#8681;</span><sub>b</sub> b &#10233; b &#8804;<span class="hidden">&#8681;</span><sub>b</sub> c &#10233; a &#8804;<span class="hidden">&#8681;</span><sub>b</sub> c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>block_let_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>  </span><span>b_lt_tran</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_gt_tran</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a &gt;<span class="hidden">&#8681;</span><sub>b</sub> b &#10233; b &gt;<span class="hidden">&#8681;</span><sub>b</sub> c &#10233; a &gt;<span class="hidden">&#8681;</span><sub>b</sub> c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>block_gt_def</span><span> </span><span>block_let_def</span><span> </span><span>block_lt_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prod.expand</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_get_tran</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a &#8805;<span class="hidden">&#8681;</span><sub>b</sub> b &#10233; b &#8805;<span class="hidden">&#8681;</span><sub>b</sub> c &#10233; a &#8805;<span class="hidden">&#8681;</span><sub>b</sub> c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>block_get_def</span><span> </span><span>block_gt_def</span><span> </span><span>block_let_def</span><span> </span><span>block_lt_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_let_refl</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a&#8804;<span class="hidden">&#8681;</span><sub>b</sub>a&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>block_let_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_get_refl</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a&#8805;<span class="hidden">&#8681;</span><sub>b</sub>a&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>block_get_def</span><span> </span><span>block_gt_def</span><span> </span><span>block_let_def</span><span> </span><span>block_lt_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_b_lt</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172; a&lt;<span class="hidden">&#8681;</span><sub>b</sub>a&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>block_lt_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_b_gt</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172; a &gt;<span class="hidden">&#8681;</span><sub>b</sub> a&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span>   </span><span>block_gt_def</span><span> </span><span>block_let_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>antysimb</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x &#8804;<span class="hidden">&#8681;</span><sub>b</sub> y &#10233; y &#8804;<span class="hidden">&#8681;</span><sub>b</sub> x &#10233; x = y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>block_let_def</span><span> </span><span>block_lt_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>next_block_bigger</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg &#10233;
                         (ni,nj) = next_block cfg (i,j) &#10233; 
                         j &lt; sl cfg &#10233;
                         r&#8712;l2_set cfg i j &#10233; 
                         rn&#8712; l2_set cfg ni nj &#10233;
                         rn&gt;r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>next_block_def</span><span> </span><span>l2_set_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Suc j) &lt; sl cfg&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>snd_range_l2_i_j_less_fst_j&#39;</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">=</span><span>i</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j</span><span class="delimiter">=</span><span>j</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc j&quot;</span></span></span><span class="delimiter">]</span><span> 
</span><span>   </span><span>snd_range_l2_i_j_less_fst_i&#39;_j&#39;</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j</span><span class="delimiter">=</span><span>j</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j&#39;</span><span class="delimiter">=</span><span>0</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">=</span><span>i</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Suc i&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mapping_insert</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat &#8658; (nat&#215;nat)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert cfg r &#8801; 
          if (sm cfg) = 0 then
             (if r &lt;((2^(sm cfg)) + 1) then  (0,0)
              else (r_gt_sm_0_i r,0))
          else (if r &lt;(2^(sm cfg)) then (0,r_lt_sm_gt_0_j cfg r)
                else (r_gt_sm_gt_0_i cfg r,r_gt_sm_gt_0_j cfg r))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg &#8805; l cfg &#10233;
       (i,j) = mapping_insert cfg r &#10233;
       r&#8712;l2_set cfg i j &#8743; j &lt; sl cfg&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mapping_insert_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sm cfg = 0&quot;</span></span></span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&lt; (2 ^ sm cfg) + 1&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_r_in_l2_sm_0_r_lt_sm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>all_r_in_l2_sm_0_r_geqt_sm</span><span> </span><span>le_less_linear</span><span> </span><span>le_numeral_extra</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>numeral_2_eq_2</span><span> </span><span>plus_1_eq_Suc</span><span> </span><span>power_eq_if</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&lt; (2 ^ sm cfg)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>all_r_in_l2_sm_gt_0_r_lt_sm</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_r_in_l2_sm_gt_0_r_gt_sm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>map_search</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat &#8658; (nat&#215;nat)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_search cfg r &#8801; next_block cfg (mapping_insert cfg r)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2_set_search_gt_r</span><span class="delimiter">:</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;l cfg &#8804; sm cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(i,j) = (map_search cfg r)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">shows</span></span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;r1&#8712; l2_set cfg i j. r1 &gt; r&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r1</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a00</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r1 &#8712;l2_set cfg i j&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8712; l2_set cfg (fst (mapping_insert cfg r))
                          (snd (mapping_insert cfg r)) &#8743; 
          (snd (mapping_insert cfg r)) &lt; sl cfg&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>r</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&lt;r1&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>next_block_bigger</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="delimiter">]</span><span> </span><span>a0</span><span> </span><span>a00</span><span> 
</span><span>            </span><span>a1</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>map_search_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>split_block</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658;  bhdr_t &#8658; (bhdr_t&#215;bhdr_t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;split_block r b = (Bhdr (s_addr b) ((s_addr b) + r - 1),
                           Bhdr ((s_addr b) + r + overhead conf) (e_addr b))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_size_sum</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;r &gt; 0 &#10233; b_size b - overhead conf &#8805; r &#10233;
   (b1, b2) = split_block r b &#10233; b_size b1 + b_size b2 = b_size b - overhead conf&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>join_block</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_t &#8658; bhdr_t &#8658; bhdr_t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;join_block b1 b2 &#8801; Bhdr (s_addr b1) (e_addr b2)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>bitmap</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; bool&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fl_bitmap_f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; bhdr_matrix_t &#8658; bitmap&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fl_bitmap_f cfg m &#8801;  (&#955;i. (&#8707;j&lt; sl cfg. m i j&#8800;{}))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sl_bitmap_f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_matrix_t &#8658; (nat &#8658; bitmap)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sl_bitmap_f m &#8801;  &#955;i j. m i j&#8800;{}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>suitable_blocks</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; (nat&#215;nat) &#8658; state_t &#8658; (nat&#215;nat) set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable_blocks cfg p &#963; &#8801; 
  {(i,j).  (bhdr_matrix_f &#963;) i j&#8800;{} &#8743; p &#8804;<span class="hidden">&#8681;</span><sub>b</sub> (i,j) &#8743; j&lt; (sl cfg) }
  &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>suitable_blocks_bitmap</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; (nat&#215;nat) &#8658; state_t &#8658; (nat&#215;nat) set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable_blocks_bitmap cfg p &#963; &#8801;
     let i = fst p; j = snd p in
      {(i&#39;,j&#39;). (fl_bitmap_f cfg (bhdr_matrix_f &#963;)) i&#39; = True  &#8743; j&#39;&lt; (sl cfg) &#8743;
                 (sl_bitmap_f (bhdr_matrix_f &#963;)) i&#39; j&#39; = True &#8743; ((i,j)&#8804;<span class="hidden">&#8681;</span><sub>b</sub>(i&#39;,j&#39;))}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suitable_blocks_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;suitable_blocks cfg p &#963; = suitable_blocks_bitmap cfg p &#963;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_blocks_def</span><span> </span><span>suitable_blocks_bitmap_def</span><span> </span><span>fl_bitmap_f_def</span><span> </span><span>sl_bitmap_f_def</span><span>
</span><span>  </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>Leastb</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;a::wellorder&#215;&#39;a) &#8658; bool) &#8658; (&#39;a::wellorder&#215;&#39;a)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">binder</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LEAST<span class="hidden">&#8681;</span><sub>b</sub> &quot;</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Leastb P = (THE x. P x &#8743; (&#8704;y. P y &#10230; x &#8804;<span class="hidden">&#8681;</span><sub>b</sub> y))&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* lemma Least_equality:
  assumes &quot;P x&quot;
    and &quot;&#8896;y. P y &#10233; x &#8804; y&quot;
  shows &quot;Least P = x&quot;
unfolding Least_def by (rule the_equality)
  (blast intro: assms antisym)+ *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prod&quot;</span></span></span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ord</span><span class="delimiter">,</span><span> </span><span>ord</span><span class="delimiter">)</span><span> </span><span>ord</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>less_prod_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p &lt; q &#8801; (fst p &lt; fst q) &#8744; (fst p = fst q &#8743; snd p &lt; snd q)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>    </span><span>less_eq_prod_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p &#8804; q &#8801; p=q &#8744; ((fst p &lt; fst q) &#8744; (fst p = fst q &#8743; snd p &lt; snd q))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prod&quot;</span></span></span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>linorder</span><span class="delimiter">,</span><span> </span><span>linorder</span><span class="delimiter">)</span><span> </span><span>linorder</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::linorder &#215; &#39;b::linorder&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; (x &lt; y) = (x &#8804; y &#8743; &#172; y &#8804; x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_prod_def</span><span> </span><span>less_eq_prod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8804; x&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_prod_def</span><span> </span><span>less_eq_prod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8804; y &#10233; y &#8804; z &#10233; x &#8804; z&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_prod_def</span><span> </span><span>less_eq_prod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8804; y &#10233; y &#8804; x &#10233; x = y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_prod_def</span><span> </span><span>less_eq_prod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8804; y &#8744; y &#8804; x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_prod_def</span><span> </span><span>less_eq_prod_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_linear</span><span> </span><span>prod_eqI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* lemma &quot;(&#8896;x. (&#8896;y. y &lt; x &#10233; P y) &#10233; P x) &#10233; P (a::int)&quot;
proof-
  assume step: &quot;(&#8896;m. m &lt; n &#10233; P m) &#10233; P n&quot; for n :: nat
  have &quot;&#8896;q. q &#8804; a &#10233; P q&quot;
  proof (induct a)
    case (0 n)
    have &quot;P 0&quot; by (rule step) auto
    with 0 show ?case by auto
  next
    case (Suc m n)
    then have &quot;n &#8804; m &#8744; n = Suc m&quot;
      by (simp add: le_Suc_eq)
    then show ?case
    proof
      assume &quot;n &#8804; m&quot;
      then show &quot;P n&quot; by (rule Suc(1))
    next
      assume n: &quot;n = Suc m&quot;
      show &quot;P n&quot; by (rule step) (rule Suc(1), simp add: n le_simps)
    qed
  qed
  then show &quot;P a&quot; by auto
qed

thm split_beta split_conv split_beta&#39;
instance prod :: (wellorder,wellorder) wellorder
proof
  fix P and n :: &quot;&#39;a::wellorder &#215; &#39;b::wellorder&quot;
  obtain f where f:&quot;P=(&#955;(x, y). (f::&#39;a::wellorder &#8658; &#39;b::wellorder &#8658; bool) (x::&#39;a::wellorder) (y::&#39;b::wellorder))&quot; 
    by force
  assume step: &quot;(&#8896;m. m &lt; q &#10233; P m) &#10233; P q&quot; for q :: &quot;&#39;a::wellorder &#215; &#39;b::wellorder&quot;  
  have &quot;&#8896;q. q &#8804; n &#10233; P q&quot;
  proof (induct n)
    case (Pair a b)
    then show ?case sorry
  qed
  {assume &quot;&#8704;m. &#172; m&lt; n&quot; then have &quot;P n&quot; using step by fastforce}
  moreover 
  {obtain na nb where n:&quot;n = (na, nb)&quot;
    by fastforce
    assume a00:&quot;&#8707;m. m&lt;n&quot; 
    then obtain m ma mb where &quot;(ma::&#39;a::wellorder, mb::&#39;b::wellorder) &lt; (na,nb)&quot; and &quot;m = (ma, mb)&quot; 
      using n by auto
    then have &quot;ma &lt; na &#8744; ((ma = na) &#8743; mb &lt;nb)&quot; 
      using less_prod_def by fastforce
    moreover {assume &quot;ma &lt; na&quot;
      note less_induct
      then have &quot;f na nb&quot; using step sorry
      then have &quot;P n&quot; using f n by auto
    }
    moreover {assume &quot;(ma = na) &#8743; mb &lt;nb&quot;
      let ?P2 = &quot;&#955;p. &quot;
      note less_induct
      then have &quot;P n&quot; using step apply auto  sorry
    }
    ultimately have &quot;P n&quot; using step n by fastforce}
  ultimately show &quot;P n&quot; by auto
qed *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma Least_equality:
  assumes &quot;P (x::(&#39;a::wellorder&#215;&#39;a))&quot;
    and &quot;&#8896;y. P y &#10233; x &#8804;<span class="hidden">&#8681;</span><sub>b</sub> y&quot;
  shows &quot;Leastb P = x&quot;
  unfolding Leastb_def  
  by (rule the_equality) (blast intro: assms antysimb)+
    
lemma LeastI2_order:
  assumes &quot;P (x::(&#39;a::wellorder&#215;&#39;a))&quot;
    and &quot;&#8896;y. P y &#10233; x &#8804;<span class="hidden">&#8681;</span><sub>b</sub> y&quot;
    and &quot;&#8896;x. P x &#10233; &#8704;y. P y &#10230; x &#8804;<span class="hidden">&#8681;</span><sub>b</sub> y &#10233; Q x&quot;
  shows &quot;Q (Leastb P)&quot;
unfolding Leastb_def by (rule theI2)
  (blast intro: assms antysimb)+ 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>min_elem_set</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(nat&#215;nat) set &#8658; (nat&#215;nat)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_elem_set s &#8801; 
    (LEAST x.  x &#8712; s)&quot;</span></span></span><span>
</span><span>        
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* thm 
wellorder_Least_lemma(2)
lemma assumes a0:&quot; (s::(nat&#215;nat) set)&#8800;{}&quot;
  shows &quot;&#8704;e&#8712;s. ((min_elem_set s))&#8804; e&quot;
proof-
  {fix e
    assume a00: &quot; e&#8712; s&quot;
    have &quot;((min_elem_set s))&#8804; e&quot;
      unfolding min_elem_set_def 
      using wellorder_Least_lemma(2)[of &quot;&#955;x. x&#8712;s&quot;]
  

lemma &quot; (s::(nat&#215;nat) set)&#8800;{} &#10233; &#8707;p&#8712;s. (&#8704;p&#39;&#8712;s. p&#8804;<span class="hidden">&#8681;</span><sub>b</sub>p&#39;)&quot;
  apply auto 
  unfolding block_let_def block_lt_def
  
  nitpick
  sorry *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mapping_search</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; nat &#8658; (nat&#215;(nat&#215;nat))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_search cfg r &#8801; let r = if r&lt; (min_block cfg) then min_block cfg else r; 
                                     (i,j) = mapping_insert cfg r;
                                     (i&#39;,j&#39;) = next_block cfg (i,j);
                                     initial_size = fst (range_l2 cfg i j);
                                     r&#39;= fst (range_l2 cfg i&#39; j&#39;) in 
                                 if initial_size = r then (r,(i,j))
                                 else (r&#39;, (i&#39;,j&#39;))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2_set_mapping_search_geq_r</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;l cfg &#8804; sm cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(r&#39;, (i,j)) = (mapping_search cfg r)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">shows</span></span><span class="string"><span class="delete"><span class="delete">&quot;r&#39;&#8805; r &#8743; (&#8704;r1&#8712; l2_set cfg i j. r1 &#8805; r&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a00</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&lt;(min_block cfg)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mapping_search_def</span><span> </span><span>Let_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (range_l2 cfg x1 x2) = min_block cfg&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l2_set_search_gt_r</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_block cfg)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>map_search_def</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a0</span><span> </span><span>l2_set_def</span><span> </span><span>Let_def</span><span> </span><span>range_l2_disj</span><span class="delimiter">)</span><span>     
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8805;(min_block cfg)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mapping_search_def</span><span> </span><span>Let_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (range_l2 cfg x1 x2) = r&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l2_set_search_gt_r</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>map_search_def</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a0</span><span> </span><span>l2_set_def</span><span> </span><span>Let_def</span><span> </span><span>range_l2_disj</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>find_suitable_blocks_opt</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(nat&#215;nat) &#8658; state_t &#8658; ((nat&#215;nat) set) option&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;find_suitable_blocks_opt p s &#8801; 
  let x = suitable_blocks conf p s in 
       if (x={}) then None else Some x&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ij_level_empty</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_matrix_t &#8658; nat &#8658; nat &#8658;bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ij_level_empty m i j &#8801; m i j = {}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>i_level_empty</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;Sys_Config &#8658; bhdr_matrix_t &#8658; nat  &#8658;bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i_level_empty cfg m i &#8801; &#8704;j&lt; (sl cfg). ij_level_empty m i j&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>remove_elem_from_matrix</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_t &#8658; nat &#8658; nat &#8658; state_t &#8658;state_t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;remove_elem_from_matrix b i j &#963; &#8801; 
    let matrix_not_elem = (Set.remove b ((bhdr_matrix_f &#963;) i j));
        new_matrix = set_bhdr_matrix (bhdr_matrix_f &#963;) i j matrix_not_elem  in 
     &#963;&#10631;bhdr_matrix_f:= new_matrix&#10632;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>remove_block</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(nat&#215;nat) &#8658; (state_t, bhdr_t) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;remove_block p  &#8801; 
 let i = fst p; j = snd p in
     do
       matrix &#8592; gets (&#955;&#963;. (bhdr_matrix_f &#963;) i j);
       b &#8592; select matrix; 
       modify (remove_elem_from_matrix b i j);
       return b
     od &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>add_block</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_t &#8658; state_t &#8658; state_t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block b &#963; &#8801; 
 let (i,j) = mapping_insert conf (b_size b)  in
   &#963;&#10631;bhdr_matrix_f := insert_block_bhdr_matrix  (bhdr_matrix_f &#963;) i j b&#10632;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>malloc</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; (state_t, nat) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;malloc r &#8801;  let (r,(i,j)) = mapping_search conf r in
                     do set_ps &#8592; gets (find_suitable_blocks_opt (i,j));
                        condition (&#955;s. set_ps = None) (return 0)
                        (do p &#8592; select (the set_ps);
                            b &#8592; remove_block p;
                            (condition (&#955;s. b_size b - r &#8805; (min_block conf))
                                (do (b1,b2) &#8592; gets (&#955;s. (split_block r b));
                                 modify (&#955;s. s&#10631;alloced_bhdr_s:= insert b1 (alloced_bhdr_s s)&#10632;);
                                 modify (add_block b2);
                                 return (s_addr b1) od)
                                (do
                                  modify (&#955;s. s&#10631;alloced_bhdr_s:= insert b (alloced_bhdr_s s)&#10632;);
                                  return (s_addr b)
                                 od))
                         od)
                     od&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* definition join_blocks::&quot;bhdr_t &#8658; bhdr_t &#8658; (state_t, bhdr_t) nondet_monad&quot;
  where &quot;join_blocks b1 b2 &#8801;  
         let (i,j) = mapping_insert conf (b_size b1);
             b_join = join_block b1 b2 in
         do             
            modify (remove_elem_from_matrix b1 i j);
            modify (add_block b_join);
            return b_join
         od&quot; *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>join_prev</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_t &#8658; (state_t, bhdr_t) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;join_prev b &#8801;  do b&#39; &#8592; gets (prev_free_hdr_s conf b);
                   condition (&#955;s. b&#39; = None)
                     (return b)
                     (let (i,j) = mapping_insert conf (b_size(the b&#39;));
                          b_join = join_block (the b&#39;) b
                      in
                      do
                         modify (remove_elem_from_matrix (the b&#39;) i j);
                         return b_join
                      od)
                od &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>join_suc</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_t &#8658; (state_t, bhdr_t) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;join_suc b &#8801; do b&#39; &#8592; gets (suc_hdr_free_s conf b);
                   condition (&#955;s. b&#39; = None)
                     (return b)
                     (let (i,j) = mapping_insert conf (b_size(the b&#39;));
                          b_join = join_block b (the b&#39;)
                      in
                      do
                        modify (remove_elem_from_matrix (the b&#39;) i j);
                        return b_join
                      od)
                od&quot;</span></span></span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>free</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; (state_t, nat) nondet_monad&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;free addr &#8801; condition (block_alloced addr)
                        (do b &#8592; gets (get_alloced_block addr);
                           modify (&#955;s. s&#10631; alloced_bhdr_s := Set.remove b (alloced_bhdr_s s)&#10632;);
                           b &#8592; join_suc b;
                           b &#8592; join_prev b;
                           modify (add_block b);
                           return 1
                        od)
                        (do
                          modify (&#955;s. undefined);
                          return undefined
                         od)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>run</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;state_t list &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>single_s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;run [x]&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>malloc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;run (x#xs); v = (SOME v. v&#8712;(fst (malloc r x)))&#10215; &#10233; run ((snd v)#x#xs)&quot;</span></span></span><span> 
</span><span class="delimiter">|</span><span> </span><span>free</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;run (x#xs); v = (SOME v. v&#8712;(fst (free r x)))&#10215; &#10233; run ((snd v)#x#xs)&quot;</span></span></span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;properties&#8250;</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>block_t_size</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_t &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_t_size b &#8801; b_size b + overhead conf&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wf_block</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b &#8801; s_addr b &#8804; e_addr b &#8743; s_addr b &#8805; overhead conf &#8743; block_t_size b &#8805; min_block conf &#8743; 
                       block_t_size b  &#8804; mem_size conf&quot;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 1. s_addr b &lt;= e_addr b means the size of a block if greater than 1. If strict less, it would be 2. *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 2. block_t_size b &gt;= min_block conf is consistent with definition of malloc (b_size b - r &gt;= min_block conf). *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wf</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;state_t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf &#963; &#8801; &#8704;x &#8712; all_blocks conf &#963;. wf_block x&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>disjoint_free_non_free</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;state_t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free &#963; &#8801; alloced_bhdr_s &#963; &#8745; free_blocks conf &#963; = {} &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>disjoint_memory</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_t &#8658; bhdr_t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory b1 b2 &#8801; 
         (e_addr b1 + (overhead conf) &lt; s_addr b2 &#8744; 
          e_addr b2 + (overhead conf) &lt; s_addr b1)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>disjoint_memory_set</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;state_t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set &#963; &#8801; 
  &#8704;x1 x2. x1 &#8712; all_blocks conf &#963; &#8743; x2 &#8712; all_blocks conf &#963; &#8743; x1&#8800;x2 &#10230; disjoint_memory x1 x2 &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>no_split_memory</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;state_t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory &#963; &#8801; let f = free_blocks conf &#963; in
                            &#172; (&#8707;b1 b2. b1 &#8712; f &#8743; b2 &#8712; f &#8743; 
                              (s_addr b1 = e_addr b2 + 1 + overhead conf))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wf_adjacency_list</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;state_t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list &#963; &#8801; tlsf_matrix conf (bhdr_matrix_f &#963;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wf_bitmap1</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;state_t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_bitmap1 &#963; &#8801; 
  &#8704;i . fl_bitmap_f conf (bhdr_matrix_f &#963;) i = 
    (&#8707;j&lt; sl conf. sl_bitmap_f (bhdr_matrix_f &#963;) i j)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wf_bitmap2</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;state_t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_bitmap2 &#963; &#8801; 
  &#8704;i . &#8704;j &lt; sl conf.  
  (bhdr_matrix_f &#963;) i j&#8800;{} =  
      sl_bitmap_f (bhdr_matrix_f &#963;) i j&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wf_bitmap</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;state_t &#8658; bool&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_bitmap &#963; &#8801; wf_bitmap1 &#963; &#8743; wf_bitmap2 &#963;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sum_block</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_t set &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_block &#963; &#8801; Finite_Set.fold (&#955;b s. block_t_size b + s) 0 &#963;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>all_block_mem_size</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;state_t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_block_mem_size &#963; &#8801;  sum_block (all_blocks conf &#963;) = mem_size conf&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;state_t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv &#963; &#8801; no_split_memory &#963; &#8743; disjoint_free_non_free &#963; &#8743;disjoint_memory_set &#963; &#8743; wf &#963; &#8743;
            wf_adjacency_list &#963; &#8743;  all_block_mem_size &#963;&quot;</span></span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* wf_bitmap does not make sense here. See explanation below *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unique_get_alloced_block1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr &#963; &#10233; &#8707;b. (&#8707;e_addr. b = Bhdr addr e_addr) &#8743; b &#8712; alloced_bhdr_s &#963;&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>block_alloced_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_block_diff_s_addr</span><span class="delimiter">:</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;inv &#963;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;b1&#8712; all_blocks conf &#963;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;b2&#8712; all_blocks conf &#963;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;b1&#8800;b2&quot;</span></span></span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s_addr b1 &#8800; s_addr b2&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;s_addr b1 = s_addr b2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b1 &#8743; wf_block b2&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> </span><span>wf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory b1 b2&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> </span><span>disjoint_memory_set_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_block_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_block_diff_e_addr</span><span class="delimiter">:</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;inv &#963;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;b1&#8712; all_blocks conf &#963;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;b2&#8712; all_blocks conf &#963;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;b1&#8800;b2&quot;</span></span></span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b1 &#8800; e_addr b2&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b1 = e_addr b2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b1 &#8743; wf_block b2&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> </span><span>wf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory b1 b2&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> </span><span>disjoint_memory_set_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_block_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_addr_same_block</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;inv &#963;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;e_addr. b1 = Bhdr addr e_addr) &#8743; b1 &#8712; alloced_bhdr_s &#963;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;e_addr. b2 = Bhdr addr e_addr) &#8743; b2 &#8712; alloced_bhdr_s &#963;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b1 = b2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span>     
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>diff_block_diff_s_addr</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>bhdr_t.inject</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>   
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;!b. get_alloced_block addr &#963; = b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>                                           
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* no_split *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alloc_insert_no_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory s &#10233; no_split_memory (s&#10631;alloced_bhdr_s := insert b (alloced_bhdr_s s) &#10632;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_split_memory_def</span><span> </span><span>free_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alloc_insert_no_split&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory (s&#10631;bhdr_matrix_f := m &#10632;) &#10233; no_split_memory (s&#10631; alloced_bhdr_s := insert b (alloced_bhdr_s s),bhdr_matrix_f := m &#10632;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_split_memory_def</span><span> </span><span>free_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* why the two are not same? *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alloc_insert_no_split&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory (s&#10631;bhdr_matrix_f := m &#10632;) &#10233; no_split_memory (s&#10631; bhdr_matrix_f := m, alloced_bhdr_s := insert b (alloced_bhdr_s s) &#10632;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_split_memory_def</span><span> </span><span>free_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* why the three are not same? *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subset_remove_no_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory s &#10233; free_blocks conf s &#8805; free_blocks conf s&#39; &#10233; no_split_memory s&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_split_memory_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>subset_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>matrix_remove_no_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory s &#10233;
    no_split_memory (s&#10631;bhdr_matrix_f := set_bhdr_matrix (bhdr_matrix_f s) i j (Set.remove b (bhdr_matrix_f s i j)) &#10632;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subset_remove_no_split</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory _&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_def</span><span> </span><span>set_bhdr_matrix_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_alloc_no_split</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory s &#10233; 
   wf s &#10233;
   disjoint_memory_set s &#10233;
   b &#8712; free_blocks conf s &#10233; 
   r &gt; 0 &#10233; &#8213;&#8249;split a zero is meaningless&#8250;
   r &lt; b_size b - overhead conf &#10233;
   free_blocks conf s&#39; = (free_blocks conf s) - {b} &#8746; {snd (split_block r b)} &#10233;
   no_split_memory s&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_split_memory_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span> </span><span>split_block_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>b_size.simps</span><span> </span><span>bhdr_t.exhaust_sel</span><span> </span><span>diff_add_inverse</span><span> </span><span>diff_le_self</span><span> </span><span>not_le</span><span> </span><span>plus_1_eq_Suc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>disjoint_memory_def</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span> </span><span>split_block_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_blocks_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>bspec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>b2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>disjoint_memory_def</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span> </span><span>split_block_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_blocks_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>bspec</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>split_beta</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: move it *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>find_opt_is_free</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;find_suitable_blocks_opt (i,j) s = Some ps &#10233;
   (i&#39;, j&#39;) &#8712; ps &#10233;
   b &#8712; bhdr_matrix_f s i&#39; j&#39; &#10233;
   b &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Union_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bexI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_suitable_blocks_opt_def</span><span> </span><span>suitable_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>case_prodD</span><span> </span><span>mem_Collect_eq</span><span> </span><span>option.discI</span><span> </span><span>option.inject</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_range_in_set</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l cfg &#8804; sm cfg &#10233; fst (range_l2 cfg i j) &#8712; l2_set cfg i j&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_set_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>range_l2_disj</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_search_r_ge_minblock</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;l cfg &#8804; sm cfg &#10233; (r&#39;,(i,j)) = mapping_search cfg r &#10233; r&#39; &#8805; min_block cfg&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &lt; min_block cfg&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mapping_search_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span> </span><span>next_block_bigger</span><span> </span><span>fst_range_in_set</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_imp_le_nat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span> </span><span>next_block_bigger</span><span> </span><span>fst_range_in_set</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>le_cases</span><span> </span><span>less_le_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_search_r_gt_0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;l cfg &#8804; sm cfg &#10233; min_block cfg &gt; 0 &#10233; (r&#39;,(i,j)) = mapping_search cfg r &#10233; r&#39; &gt; 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_search_r_ge_minblock</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* the matrix could be arbitrary so I introduced free_blocks_mat *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;j &lt; sl cfg &#10233; free_blocks_mat cfg mat = f &#10233;
   free_blocks cfg (s&#10631; bhdr_matrix_f := insert_block_bhdr_matrix mat i j b &#10632;) = f &#8746; {b}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_mat_def</span><span> </span><span>free_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>ii</span><span> </span><span>jj</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mat ii jj&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>insert_block_bhdr_matrix_def</span><span> </span><span>set_bhdr_matrix_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>insert_block_bhdr_matrix_def</span><span> </span><span>set_bhdr_matrix_def</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insert_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_is_union_conf</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert conf (b_size b) = (i, j)&#10233; free_blocks_mat conf mat = f &#10233;
   free_blocks conf (s&#10631; bhdr_matrix_f := insert_block_bhdr_matrix mat i j b &#10632;) = f &#8746; {b}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mapping_insert_r_in_l2_set</span><span> </span><span>mbiggerl</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>neq_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8800; b &#10233; a &lt; b &#8744; a &gt; (b::nat)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>free_block_no_dup</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s &#10233; b &#8712; bhdr_matrix_f s i j &#10233; b &#8712;bhdr_matrix_f s i&#39; j&#39; &#10233; 
  j &lt; sl conf &#10233; j&#39; &lt; sl conf &#10233;
  i=i&#39; &#8743; j=j&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_adjacency_list_def</span><span> </span><span>tlsf_matrix_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_set_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>i&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>j</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>j&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i = i&#39;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>neq_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snd_range_l2_i_j_less_fst_i&#39;_j&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>conf</span><span> </span><span>j</span><span> </span><span>j&#39;</span><span> </span><span>i</span><span> </span><span>i&#39;</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snd_range_l2_i_j_less_fst_i&#39;_j&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>conf</span><span> </span><span>j&#39;</span><span> </span><span>j</span><span> </span><span>i&#39;</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>neq_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snd_range_l2_i_j_less_fst_j&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>conf</span><span> </span><span>j</span><span> </span><span>j&#39;</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leD</span><span> </span><span>le_less_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snd_range_l2_i_j_less_fst_j&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>conf</span><span> </span><span>j&#39;</span><span> </span><span>j</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leD</span><span> </span><span>le_less_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s &#10233; b &#8712; bhdr_matrix_f s i j &#10233; j &lt; sl conf &#10233;
   free_blocks_mat conf (set_bhdr_matrix (bhdr_matrix_f s) i j (Set.remove b (bhdr_matrix_f s i j))) = free_blocks conf s - {b}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_def</span><span> </span><span>free_blocks_mat_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_bhdr_matrix_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ai</span><span> </span><span>aj</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_block_no_dup</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sl_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_bhdr_matrix_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>xi</span><span> </span><span>xj</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Set.remove b (bhdr_matrix_f s xi xj)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>xi</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>xj</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_block_no_dup</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>xj</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_block_no_dup</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_is_minus_conf</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s &#10233; b &#8712; bhdr_matrix_f s i j &#10233; mapping_insert conf (b_size b) = (i, j) &#10233;
   free_blocks_mat conf (set_bhdr_matrix (bhdr_matrix_f s) i j (Set.remove b (bhdr_matrix_f s i j))) = free_blocks conf s - {b}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mapping_insert_r_in_l2_set</span><span> </span><span>mbiggerl</span><span> </span><span>sl_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;find_suitable_blocks_opt (i, j) s = Some ps &#10233; (i&#39;, j&#39;) &#8712; ps &#10233; j&#39; &lt; sl conf&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_suitable_blocks_opt_def</span><span> </span><span>suitable_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suitable_blocks_ij_increase</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;find_suitable_blocks_opt (i, j) s = Some ps &#10233; (i&#39;, j&#39;) &#8712; ps &#10233; (i, j) &#8804;<span class="hidden">&#8681;</span><sub>b</sub> (i&#39;, j&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_suitable_blocks_opt_def</span><span> </span><span>suitable_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>block_mat_size</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s &#10233; b &#8712; bhdr_matrix_f s i j &#10233; j &lt; sl conf &#10233; b_size b &#8712; l2_set conf i j&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_adjacency_list_def</span><span> </span><span>tlsf_matrix_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_l2_set_i_mono</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;l cfg &#8804; sm cfg &#10233; ja &lt; sl cfg &#10233; jb &lt; sl cfg &#10233;
   b_size a &#8712; l2_set cfg ia ja &#10233;
   b_size b &#8712; l2_set cfg ib jb &#10233;
   b_size a &#8804; b_size b &#10233; ia &#8804; ib&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_set_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_le_trans</span><span> </span><span>not_le</span><span> </span><span>sl_def</span><span> </span><span>snd_range_l2_i_j_less_fst_i&#39;_j&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_decrease_size</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_block conf &#8804; b_size b - r &#10233; b_size (snd (split_block r b)) &#8804; b_size b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_malloc_no_split_memory</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;&#955;&#963;. inv &#963;&#10628; (malloc r ) &#10627;&#955;n &#963;. no_split_memory &#963;&#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>malloc_def</span><span> </span><span>Let_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_search conf r&quot;</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>r&#39;</span><span> </span><span>i</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;split_block r&#39; b&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;aa= fst (split_block r&#39; ba)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;baa= snd (split_block r&#39; ba)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hypsubst_thin</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prod_injects</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_block_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#39; = fst(mapping_search conf r)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hypsubst_thin</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>select_wp</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>select_wp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>r&#39;</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span>s</span><span> </span><span>i&#39;</span><span> </span><span>j&#39;</span><span> </span><span>b</span><span> </span><span>ps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert conf (b_size (snd (split_block r&#39; b)))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ia</span><span> </span><span>ja</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>alloc_insert_no_split&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_alloc_no_split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>find_opt_is_free</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>map_search_r_gt_0</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cfg</span><span class="delimiter">=</span><span>conf</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mbiggerl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>alloc_insert_no_split&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>matrix_remove_no_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>select_wp</span><span class="delimiter">[</span><span>wp</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="comment">&#8213;&#8249;disjoint free non free&#8250;</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alloc_free_non_free_disjoint</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free s &#10233; wf_adjacency_list s &#10233; j &lt; sl conf &#10233; b &#8712; bhdr_matrix_f s i j &#10233;
   disjoint_free_non_free
         (s&#10631;bhdr_matrix_f := set_bhdr_matrix (bhdr_matrix_f s) i j (Set.remove b (bhdr_matrix_f s i j)),
              alloced_bhdr_s := insert b (alloced_bhdr_s s)&#10632;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_free_non_free_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>sl_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_free_not_exist_fst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s &#10233;
   wf s &#10233;
   r &#8800; b_size b &#10233; &#8213;&#8249;to avoid b and b1 being identical&#8250;
   split_block r b = (b1, b2) &#10233;
   b &#8712; free_blocks conf s &#10233;
   b1 &#8713; all_blocks conf s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_set_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_blocks_def</span><span> </span><span>split_block_def</span><span> </span><span>wf_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred</span><span> </span><span>Un_iff</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>diff_add_inverse</span><span> </span><span>neq0_conv</span><span> </span><span>not_le</span><span> </span><span>oh_gt_0</span><span> </span><span>zero_eq_add_iff_both_eq_0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>disjoint_memory_def</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>add_lessD1</span><span> </span><span>bhdr_t.sel</span><span> </span><span>not_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>oh_gt_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x1</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>r</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>leD</span><span> </span><span>oh_gt_0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span class="delimiter">:</span><span> </span><span>disjoint_memory_def</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>add_lessD1</span><span> </span><span>bhdr_t.sel</span><span> </span><span>not_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>oh_gt_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_free_not_free_fst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s &#10233;
   wf s &#10233;
   r &#8800; b_size b &#10233;
   split_block r b = (b1, b2) &#10233; 
   b &#8712; free_blocks conf s &#10233; 
   b1 &#8713; free_blocks conf s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_free_not_exist_fst</span><span> </span><span>all_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_free_not_exist_snd</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s &#10233;
   wf s &#10233;
   split_block r b = (b1, b2) &#10233;
   b &#8712; free_blocks conf s &#10233;
   b2 &#8713; all_blocks conf s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_set_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_blocks_def</span><span> </span><span>split_block_def</span><span> </span><span>wf_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>oh_gt_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_block_def</span><span> </span><span>disjoint_memory_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>oh_gt_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_block_def</span><span> </span><span>disjoint_memory_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_free_not_alloced_snd</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s &#10233;
   wf s &#10233;
   split_block r b = (b1, b2) &#10233;
   b &#8712; free_blocks conf s &#10233;
   b2 &#8713; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_free_not_exist_snd</span><span> </span><span>all_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_fst_snd_neq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b &#10233; b1 = fst(split_block r b) &#10233; b2 = snd(split_block r b) &#10233; b1 &#8800; b2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_block_def</span><span> </span><span>wf_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>oh_gt_0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_malloc_disjoint_free_non_free</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;&#955;&#963;. inv &#963;&#10628; (malloc r ) &#10627;&#955;n &#963;. disjoint_free_non_free &#963;&#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>malloc_def</span><span> </span><span>remove_block_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wpsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>r&#39;</span><span> </span><span>i</span><span> </span><span>j</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ps</span><span> </span><span>i&#39;</span><span> </span><span>j&#39;</span><span> </span><span>b</span><span> </span><span>b1</span><span> </span><span>b2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert conf (b_size (snd (split_block r&#39; b)))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>ia</span><span> </span><span>ja</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_free_non_free_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ia</span><span> </span><span>ja</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(i&#39;, j&#39;) &#8712; ps&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; bhdr_matrix_f s i&#39; j&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;find_suitable_blocks_opt (i, j) s = Some ps&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j&#39; &lt; sl conf&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span> </span><span>less_imp_le_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_search conf r = (r&#39;, i, j)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#39; &gt; 0&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_search_r_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span>min_block_gt_overhead</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_self_eq_0</span><span> </span><span>less_imp_diff_less</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_block conf &#8804; b_size b - r&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;split_block r&#39; b = (b1, b2)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>split_b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;b1 = fst(split_block r&#39; b)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b2 = snd(split_block r&#39; b)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b1 &#8713; free_blocks conf s&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_free_not_free_fst</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>r&#39;</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inv _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8804; _ - _&#8250;</span></span></span><span> </span><span>min_block_gt_overhead</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b1 &#8713; free_blocks conf s - {b} &#8746; {b2}&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_fst_snd_neq</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>split_b</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b1 &#8713; _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(i&#39;, j&#39;) &#8712; ps&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; bhdr_matrix_f s i&#39; j&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;find_suitable_blocks_opt (i, j) s = Some ps&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j&#39; &lt; sl conf&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>suitable_blocks_j_lt_sl</span><span> </span><span>less_imp_le_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_search conf r = (r&#39;, i, j)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#39; &gt; 0&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_search_r_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span>min_block_gt_overhead</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_self_eq_0</span><span> </span><span>less_imp_diff_less</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;split_block r&#39; b = (b1, b2)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>split_b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;b1 = fst(split_block r&#39; b)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b2 = snd(split_block r&#39; b)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b2 &#8713; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_free_not_alloced_snd</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inv _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alloced_bhdr_s s &#8745; (free_blocks conf s - {b} &#8746; {b2}) = {}&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8713; _&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b2 = _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inv _&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>alloc_free_non_free_disjoint</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>prod_injects</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="comment">&#8213;&#8249;disjoint memory set&#8250;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>disjoint_mem_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory a b &#10233; disjoint_memory b a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alloc_disjoint_memory_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s &#10233; wf_adjacency_list s &#10233; j &lt; sl conf &#10233; b &#8712; bhdr_matrix_f s i j &#10233;
   disjoint_memory_set
       (s&#10631;bhdr_matrix_f := set_bhdr_matrix (bhdr_matrix_f s) i j (Set.remove b (bhdr_matrix_f s i j)),
            alloced_bhdr_s := insert b (alloced_bhdr_s s)&#10632;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>sl_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_def</span><span> </span><span>sl_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Union_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_def</span><span> </span><span>sl_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Union_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>disjoint_mem_sym</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_def</span><span> </span><span>sl_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Union_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>disjoint_mem_sym</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_def</span><span> </span><span>sl_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Union_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>free_matrix_in_free_block</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; bhdr_matrix_f s i j &#10233; j &lt; sl conf &#10233; b &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_disjoint</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;r &gt; 0 &#8744; s_addr b &gt; 0 &#10233;
   b1 = fst (split_block r b) &#10233;
   b2 = snd (split_block r b) &#10233;
   disjoint_memory b1 b2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_block_def</span><span> </span><span>disjoint_memory_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_disjoint_fst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;r &lt; b_size b &#10233;
   disjoint_memory f b &#10233;
   (b1, b2) = split_block r b &#10233;
   disjoint_memory f b1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_def</span><span> </span><span>split_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_disjoint_snd</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory f b &#10233;
   (b1, b2) = split_block r b &#10233;
   disjoint_memory f b2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_def</span><span> </span><span>split_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>select_wp</span><span class="delimiter">[</span><span>wp</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_malloc_disjoint_memory_set</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;&#955;&#963;. inv &#963;&#10628; (malloc r ) &#10627;&#955;n &#963;. disjoint_memory_set &#963; &#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>malloc_def</span><span> </span><span>Let_def</span><span> </span><span>remove_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wpsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>r&#39;</span><span> </span><span>i</span><span> </span><span>j</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ps</span><span> </span><span>i&#39;</span><span> </span><span>j&#39;</span><span> </span><span>b</span><span> </span><span>b1</span><span> </span><span>b2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>all_blocks_def</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span> </span><span>add_block_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ia</span><span> </span><span>ja</span><span> </span><span>xb</span><span> </span><span>yb</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>free_matrix_in_free_block</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_free_non_free_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_disjoint</span><span class="delimiter">[</span><span>of</span><span> </span><span>r&#39;</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_search_r_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">,</span><span>of</span><span> </span><span>r&#39;</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span>r</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_mem_sym</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_disjoint_fst</span><span class="delimiter">[</span><span>of</span><span> </span><span>r&#39;</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_mem_sym</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_disjoint_fst</span><span class="delimiter">[</span><span>of</span><span> </span><span>r&#39;</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_mem_sym</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_disjoint</span><span class="delimiter">[</span><span>of</span><span> </span><span>r&#39;</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_search_r_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">,</span><span>of</span><span> </span><span>r&#39;</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span>r</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_disjoint_fst</span><span class="delimiter">[</span><span>of</span><span> </span><span>r&#39;</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_disjoint_fst</span><span class="delimiter">[</span><span>of</span><span> </span><span>r&#39;</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_mem_sym</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_disjoint_snd</span><span class="delimiter">)</span><span> 
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_mem_sym</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_disjoint_snd</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_disjoint_snd</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_disjoint_snd</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ps</span><span> </span><span>i&#39;</span><span> </span><span>j&#39;</span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>alloc_disjoint_memory_set</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="comment">&#8213;&#8249;inv wf&#8250;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alloc_no_split_all_blocks</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39; = s&#10631;bhdr_matrix_f := set_bhdr_matrix (bhdr_matrix_f s) i j (Set.remove b (bhdr_matrix_f s i j)),
          alloced_bhdr_s := insert b (alloced_bhdr_s s)&#10632; &#10233;
   wf_adjacency_list s &#10233;
   j &lt; sl conf &#10233; 
   b &#8712; bhdr_matrix_f s i j &#10233;
   all_blocks conf s&#39; = all_blocks conf s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hypsubst_thin</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>free_matrix_in_free_block</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_wf_fst</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b &#10233;
   split_block r b = (b1, b2) &#10233;
   r &#8805; min_block conf &#10233;
   r &#8804; b_size b &#10233;
   wf_block b1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_block_def</span><span> </span><span>split_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_wf_snd</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b &#10233;
   split_block r b = (b1, b2) &#10233;
   r &#8805; min_block conf &#10233;
   b_size b - r &#8805; min_block conf &#10233;
   wf_block b2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_block_def</span><span> </span><span>split_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_malloc_wf</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;&#955;&#963;. inv &#963;&#10628; (malloc r ) &#10627;&#955;n &#963;. wf &#963; &#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>malloc_def</span><span> </span><span>Let_def</span><span> </span><span>remove_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wpsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>r&#39;</span><span> </span><span>i</span><span> </span><span>j</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ps</span><span> </span><span>i&#39;</span><span> </span><span>j&#39;</span><span> </span><span>b</span><span> </span><span>b1</span><span> </span><span>b2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span> </span><span>Let_def</span><span> </span><span>remove_elem_from_matrix_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>ia</span><span> </span><span>ja</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="comment">&#8213;&#8249;well formed b1&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_wf_fst</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_search_r_ge_minblock</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>find_opt_is_free</span><span> </span><span>inv_def</span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="comment">&#8213;&#8249;well formed b2&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_wf_snd</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_search_r_ge_minblock</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>find_opt_is_free</span><span> </span><span>inv_def</span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ps</span><span> </span><span>i&#39;</span><span> </span><span>j&#39;</span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>alloc_no_split_all_blocks</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span> </span><span>wf_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="comment">&#8213;&#8249;inv wf adjacency list&#8250;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_block_wf_adjacency</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s &#10233;
   wf_adjacency_list (add_block b s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>prod.splits</span><span> 
</span><span>           </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_adjacency_list_def</span><span> </span><span>add_block_def</span><span> </span><span>Let_def</span><span>
</span><span>                 </span><span>insert_block_bhdr_matrix_def</span><span> </span><span>set_bhdr_matrix_def</span><span>
</span><span>                 </span><span>tlsf_matrix_def</span><span> </span><span>mapping_insert_r_in_l2_set</span><span> </span><span>mbiggerl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_malloc_wf_adjacency_list</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;&#955;&#963;. inv &#963;&#10628; (malloc r ) &#10627;&#955;n &#963;. wf_adjacency_list &#963; &#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>malloc_def</span><span> </span><span>Let_def</span><span> </span><span>remove_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wpsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_block_wf_adjacency</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span> </span><span>wf_adjacency_list_def</span><span> </span><span>set_bhdr_matrix_def</span><span>
</span><span>                        </span><span>tlsf_matrix_def</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span> </span><span>wf_adjacency_list_def</span><span> </span><span>set_bhdr_matrix_def</span><span> 
</span><span>                     </span><span>tlsf_matrix_def</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* inv wf_bitmap *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_bitmap s&quot;</span></span></span><span> </span><span class="comment">&#8213;&#8249;this is not actually an invariant. Given the definition of bitmap, the property always holds&#8250;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_bitmap_def</span><span> </span><span>wf_bitmap1_def</span><span> </span><span>wf_bitmap2_def</span><span> 
</span><span>                    </span><span>fl_bitmap_f_def</span><span> </span><span>sl_bitmap_f_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* inv total memory size *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_block_size_t</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sz = block_t_size b &#10233;
   split_block r b = (b1, b2) &#10233;
   min_block conf &#8804; r &#10233;
   min_block conf &#8804; b_size b - r &#10233;
   sz1 = block_t_size b1 &#10233;
   sz2 = block_t_size b2 &#10233;
   sz = sz1 + sz2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dual_order.strict_trans</span><span> </span><span>min_block_gt_overhead</span><span> </span><span>not_less</span><span> </span><span>oh_gt_0</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x2 &#8805; (x1 + nat + overhead conf)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_neq_fst</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;split_block r b = (b1, b2) &#10233; r &#8800; b_size b &#10233; r &gt; 0 &#10233; b &#8800; b1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split_block_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_neq_snd</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;split_block r b = (b1, b2) &#10233; r &gt; 0 &#10233; b &#8800; b2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split_block_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_block_f_commute</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;comp_fun_commute (&#955;b. (+) (block_t_size b))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comp_fun_commute_def</span><span> </span><span>comp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minus_transposition</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8805; c &#10233; a + c = (b::nat) &#10233; a = b - c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Un_is_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8746; {b} = insert b A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_block_is_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_block_mem_size s &#10233; finite (all_blocks conf s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_block_mem_size_def</span><span> </span><span>sum_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fold_infinite</span><span> </span><span>total_mem_gt_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_malloc_all_block_mem_size</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;&#955;&#963;. inv &#963;&#10628; (malloc r ) &#10627;&#955;n &#963;. all_block_mem_size &#963;&#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>malloc_def</span><span> </span><span>Let_def</span><span> </span><span>remove_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wpsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>r&#39;</span><span> </span><span>i</span><span> </span><span>j</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ps</span><span> </span><span>i&#39;</span><span> </span><span>j&#39;</span><span> </span><span>b</span><span> </span><span>b1</span><span> </span><span>b2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span> </span><span>Let_def</span><span> </span><span>remove_elem_from_matrix_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_block_mem_size_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mapping_insert_r_in_l2_set</span><span> </span><span>mbiggerl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ia</span><span> </span><span>ja</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_block_mem_size s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_block_mem_size s&#8250;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mem_size conf = sum_block (free_blocks conf s &#8746; alloced_bhdr_s s)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_block_mem_size_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;find_suitable_blocks_opt (i, j) s = Some ps&quot;</span></span></span><span> 
</span><span>               </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_search conf r = (r&#39;, i, j)&quot;</span></span></span><span>
</span><span>               </span><span class="string"><span class="delete"><span class="delete">&quot;(i&#39;, j&#39;) &#8712; ps&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; bhdr_matrix_f s i&#39; j&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#39; &gt; 0&quot;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_search_r_gt_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mapping_search conf r = _&#8250;</span></span></span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_block conf &#8804; r&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_search_r_ge_minblock</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mapping_search conf r = _&#8250;</span></span></span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_block conf &#8804; b_size b - r&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#39; &#8800; b_size b&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;split_block r&#39; b = (b1, b2)&quot;</span></span></span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (all_blocks conf s)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_block_is_finite</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inv _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>free_matrix_in_free_block</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(i&#39;, j&#39;) &#8712; ps&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_suitable_blocks_opt (i, j) s = Some ps&#8250;</span></span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8713; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>calculation</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_free_non_free s&#8250;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b1 &#8800; b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b2 &#8800; b&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_neq_fst</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;split_block _ _ = _&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;r&#39; &#8800; _&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;r&#39; &gt; 0&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_neq_snd</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;split_block _ _ = _&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;r&#39; &gt; 0&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_block (insert b1 (free_blocks conf s - {b} &#8746; {b2} &#8746; alloced_bhdr_s s)) = 
                         sum_block (all_blocks conf s &#8746; {b1} &#8746; {b2} - {b})&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_blocks_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>sum_block</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;... = sum_block (all_blocks conf s) + block_t_size b1 + block_t_size b2 - block_t_size b&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_implies_diff</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_block_def</span><span> </span><span>Un_is_insert</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Finite_Set.comp_fun_commute.fold_rec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sum_block_f_commute</span><span> </span><span class="delimiter">,</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; free_blocks conf s&#8250;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_blocks_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>comp_fun_commute.fold_insert</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>4</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>comp_fun_commute.fold_insert</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_block_f_commute</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b1 &#8800; b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;split_block r&#39; b = (b1, b2)&#8250;</span></span></span><span> </span><span>bhdr_t.collapse</span><span> </span><span>bhdr_t.inject</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>split_block_def</span><span class="delimiter">)</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_free_not_exist_snd</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;split_block r&#39; b = (b1, b2)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; free_blocks conf s&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_free_not_exist_fst</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;r&#39; &#8800; _&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;split_block r&#39; b = (b1, b2)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; free_blocks conf s&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;... = mem_size conf + block_t_size b1 + block_t_size b2 - block_t_size b&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_block_mem_size s&#8250;</span></span></span><span> </span><span>all_block_mem_size_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_block (insert b1 (free_blocks conf s - {b} &#8746; {b2} &#8746; alloced_bhdr_s s)) 
                      = mem_size conf + block_t_size b1 + block_t_size b2 - block_t_size b&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_t_size b1 + block_t_size b2 = block_t_size b&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>split_block_size_t</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span> </span><span>r&#39;</span><span> </span><span>b1</span><span> </span><span>b2</span><span class="delimiter">,</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_block (insert b1 (free_blocks conf s - {b} &#8746; {b2} &#8746; alloced_bhdr_s s)) = mem_size conf&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ps</span><span> </span><span>i&#39;</span><span> </span><span>j&#39;</span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_block_mem_size_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_blocks_j_lt_sl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_def</span><span> </span><span>all_block_mem_size_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_insert_left</span><span> </span><span>find_opt_is_free</span><span> </span><span>insert_Diff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoare_conjI1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; &#10627;P&#10628; f &#10627;R&#10628;; &#10627;P&#10628; f &#10627;Q&#10628; &#10215; &#10233; &#10627;P&#10628; f &#10627;&#955;r s. Q r s &#8743; R r s&#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>inv_malloc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;inv&#10628; (malloc r ) &#10627;&#955;n. inv &#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoare_conjI1</span><span class="delimiter">)</span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_malloc_no_split_memory</span><span> </span><span>inv_malloc_disjoint_free_non_free</span><span>
</span><span>  </span><span>inv_malloc_disjoint_memory_set</span><span> </span><span>inv_malloc_wf</span><span> </span><span>inv_malloc_wf_adjacency_list</span><span>
</span><span>  </span><span>inv_malloc_all_block_mem_size</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* free inv no split *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suc_freeD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf b s = Some b&#39; &#10233; wf s &#10233; disjoint_memory_set s &#10233; b&#39; &#8712; free_blocks conf s &#8743; e_addr b + 1 + overhead conf = s_addr b&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suc_hdr_free_s_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bs</span><span> </span><span>be</span><span> </span><span>e&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;x. (&#8707;e_addr&#39;. x = Bhdr (Suc (be + overhead conf)) e_addr&#39;) &#8743; x &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b = Bhdr bs be&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; = (THE x. ?P x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Bhdr (Suc (be + overhead conf)) e&#39; &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;! x. ?P x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8712; _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>bspec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>bspec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Bhdr (Suc (be + overhead conf)) e&#39;&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_set_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Bhdr (Suc (be + overhead conf)) e&#39;&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_blocks_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_block_def</span><span> </span><span>disjoint_memory_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_lessD1</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>not_le</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>theI&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?P</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prev_freeD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b s = Some b&#39; &#10233; wf s &#10233; disjoint_memory_set s &#10233; b&#39; &#8712; free_blocks conf s &#8743; e_addr b&#39; + 1 + overhead conf = s_addr b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prev_free_hdr_s_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>be</span><span> </span><span>b&#39;s</span><span> </span><span>b&#39;e</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;x. (&#8707;s_addr&#39;. x = Bhdr s_addr&#39; b&#39;e) &#8743; x &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b = Bhdr (Suc (b&#39;e + overhead conf)) be&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; = (THE x. ?P x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Bhdr b&#39;s b&#39;e &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;! x. ?P x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8712; _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>bspec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>bspec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Bhdr b&#39;s b&#39;e&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_set_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Bhdr b&#39;s b&#39;e&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_blocks_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_block_def</span><span> </span><span>disjoint_memory_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>theI&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?P</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>free_blocks_in_matrix</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s &#10233; b &#8712; free_blocks conf s &#10233; (i, j) = mapping_insert conf (b_size b) &#10233; b &#8712; bhdr_matrix_f s i j&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_adjacency_list_def</span><span> </span><span>free_blocks_def</span><span> </span><span>tlsf_matrix_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>sl_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i&#39;</span><span> </span><span>j&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>i&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>j&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>sl_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>sl_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l2_set_disj</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span> </span><span>mbiggerl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>disjoint_iff_not_equal</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_alloced_is_alloced</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s &#10233; disjoint_memory_set s &#10233; block_alloced addr s &#10233; b = get_alloced_block addr s &#10233; b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Bhdr addr e) &#8712; (alloced_bhdr_s s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>block_alloced_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b = get_alloced_block addr s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;!e_addr. (Bhdr addr e_addr) &#8712; (alloced_bhdr_s s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e_addr</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Bhdr addr e_addr &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;addr &#8804; e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Un_iff</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Bhdr addr e &#8712; alloced_bhdr_s s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;addr &#8804; e_addr&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Un_iff</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Bhdr addr e_addr = Bhdr addr e &#8744; disjoint_memory (Bhdr addr e) (Bhdr addr e_addr)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Bhdr addr e &#8712; alloced_bhdr_s s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_memory_set_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr = e&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>disjoint_memory_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b = _&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>get_alloced_block_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>theI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_not_member_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; S &#10233; S - {x} = S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suc_free_none_remove</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf b s = None &#10233; suc_hdr_free_s conf b (remove_elem_from_matrix b&#39; i j s) = None&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &#8712; bhdr_matrix_f s i j&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_bhdr_matrix_def</span><span> </span><span>remove_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suc_hdr_free_s_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bs</span><span> </span><span>be</span><span> </span><span>be&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Bhdr (Suc (be + overhead conf)) be&#39;&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remove_not_member_id</span><span> </span><span>set_bhdr_matrix_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>remove_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suc_free_none_equiv1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf b (add_block b&#39; s) = None &#10233; suc_hdr_free_s conf b s = None&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span> </span><span>suc_hdr_free_s_def</span><span> </span><span>insert_block_bhdr_matrix_def</span><span> </span><span>set_bhdr_matrix_def</span><span> </span><span>free_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insert_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suc_free_none_equiv2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf b s = None &#10233; e_addr b = e_addr b&#39; &#10233; suc_hdr_free_s conf b&#39; s = None&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suc_hdr_free_s_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suc_free_none_equiv3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf b (remove_elem_from_matrix b&#39; i j s) = None &#10233; 
   e_addr b + 1 + overhead conf &#8800; s_addr b&#39; &#10233; suc_hdr_free_s conf b s = None&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suc_hdr_free_s_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s1</span><span> </span><span>e1</span><span> </span><span>s2</span><span> </span><span>e2</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Bhdr (Suc (e1 + overhead conf)) e_addr&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>free_blocks_def</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>set_bhdr_matrix_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>member_remove</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prev_free_none_equiv1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b (add_block b&#39; s) = None &#10233; prev_free_hdr_s conf b s = None&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span> </span><span>prev_free_hdr_s_def</span><span> </span><span>insert_block_bhdr_matrix_def</span><span> </span><span>set_bhdr_matrix_def</span><span> </span><span>free_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insert_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prev_free_none_equiv2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b s = None &#10233; s_addr b = s_addr b&#39; &#10233; prev_free_hdr_s conf b&#39; s = None&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prev_free_hdr_s_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prev_free_none_equiv3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b (remove_elem_from_matrix b&#39; i j s) = None &#10233; 
   e_addr b&#39; + 1 + overhead conf &#8800; s_addr b &#10233; prev_free_hdr_s conf b s = None&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prev_free_hdr_s_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Bhdr s_addr&#39; e_addr&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>free_blocks_def</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>set_bhdr_matrix_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>member_remove</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_add_block_preserve</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf s &#10233; wf_block b &#10233; wf (add_block b s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mapping_insert_r_in_l2_set</span><span> </span><span>mbiggerl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_blk_mat_s_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_remove_preserve</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf s &#10233; wf (remove_elem_from_matrix b i j s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>wf_def</span><span> </span><span>set_bhdr_matrix_def</span><span> </span><span>all_blocks_def</span><span> </span><span>free_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_preserve_3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf s &#10233; wf_block b &#10233; wf (add_block b (remove_elem_from_matrix b&#39; i j s))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_add_block_preserve</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_remove_preserve</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_of_two_elems</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x &#8800; y &#10233; sum f {x,y} = f x + f y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_of_three_elems</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x &#8800; y &#10233; x &#8800; z &#10233; y &#8800; z &#10233; sum f {x,y,z} = f x + f y + f z&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8800; y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8800; z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8800; z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;A a. infinite A &#8744; finite (insert (a::&#39;a) A)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>finite.insertI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite {y}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f z + sum f {x, y} = f x + f y + f z&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>linordered_field_class.sign_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f5</span><span> </span><span>f4</span><span> </span><span>a3</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insertE</span><span> </span><span>insert_commute</span><span> </span><span>singletonD</span><span> </span><span>sum.insert</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_blocks_size_gt_two_blocks</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;sum_block S = a &#10233; x &#8712; S &#10233; y &#8712; S &#10233; x &#8800; y &#10233; finite S &#10233;
       block_t_size x + block_t_size y &#8804; a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>sum.eq_fold</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>comp_def</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_of_two_elems</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>block_t_size</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hypsubst</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_mono2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_blocks_size_gt_three_blocks</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;sum_block S = a &#10233; x &#8712; S &#10233; y &#8712; S &#10233; z &#8712; S &#10233;
       x &#8800; y &#10233; x &#8800; z &#10233; y &#8800; z &#10233; finite S &#10233;
       block_t_size x + block_t_size y + block_t_size z &#8804; a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>sum.eq_fold</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>comp_def</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_of_three_elems</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>block_t_size</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hypsubst</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_mono2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_join_block</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b1 &#10233; wf_block b2 &#10233; 
   e_addr b1 +1 +overhead conf = s_addr b2 &#10233; 
   block_t_size b1 + block_t_size b2 &#8804; mem_size conf &#10233;
   wf_block (join_block b1 b2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_block_def</span><span> </span><span>join_block_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>b2</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>join_block_assoc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;join_block b1 (join_block b2 b3) = join_block (join_block b1 b2) b3&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>join_block_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_join_block_2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b1 &#10233; wf_block b2 &#10233; wf_block b3 &#10233;
   e_addr b1 +1 +overhead conf = s_addr b2 &#10233; 
   e_addr b2 +1 +overhead conf = s_addr b3 &#10233; 
   block_t_size b1 + block_t_size b2 + block_t_size b3 &#8804; mem_size conf &#10233;
   wf_block (join_block b1 (join_block b2 b3))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_block_def</span><span> </span><span>join_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>b2</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>b3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>free_blocks_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;free_blocks cfg (s&#10631; alloced_bhdr_s:= t &#10632;) = free_blocks cfg s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>free_blocks_simp&#39;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;free_blocks cfg (s&#10631; alloced_bhdr_s:= t, bhdr_matrix_f := m &#10632;) = free_blocks cfg (s&#10631; bhdr_matrix_f := m &#10632;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suc_free_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s cfg b (s&#10631; alloced_bhdr_s:= t &#10632;) = suc_hdr_free_s cfg b s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suc_hdr_free_s_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prev_free_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s cfg b (s&#10631; alloced_bhdr_s:= t &#10632;) = prev_free_hdr_s cfg b s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prev_free_hdr_s_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>disjoint_add_block</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;b&#39; &#8712; all_blocks conf s. disjoint_memory b b&#39; &#10233; 
   disjoint_memory_set s &#10233; disjoint_memory_set (add_block b s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>disjoint_mem_sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>disjoint_remove_block</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s &#10233; 
   free_blocks conf s&#39; &#8804; free_blocks conf s &#10233;
   alloced_bhdr_s s&#39; &#8804; alloced_bhdr_s s &#10233;
   disjoint_memory_set s&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_free_block_size_decrease</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;free_blocks conf (s&#10631; bhdr_matrix_f := set_bhdr_matrix (bhdr_matrix_f s) i j ((bhdr_matrix_f s i j) - {b})&#10632;) &#8804; free_blocks conf s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_bhdr_matrix_def</span><span> </span><span>free_blocks_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>sl_def</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>join_block_disjoint</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b1 + overhead conf + 1 = s_addr b2 &#10233; wf_block b &#10233;
   disjoint_memory b b1 &#10233; disjoint_memory b b2 &#10233; disjoint_memory b (join_block b1 b2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>join_block_def</span><span> </span><span>disjoint_memory_def</span><span> </span><span>wf_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>disjoint_memory_preserve_3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s &#10233; wf_adjacency_list s &#10233; wf s &#10233; disjoint_free_non_free s &#10233;
   e_addr b1 + 1 + overhead conf = s_addr b2 &#10233; j &lt; sl conf &#10233; b1 &#8712; bhdr_matrix_f s i j &#10233; b2 &#8712; alloced_bhdr_s s &#10233;
   disjoint_memory_set (add_block (join_block b1 b2) (remove_elem_from_matrix b1 i j (s&#10631;alloced_bhdr_s := alloced_bhdr_s s - {b2}&#10632;)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_add_block</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_blocks_def</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_set_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_mem_sym</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>join_block_disjoint</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_blocks_def</span><span> </span><span>free_matrix_in_free_block</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory b&#39; (join_block b1 b2)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disjoint_mem_sym</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>join_block_disjoint</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_blocks_def</span><span> </span><span>wf_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>free_matrix_in_free_block</span><span> </span><span>in_empty_interE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_memory_set_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_remove_block</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remove_free_block_size_decrease</span><span> </span><span>remove_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insert_absorb</span><span> </span><span>insert_subset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>disjoint_memory_preserve_2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s &#10233; wf_adjacency_list s &#10233; wf s &#10233; disjoint_free_non_free s &#10233;
   e_addr b1 + 1 + overhead conf = s_addr b2 &#10233; j &lt; sl conf &#10233; b2 &#8712; bhdr_matrix_f s i j &#10233; b1 &#8712; alloced_bhdr_s s &#10233;
   disjoint_memory_set (add_block (join_block b1 b2) (remove_elem_from_matrix b2 i j (s&#10631;alloced_bhdr_s := alloced_bhdr_s s - {b1}&#10632;)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_add_block</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_blocks_def</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_memory_set_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_mem_sym</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>join_block_disjoint</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>free_matrix_in_free_block</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory b&#39; (join_block b1 b2)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disjoint_mem_sym</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>join_block_disjoint</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_blocks_def</span><span> </span><span>wf_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_memory_set_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>free_matrix_in_free_block</span><span> </span><span>in_empty_interE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_remove_block</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remove_free_block_size_decrease</span><span> </span><span>remove_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insert_absorb</span><span> </span><span>insert_subset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suc_free_noneD</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf b s = None &#10233; &#8704;b&#39; &#8712; free_blocks conf s. e_addr b + 1 + overhead conf &#8800; s_addr b&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suc_hdr_free_s_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bhdr_t.collapse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prev_free_noneD</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b s = None &#10233; &#8704;b&#39; &#8712; free_blocks conf s. e_addr b&#39; + 1 + overhead conf &#8800; s_addr b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prev_free_hdr_s_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bhdr_t.collapse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prev_free_some_equiv2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b s = Some p &#10233; s_addr b = s_addr b&#39; &#10233; prev_free_hdr_s conf b&#39; s = Some p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prev_free_hdr_s_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prev_free_some_equiv3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b (remove_elem_from_matrix b&#39; i j s) = Some p &#10233; 
   wf s &#10233; disjoint_memory_set s &#10233;
   e_addr b&#39; + 1 + overhead conf &#8800; s_addr b &#10233; prev_free_hdr_s conf b s = Some p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_freeD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_remove_preserve</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_remove_block</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>remove_elem_from_matrix_def</span><span> 
</span><span>         </span><span>remove_free_block_size_decrease</span><span> </span><span>remove_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prev_free_hdr_s_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="comment">&#8213;&#8249;not empty&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>p</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>set_bhdr_matrix_def</span><span> </span><span>free_blocks_def</span><span>
</span><span>                </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_matrix_f s i j&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s_addr p&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="comment">&#8213;&#8249;equality&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="comment">&#8213;&#8249;existence&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s_addr p&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>set_bhdr_matrix_def</span><span> </span><span>free_blocks_def</span><span>
</span><span>                  </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bhdr_matrix_f s i j&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span> </span><span class="comment">&#8213;&#8249;uniqueness&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>set_bhdr_matrix_def</span><span> </span><span>free_blocks_def</span><span>
</span><span>                  </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_matrix_in_free_block</span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>wf_def</span><span>
</span><span>            </span><span>disjoint_memory_def</span><span> </span><span>wf_block_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>add_lessD1</span><span> </span><span>all_blocks_def</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>leD</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prev_free_eq</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;s_addr b = s_addr b&#39; &#10233;  prev_free_hdr_s conf b s = prev_free_hdr_s conf b&#39; s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prev_free_some_equiv2</span><span> </span><span>prev_free_none_equiv2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>not_None_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;a</span><span> </span><span>set_matrix</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat &#8658; &#39;a set&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>no_overlap_matrix</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a set_matrix &#8658; (nat &#8658; nat &#8658; bool) &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;no_overlap_matrix s P &#8801; (&#8704;x i j i&#39; j&#39;. P i j &#8743; P i&#39; j&#39; &#8743; x &#8712; s i j &#8743; x &#8712; s i&#39; j&#39; &#10230; i = i&#39; &#8743; j = j&#39;) &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>no_overlap_bhdr_matJ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a set_matrix &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;no_overlap_bhdr_matJ s &#8801; no_overlap_matrix s (&#955;_ j. j &lt; sl conf)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_overlap_bhdr_mat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s &#10233; no_overlap_bhdr_matJ (bhdr_matrix_f s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_overlap_matrix_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_block_no_dup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>free_blocks_remove_is_minus&#39;</span><span class="delimiter">:</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* a generalized version of &quot;free_blocks_remove_is_minus&quot; *)</span></span></span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;no_overlap_bhdr_matJ mat &#10233; b &#8712; mat i j &#10233; j &lt; sl conf &#10233;
   free_blocks_mat conf mat = f &#10233;
   free_blocks_mat conf (set_bhdr_matrix mat i j (Set.remove b (mat i j))) = f - {b}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_blocks_mat_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_bhdr_matrix_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ai</span><span> </span><span>aj</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_overlap_matrix_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_bhdr_matrix_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>xi</span><span> </span><span>xj</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Set.remove b (mat xi xj)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>xi</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>xj</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_overlap_matrix_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>xj</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_overlap_mat_remove</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;no_overlap_bhdr_matJ mat &#10233; no_overlap_bhdr_matJ (set_bhdr_matrix mat i j (Set.remove b (mat i j)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_overlap_matrix_def</span><span> </span><span>set_bhdr_matrix_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>free4</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert conf (Suc (e_addr bs) - s_addr bp) = (i, j)&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bp)) = jp&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bs)) = js&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; bhdr_matrix_f s ip jp&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f s is js&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bp&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr bp + 1 + overhead conf = s_addr b&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b + 1 + overhead conf = s_addr bs&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;free_blocks conf
    (remove_elem_from_matrix bp ip jp
      (remove_elem_from_matrix bs is js
        (s&#10631;alloced_bhdr_s := Set.remove b (alloced_bhdr_s s)&#10632;))
     &#10631;bhdr_matrix_f :=
        insert_block_bhdr_matrix
         (bhdr_matrix_f
           (remove_elem_from_matrix bp ip jp
             (remove_elem_from_matrix bs is js
               (s&#10631;alloced_bhdr_s := Set.remove b (alloced_bhdr_s s)&#10632;))))
         i j (Bhdr (s_addr bp) (e_addr bs))&#10632;) = free_blocks conf s - {bs} - {bp} &#8746; {Bhdr (s_addr bp) (e_addr bs)}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>mapping_insert_r_in_l2_set</span><span> </span><span>mbiggerl</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_overlap_mat_remove</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_overlap_bhdr_mat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_bhdr_matrix_def</span><span> </span><span>assms</span><span> </span><span>wf_block_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span>prod.collapse</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span>prod.collapse</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>rule</span><span class="delimiter">+</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_free_no_split_memory</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;&#955;&#963;. inv &#963; &#8743; block_alloced addr &#963;&#10628; (free addr) &#10627;&#955;n &#963;. no_split_memory &#963; &#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>join_prev_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>join_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prod_injects</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hypsubst</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>join_suc_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prod_injects</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hypsubst</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span class="comment">&#8213;&#8249;the case when next block is not free&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="comment">&#8213;&#8249;the case when prev block is not free&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span> </span><span>no_split_memory_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mapping_insert_r_in_l2_set</span><span> </span><span>mbiggerl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block (get_alloced_block addr s)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>all_blocks_def</span><span> </span><span>inv_def</span><span> </span><span>wf_def</span><span> </span><span>get_alloced_is_alloced</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>prev_free_noneD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>suc_free_noneD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>add.assoc</span><span> </span><span>no_split_memory_def</span><span> </span><span>plus_1_eq_Suc</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bp</span><span> </span><span class="comment">&#8213;&#8249;the case when prev block is free&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#10631;alloced_bhdr_s := Set.remove ?b (alloced_bhdr_s s)&#10632;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr bp) (e_addr ?b)) (remove_elem_from_matrix bp ?i ?j ?s&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf ?b s = Some bp&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (prev_free_hdr_s conf b s) = bp&quot;</span></span></span><span>
</span><span>                      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; wf_adjacency_list s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory s&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span>b&#39;</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prev_freeD</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bp&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>  </span><span>free_blocks_in_matrix</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bp &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wfbs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bp&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span>wf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = None&quot;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory ?s&#39;&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_split_memory_def</span><span> </span><span>add_block_def</span><span> </span><span>remove_elem_from_matrix_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert conf (Suc (e_addr b) - s_addr bp)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>i&#39;</span><span> </span><span>j&#39;</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span>  </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bp&#8250;</span></span></span><span> </span><span>b</span><span> </span><span>invs</span><span>  </span><span>prev_freeD</span><span> </span><span>wf_block_def</span><span> </span><span>wfbs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bp &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>add_Suc</span><span> </span><span>no_split_memory_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;suc_hdr_free_s _ ?b s = None&#8250;</span></span></span><span> </span><span>suc_free_noneD</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>add_Suc</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>add_Suc</span><span> </span><span>no_split_memory_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span class="comment">&#8213;&#8249;the case when next block is free&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>join_block_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bs</span><span> </span><span class="comment">&#8213;&#8249;the case when next block is not free&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#10631;alloced_bhdr_s := Set.remove ?b (alloced_bhdr_s s)&#10632;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i ?j ?s&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = Some bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;the (suc_hdr_free_s conf b s) = bs&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>                          </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list ?s&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_adjacency_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b&#39;</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>                     </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b + 1 + overhead conf = s_addr bs&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc_freeD</span><span> </span><span>invs</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bs&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_blocks_in_matrix</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_adjacency_list s&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f ?s&#39; ?i ?j&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bs&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i ?j ?s&#39;) = None&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b s = None&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_none_equiv2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span>wf_block_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>prev_free_none_equiv3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory ?s&#39;&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span> </span><span>no_split_memory_def</span><span> </span><span>add_block_def</span><span> </span><span>remove_elem_from_matrix_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert conf (Suc (e_addr bs) - s_addr b)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>i&#39;</span><span> </span><span>j&#39;</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_ = _&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_ = _&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b&#39;</span><span> </span><span>suc_freeD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf _&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span>wf_block_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;suc_hdr_free_s conf (get_alloced_block addr s) s = Some bs&#8250;</span></span></span><span> </span><span>add_leD1</span><span> </span><span>b</span><span> </span><span>leD</span><span> </span><span>le_trans</span><span> </span><span>less_add_Suc1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;prev_free_hdr_s conf b s = None&#8250;</span></span></span><span> </span><span>prev_free_noneD</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>add.assoc</span><span> </span><span>plus_1_eq_Suc</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inv s&#8250;</span></span></span><span> </span><span>add_Suc</span><span> </span><span>no_split_memory_def</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inv s&#8250;</span></span></span><span> </span><span>add_Suc</span><span> </span><span>no_split_memory_def</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bs</span><span> </span><span>bp</span><span> </span><span class="comment">&#8213;&#8249;the case when next block is free&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#10631;alloced_bhdr_s := Set.remove ?b (alloced_bhdr_s s)&#10632;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr bp) (e_addr bs)) (remove_elem_from_matrix bp ?i ?j (remove_elem_from_matrix bs ?i&#39; ?j&#39; ?s))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = Some bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (suc_hdr_free_s conf b s) = bs&quot;</span></span></span><span>
</span><span>                      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bs&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>                              </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b + 1 + overhead conf = s_addr bs&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc_freeD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f s ?i&#39; ?j&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_blocks_in_matrix</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712;free_blocks conf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bs&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i&#39; ?j&#39; ?s) = Some bp&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b s = Some bp&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_some_equiv2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_some_equiv3</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span>wf_block_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>bp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (prev_free_hdr_s conf b s) = bp&quot;</span></span></span><span>
</span><span>           </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; free_blocks conf s&quot;</span></span></span><span> 
</span><span>           </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr bp + 1 + overhead conf = s_addr b&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prev_freeD</span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bp&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span>invs</span><span> </span><span>free_blocks_in_matrix</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory ?s&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_split_memory_def</span><span> </span><span>add_block_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert conf (b_size (Bhdr (s_addr bp) (e_addr bs)))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free4</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>assumption</span><span> </span><span class="delimiter">|</span><span> </span><span>thin_tac</span><span> </span><span>_</span><span class="delimiter">;</span><span> </span><span>fact</span><span> </span><span class="delimiter">|</span><span> </span><span>rule</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bp&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span>wf_block_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b&#39;</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>add_Suc</span><span> </span><span>bp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>invs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>no_split_memory_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>add_Suc</span><span> </span><span>invs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>no_split_memory_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>add_Suc</span><span> </span><span>invs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>no_split_memory_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_free_disjoint_free_non_free</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;&#955;&#963;. inv &#963;&#8743; block_alloced addr &#963;&#10628; (free addr) &#10627;&#955;n &#963;. disjoint_free_non_free &#963; &#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_def</span><span> </span><span>join_prev_def</span><span> </span><span>join_suc_def</span><span> </span><span>join_block_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>wp</span><span> </span><span class="delimiter">|</span><span> </span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>prod_injects</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span class="comment">&#8213;&#8249;the case when both prev and next are not free&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>add_block_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert conf (b_size (get_alloced_block addr s))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>bp</span><span> </span><span class="comment">&#8213;&#8249;the case when prev is not free but next is free&#8250;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(s&#10631;alloced_bhdr_s := Set.remove (get_alloced_block addr s) (alloced_bhdr_s s)&#10632;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr bp) (e_addr ?b)) (remove_elem_from_matrix bp ?i ?j ?s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf ?b s = Some bp&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (prev_free_hdr_s conf b s) = bp&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; wf_adjacency_list s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span>b&#39;</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prev_freeD</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bp&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>free_blocks_in_matrix</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bp &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wfbs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bp&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span>wf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = None&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free ?s&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>add_block_def</span><span> </span><span>Let_def</span><span>
</span><span>                </span><span>remove_elem_from_matrix_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span>_</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; alloced_bhdr_s s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inv s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>diff_block_diff_e_addr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>bs</span><span> </span><span class="comment">&#8213;&#8249;the case when prev is free but next is not free&#8250;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#10631;alloced_bhdr_s := Set.remove ?b (alloced_bhdr_s s)&#10632;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i ?j ?s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = Some bs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;the (suc_hdr_free_s conf b s) = bs&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>                        </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free s&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list ?s&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_adjacency_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b&#39;</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>                   </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b + 1 + overhead conf = s_addr bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc_freeD</span><span> </span><span>invs</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bs&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_blocks_in_matrix</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_adjacency_list s&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f ?s&#39; ?i ?j&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i ?j ?s&#39;) = None&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b s = None&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_none_equiv2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span>wf_block_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>prev_free_none_equiv3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free ?s&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>add_block_def</span><span> </span><span>Let_def</span><span>
</span><span>                </span><span>remove_elem_from_matrix_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span>_</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; alloced_bhdr_s s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inv s&#8250;</span></span></span><span> </span><span>bhdr_t.exhaust_sel</span><span> </span><span>same_addr_same_block</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_free_non_free s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>bs</span><span> </span><span>bp</span><span> </span><span class="comment">&#8213;&#8249;the case when neither prev nor next is free&#8250;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#10631;alloced_bhdr_s := Set.remove ?b (alloced_bhdr_s s)&#10632;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr bp) (e_addr bs)) (remove_elem_from_matrix bp ?i ?j (remove_elem_from_matrix bs ?i&#39; ?j&#39; ?s))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = Some bs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (suc_hdr_free_s conf b s) = bs&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bs&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>                            </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b + 1 + overhead conf = s_addr bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc_freeD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f s ?i&#39; ?j&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_blocks_in_matrix</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712;free_blocks conf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i&#39; ?j&#39; ?s) = Some bp&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b s = Some bp&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_some_equiv2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_some_equiv3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span>wf_block_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>bp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (prev_free_hdr_s conf b s) = bp&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; free_blocks conf s&quot;</span></span></span><span> 
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr bp + 1 + overhead conf = s_addr b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prev_freeD</span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bp&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span>invs</span><span> </span><span>free_blocks_in_matrix</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free ?s&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>add_block_def</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>assumption</span><span> </span><span class="delimiter">|</span><span> </span><span>rule</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span>_</span><span class="delimiter">;</span><span> </span><span>fact</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>IntI</span><span> </span><span>Un_upper2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inv s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>contra_subsetD</span><span> 
</span><span>             </span><span>diff_block_diff_e_addr</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>empty_iff</span><span> </span><span>invs</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>sup_commute</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_free_disjoint_memory_set</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;&#955;&#963;. inv &#963;&#8743; block_alloced addr &#963;&#10628; (free addr) &#10627;&#955;n &#963;. disjoint_memory_set &#963; &#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_def</span><span> </span><span>join_prev_def</span><span> </span><span>join_suc_def</span><span> </span><span>join_block_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>wp</span><span> </span><span class="delimiter">|</span><span> </span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>prod_injects</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>add_block_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert conf (b_size (get_alloced_block addr s))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>insert_is_union_conf</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>insert_is_union_conf</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UnE</span><span> </span><span>Un_is_insert</span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>get_alloced_is_alloced</span><span> </span><span>insertE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>bp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(s&#10631;alloced_bhdr_s := Set.remove (get_alloced_block addr s) (alloced_bhdr_s s)&#10632;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr bp) (e_addr ?b)) (remove_elem_from_matrix bp ?i ?j ?s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf ?b s = Some bp&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (prev_free_hdr_s conf b s) = bp&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; wf_adjacency_list s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span>b&#39;</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>                   </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr bp + 1 +overhead conf = s_addr b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prev_freeD</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bp&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>free_blocks_in_matrix</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bp &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wfbs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bp&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span>wf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = None&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set ?s&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_memory_preserve_3</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>join_block_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span> </span><span>mbiggerl</span><span> </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>bs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#10631;alloced_bhdr_s := Set.remove ?b (alloced_bhdr_s s)&#10632;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i ?j ?s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = Some bs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;the (suc_hdr_free_s conf b s) = bs&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>                        </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free s&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list ?s&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_adjacency_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b&#39;</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>                   </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b + 1 + overhead conf = s_addr bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc_freeD</span><span> </span><span>invs</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bs&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_blocks_in_matrix</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_adjacency_list s&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f ?s&#39; ?i ?j&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i ?j ?s&#39;) = None&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b s = None&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_none_equiv2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span>wf_block_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>prev_free_none_equiv3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set ?s&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span> </span><span>remove_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_memory_preserve_2</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>join_block_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>mapping_insert_r_in_l2_set</span><span> </span><span>mbiggerl</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>bs</span><span> </span><span>bp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#10631;alloced_bhdr_s := Set.remove ?b (alloced_bhdr_s s)&#10632;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr bp) (e_addr bs)) (remove_elem_from_matrix bp ?i ?j (remove_elem_from_matrix bs ?i&#39; ?j&#39; ?s))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = Some bs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (suc_hdr_free_s conf b s) = bs&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bs&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>                            </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b + 1 + overhead conf = s_addr bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc_freeD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f s ?i&#39; ?j&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_blocks_in_matrix</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712;free_blocks conf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i&#39; ?j&#39; ?s) = Some bp&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b s = Some bp&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_some_equiv2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_some_equiv3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span>wf_block_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>bp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (prev_free_hdr_s conf b s) = bp&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; free_blocks conf s&quot;</span></span></span><span> 
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr bp + 1 + overhead conf = s_addr b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prev_freeD</span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bp&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span>invs</span><span> </span><span>free_blocks_in_matrix</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set ?s&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_add_block</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>all_blocks_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b&#39;</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>free_blocks_remove_is_minus&#39;</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_overlap_mat_remove</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_overlap_bhdr_mat</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_bhdr_matrix_def</span><span> 
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bp &#8712; bhdr_matrix_f s ?i ?j&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bp&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span>wf_block_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span> </span><span>mbiggerl</span><span> </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>remove_is_minus_conf</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* do not know how this works yet... *)</span></span></span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &#8712; free_blocks conf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &#8800; bs&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &#8800; bp&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory b&#39; bp&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b&#39; &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b&#39; &#8800; bp&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>bp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory b&#39; bs&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b&#39; &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b&#39; &#8800; bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory b&#39; b&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; alloced_bhdr_s s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b&#39; &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>in_empty_interE</span><span> </span><span>invs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>invs</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&#39;&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b&#39; &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>wf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory (Bhdr (s_addr bp) (e_addr bs)) b&#39;&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bp&#8250;</span></span></span><span> </span><span>wf_def</span><span> </span><span>disjoint_memory_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr b&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>add_Suc</span><span> </span><span>add_lessD1</span><span> </span><span>bhdr_t.sel</span><span> </span><span>leD</span><span> </span><span>le_less_trans</span><span> </span><span>not_less_eq_eq</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b&#39;</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &#8712; alloced_bhdr_s s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &#8800; b&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory b&#39; bp&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>all_blocks_def</span><span> </span><span>bp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>calculation</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>disjoint_iff_not_equal</span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>invs</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory b&#39; bs&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>calculation</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>in_empty_interE</span><span> </span><span>invs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>invs</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory b&#39; b&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; alloced_bhdr_s s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>calculation</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>calculation</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&#39;&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span>calculation</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>invs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>wf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory (Bhdr (s_addr bp) (e_addr bs)) b&#39;&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bp&#8250;</span></span></span><span> </span><span>wf_def</span><span> </span><span>disjoint_memory_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr b&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>add.assoc</span><span> </span><span>add.commute</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>join_block_def</span><span> </span><span>join_block_disjoint</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjoint_remove_block</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_bhdr_matrix_def</span><span> </span><span>free_blocks_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_free_wf</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;&#955;&#963;. inv &#963;&#8743; block_alloced addr &#963;&#10628; (free addr) &#10627;&#955;n &#963;. wf &#963; &#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_def</span><span> </span><span>join_prev_def</span><span> </span><span>join_suc_def</span><span> </span><span>join_block_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>wp</span><span> </span><span class="delimiter">|</span><span> </span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>prod_injects</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> </span><span>wf_def</span><span> </span><span>add_block_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert conf (b_size (get_alloced_block addr s))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>insert_is_union_conf</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span>get_alloced_is_alloced</span><span> </span><span>wf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>bp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(s&#10631;alloced_bhdr_s := Set.remove (get_alloced_block addr s) (alloced_bhdr_s s)&#10632;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr bp) (e_addr ?b)) (remove_elem_from_matrix bp ?i ?j ?s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf ?b s = Some bp&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (prev_free_hdr_s conf b s) = bp&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; wf_adjacency_list s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_block_mem_size s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span>b&#39;</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>                   </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr bp + 1 +overhead conf = s_addr b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prev_freeD</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bp&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>free_blocks_in_matrix</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bp &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wfbs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bp&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span>wf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = None&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block (join_block bp b)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_join_block</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_blocks_size_gt_two_blocks</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_block_mem_size s&#8250;</span></span></span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>all_block_mem_size_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bp &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bp&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr b&#8250;</span></span></span><span> </span><span>wf_block_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_block_is_finite</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf ?s&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_preserve_3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span> </span><span>join_block_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>bs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#10631;alloced_bhdr_s := Set.remove ?b (alloced_bhdr_s s)&#10632;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i ?j ?s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = Some bs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;the (suc_hdr_free_s conf b s) = bs&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>                        </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_block_mem_size s&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list ?s&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_adjacency_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b&#39;</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>                   </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b + 1 + overhead conf = s_addr bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc_freeD</span><span> </span><span>invs</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bs&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_blocks_in_matrix</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_adjacency_list s&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f ?s&#39; ?i ?j&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i ?j ?s&#39;) = None&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b s = None&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_none_equiv2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span>wf_block_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>prev_free_none_equiv3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block (join_block b bs)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_join_block</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_blocks_size_gt_two_blocks</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_block_mem_size s&#8250;</span></span></span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>all_block_mem_size_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span>wf_block_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_block_is_finite</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf ?s&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_preserve_3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>join_block_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>bs</span><span> </span><span>bp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#10631;alloced_bhdr_s := Set.remove ?b (alloced_bhdr_s s)&#10632;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr bp) (e_addr bs)) (remove_elem_from_matrix bp ?i ?j (remove_elem_from_matrix bs ?i&#39; ?j&#39; ?s))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = Some bs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (suc_hdr_free_s conf b s) = bs&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_block_mem_size s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bs&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>                            </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b + 1 + overhead conf = s_addr bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc_freeD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f s ?i&#39; ?j&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_blocks_in_matrix</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712;free_blocks conf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i&#39; ?j&#39; ?s) = Some bp&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b s = Some bp&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_some_equiv2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_some_equiv3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span>wf_block_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>bp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (prev_free_hdr_s conf b s) = bp&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; free_blocks conf s&quot;</span></span></span><span> 
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr bp + 1 + overhead conf = s_addr b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prev_freeD</span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bp&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span>invs</span><span> </span><span>free_blocks_in_matrix</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block (join_block bp (join_block b bs))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_join_block_2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_blocks_size_gt_three_blocks</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_block_mem_size s&#8250;</span></span></span><span> </span><span>all_block_mem_size_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; _&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bp &#8712; free_blocks _ _&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks _ _&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bp&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span>wf_block_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_block_is_finite</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block (Bhdr (s_addr bp) (e_addr bs))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>join_block_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf ?s&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_preserve_3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_remove_preserve</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_free_wf_adjacency_list</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;&#955;&#963;. inv &#963;&#8743; block_alloced addr &#963;&#10628; (free addr) &#10627;&#955;n &#963;. wf_adjacency_list &#963; &#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_def</span><span> </span><span>join_prev_def</span><span> </span><span>join_suc_def</span><span> </span><span>join_block_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>wp</span><span> </span><span class="delimiter">|</span><span> </span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>prod_injects</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span> </span><span>wf_adjacency_list_def</span><span> </span><span>set_bhdr_matrix_def</span><span>
</span><span>                  </span><span>tlsf_matrix_def</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span>
</span><span>          </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>add_block_wf_adjacency</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* all_block_mem_size *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_join_block</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b1 + 1 + overhead conf = s_addr b2 &#10233;
   wf_block b1 &#10233; wf_block b2 &#10233;
   block_t_size (join_block b1 b2) = block_t_size b1 + block_t_size b2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>join_block_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>b2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8800; bb &#10233; b &#8800; bb &#10233; b &#8713; s &#10233; a &#8713; t &#10233;
   insert (bb) (s - {a} &#8746; (t - {b})) = s &#8746; t  &#8746; {bb} - {a} - {b}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8800; bb &#10233; b &#8800; bb &#10233; c &#8800; bb &#10233; b &#8713; s &#10233; a &#8713; t &#10233; c &#8713; t &#10233;
   insert (bb) (s - {a} - {c} &#8746; (t - {b})) = s &#8746; t  &#8746; {bb} - {a} - {c} - {b}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_free_all_block_mem_size</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;&#955;&#963;. inv &#963;&#8743; block_alloced addr &#963;&#10628; (free addr) &#10627;&#955;n &#963;. all_block_mem_size &#963; &#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_def</span><span> </span><span>join_prev_def</span><span> </span><span>join_suc_def</span><span> </span><span>join_block_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>wp</span><span> </span><span class="delimiter">|</span><span> </span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>prod_injects</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span> </span><span>all_block_mem_size_def</span><span> </span><span>all_blocks_def</span><span> </span><span>add_block_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert conf (b_size (get_alloced_block addr s))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>insert_is_union_conf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>get_alloced_is_alloced</span><span> </span><span>insert_Diff</span><span> </span><span>insert_is_Un</span><span> </span><span>remove_def</span><span> </span><span>sup_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>bp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(s&#10631;alloced_bhdr_s := Set.remove (get_alloced_block addr s) (alloced_bhdr_s s)&#10632;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr bp) (e_addr ?b)) (remove_elem_from_matrix bp ?i ?j ?s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf ?b s = Some bp&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (prev_free_hdr_s conf b s) = bp&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; wf_adjacency_list s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free s&quot;</span></span></span><span>
</span><span>               </span><span class="string"><span class="delete"><span class="delete">&quot;all_block_mem_size s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span>b&#39;</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>                   </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr bp + 1 +overhead conf = s_addr b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prev_freeD</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bp&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>free_blocks_in_matrix</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bp &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wfbs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bp&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span>wf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_t_size (join_block bp b) = block_t_size bp + block_t_size b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>size_join_block</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (all_blocks conf s)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_block_is_finite</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_block_mem_size s&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = None&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_block_mem_size ?s&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span> </span><span>remove_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span> </span><span>all_block_mem_size_def</span><span> </span><span>all_blocks_def</span><span> </span><span>remove_elem_from_matrix_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert conf (b_size (Bhdr (s_addr bp) (e_addr b)))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>insert_is_union_conf</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>remove_is_minus_conf</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_block (insert (Bhdr (s_addr bp) (e_addr b)) (free_blocks conf s - {bp} &#8746; (alloced_bhdr_s s - {b}))) = 
            sum_block (all_blocks conf s &#8746; {(Bhdr (s_addr bp) (e_addr b))} - {bp} - {b})&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span> </span><span>sum_block</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_blocks_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>h1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;block_t_size (join_block bp b) = block_t_size bp + block_t_size b&#8250;</span></span></span><span> </span><span>join_block_def</span><span> </span><span>oh_gt_0</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; alloced_bhdr_s s&#8250;</span></span></span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bp &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = sum_block (all_blocks conf s) + block_t_size (Bhdr (s_addr bp) (e_addr b)) - block_t_size bp - block_t_size b&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_implies_diff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_block_def</span><span> </span><span>Un_is_insert</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>comp_fun_commute.fold_rec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sum_block_f_commute</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span>  </span><span>b</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; alloced_bhdr_s s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bp &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_implies_diff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>comp_fun_commute.fold_rec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sum_block_f_commute</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span>  </span><span>bp</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; alloced_bhdr_s s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bp &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>comp_fun_commute.fold_insert</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_block_f_commute</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;block_t_size (join_block bp b) = block_t_size bp + block_t_size b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bp &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inv s&#8250;</span></span></span><span> </span><span>add_gr_0</span><span> 
</span><span>                </span><span>all_blocks_def</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>diff_block_diff_s_addr</span><span> </span><span>join_block_def</span><span> </span><span>less_add_same_cancel1</span><span> </span><span>nat_less_le</span><span> </span><span>oh_gt_0</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = sum_block (all_blocks conf s)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;block_t_size (join_block bp b) = block_t_size bp + block_t_size b&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>join_block_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_block (insert (Bhdr (s_addr bp) (e_addr b)) (free_blocks conf s - {bp} &#8746; (alloced_bhdr_s s - {b}))) = mem_size conf&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_block_mem_size s&#8250;</span></span></span><span> </span><span>all_block_mem_size_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>bs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#10631;alloced_bhdr_s := Set.remove ?b (alloced_bhdr_s s)&#10632;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i ?j ?s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = Some bs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;the (suc_hdr_free_s conf b s) = bs&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>                        </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free s&quot;</span></span></span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">&quot;all_block_mem_size s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list ?s&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_adjacency_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b&#39;</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>                   </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b + 1 + overhead conf = s_addr bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc_freeD</span><span> </span><span>invs</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bs&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_blocks_in_matrix</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_adjacency_list s&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f ?s&#39; ?i ?j&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i ?j ?s&#39;) = None&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b s = None&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_none_equiv2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span>wf_block_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>prev_free_none_equiv3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_t_size (join_block b bs) = block_t_size b + block_t_size bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>size_join_block</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (all_blocks conf s)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_block_is_finite</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_block_mem_size s&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_block_mem_size ?s&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span> </span><span>remove_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span> </span><span>all_block_mem_size_def</span><span> </span><span>all_blocks_def</span><span> </span><span>remove_elem_from_matrix_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert conf (b_size (Bhdr (s_addr b) (e_addr bs)))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>insert_is_union_conf</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>remove_is_minus_conf</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_block (insert (Bhdr (s_addr b) (e_addr bs)) (free_blocks conf s - {bs} &#8746; (alloced_bhdr_s s - {b}))) = 
            sum_block (all_blocks conf s &#8746; {(Bhdr (s_addr b) (e_addr bs))} - {bs} - {b})&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span> </span><span>sum_block</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_blocks_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>h1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;block_t_size (join_block b bs) = block_t_size b + block_t_size bs&#8250;</span></span></span><span> </span><span>join_block_def</span><span> </span><span>oh_gt_0</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; alloced_bhdr_s s&#8250;</span></span></span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = sum_block (all_blocks conf s) + block_t_size (Bhdr (s_addr b) (e_addr bs)) - block_t_size bs - block_t_size b&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_implies_diff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_block_def</span><span> </span><span>Un_is_insert</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>comp_fun_commute.fold_rec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sum_block_f_commute</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span>  </span><span>b</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; alloced_bhdr_s s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_implies_diff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>comp_fun_commute.fold_rec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sum_block_f_commute</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span>  </span><span>bs</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; alloced_bhdr_s s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>comp_fun_commute.fold_insert</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_block_f_commute</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;block_t_size (join_block b bs) = block_t_size b + block_t_size bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inv s&#8250;</span></span></span><span> </span><span>add_diff_cancel_right&#39;</span><span> 
</span><span>               </span><span>all_blocks_def</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>diff_block_diff_e_addr</span><span> </span><span>diff_is_0_eq</span><span> </span><span>join_block_def</span><span> </span><span>leD</span><span> </span><span>le_add2</span><span> </span><span>oh_gt_0</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = sum_block (all_blocks conf s)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;block_t_size _ = _&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>join_block_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_block (insert (Bhdr (s_addr b) (e_addr bs)) (free_blocks conf s - {bs} &#8746; (alloced_bhdr_s s - {b}))) = mem_size conf&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_block_mem_size s&#8250;</span></span></span><span> </span><span>all_block_mem_size_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>bs</span><span> </span><span>bp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bp))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#10631;alloced_bhdr_s := Set.remove ?b (alloced_bhdr_s s)&#10632;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (mapping_insert conf (b_size bs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_block (Bhdr (s_addr bp) (e_addr bs)) (remove_elem_from_matrix bp ?i ?j (remove_elem_from_matrix bs ?i&#39; ?j&#39; ?s))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suc_hdr_free_s conf ?b s = Some bs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (suc_hdr_free_s conf b s) = bs&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_alloced_block addr s = b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;no_split_memory s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_adjacency_list s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_free_non_free s&quot;</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">&quot;all_block_mem_size s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = Some bs&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; free_blocks conf s&quot;</span></span></span><span>
</span><span>                            </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr b + 1 + overhead conf = s_addr bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc_freeD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs &#8712; bhdr_matrix_f s ?i&#39; ?j&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_blocks_in_matrix</span><span> </span><span>invs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_alloced addr s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712;free_blocks conf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf (Bhdr (s_addr ?b) (e_addr bs)) (remove_elem_from_matrix bs ?i&#39; ?j&#39; ?s) = Some bp&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf b s = Some bp&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_some_equiv2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_some_equiv3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disjoint_memory_set_def</span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disjoint_memory_set s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span>wf_block_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>bp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the (prev_free_hdr_s conf b s) = bp&quot;</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; free_blocks conf s&quot;</span></span></span><span> 
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;e_addr bp + 1 + overhead conf = s_addr b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prev_freeD</span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp &#8712; bhdr_matrix_f s ?i ?j&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf_block bp&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span>invs</span><span> </span><span>free_blocks_in_matrix</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_t_size (join_block b bs) = block_t_size b + block_t_size bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>size_join_block</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_t_size (join_block bp (join_block b bs)) = block_t_size bp + block_t_size (join_block b bs)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>size_join_block</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr b&#8250;</span></span></span><span> </span><span>join_block_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_join_block</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_blocks_size_gt_two_blocks</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_block_mem_size s&#8250;</span></span></span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>all_block_mem_size_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_blocks_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf_block bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = s_addr bs&#8250;</span></span></span><span> </span><span>wf_block_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_block_is_finite</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_t_size (Bhdr (s_addr bp) (e_addr bs)) = block_t_size bp + block_t_size b + block_t_size bs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>join_block_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (all_blocks conf s)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_block_is_finite</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_block_mem_size s&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_block_mem_size ?s&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_block_mem_size_def</span><span> </span><span>all_blocks_def</span><span> </span><span>add_block_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_insert conf (b_size (Bhdr (s_addr bp) (e_addr bs)))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span>_</span><span class="delimiter">;</span><span> </span><span>fact</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span>_</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_block (insert (Bhdr (s_addr bp) (e_addr bs)) (free_blocks conf s - {bs} - {bp} &#8746; (alloced_bhdr_s s - {b}))) = 
            sum_block (all_blocks conf s &#8746; {Bhdr (s_addr bp) (e_addr bs)} - {bs} - {bp} - {b})&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span> </span><span>sum_block</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_blocks_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>h2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;block_t_size (Bhdr (s_addr bp) (e_addr bs)) = block_t_size bp + block_t_size b + block_t_size bs&#8250;</span></span></span><span> </span><span>oh_gt_0</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bp</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>invs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>no_split_memory_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = sum_block (all_blocks conf s) + block_t_size (Bhdr (s_addr bp) (e_addr bs)) - block_t_size bs - block_t_size bp - block_t_size b&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_implies_diff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_block_def</span><span> </span><span>Un_is_insert</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>comp_fun_commute.fold_rec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sum_block_f_commute</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span>  </span><span>b</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8712; alloced_bhdr_s s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>bp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>disjoint_free_non_free_def</span><span> </span><span>invs</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_implies_diff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>comp_fun_commute.fold_rec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sum_block_f_commute</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span>  </span><span>bp</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;block_t_size (Bhdr (s_addr bp) (e_addr bs)) = block_t_size bp + block_t_size b + block_t_size bs&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span> </span><span>bp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>oh_gt_0</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_implies_diff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>comp_fun_commute.fold_rec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sum_block_f_commute</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span>  </span><span>bs</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span>all_blocks_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>comp_fun_commute.fold_insert</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_block_f_commute</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;block_t_size (Bhdr (s_addr bp) (e_addr bs)) = block_t_size bp + block_t_size b + block_t_size bs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bs &#8712; free_blocks conf s&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inv s&#8250;</span></span></span><span> 
</span><span>               </span><span>add_cancel_left_left</span><span> </span><span>add_eq_0_iff_both_eq_0</span><span> </span><span>all_blocks_def</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>diff_block_diff_e_addr</span><span> </span><span>neq0_conv</span><span> </span><span>oh_gt_0</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = sum_block (all_blocks conf s)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;block_t_size (Bhdr _ _) = _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_block (insert (Bhdr (s_addr bp) (e_addr bs)) (free_blocks conf s - {bs} - {bp} &#8746; (alloced_bhdr_s s - {b}))) = mem_size conf&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_block_mem_size s&#8250;</span></span></span><span> </span><span>all_block_mem_size_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>inv_free</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;&#955;&#963;. inv &#963;&#8743; block_alloced addr &#963;&#10628; (free addr) &#10627;&#955;n &#963;. inv &#963; &#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoare_conjI1</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_free_no_split_memory</span><span> </span><span>inv_free_disjoint_free_non_free</span><span>
</span><span>  </span><span>inv_free_disjoint_memory_set</span><span> </span><span>inv_free_wf</span><span> </span><span>inv_free_wf_adjacency_list</span><span>
</span><span>  </span><span>inv_free_all_block_mem_size</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>valid_def</span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;properties&#8250;</span><span> 
</span><span>
</span><span class="comment">&#8213; &#8249;malloc returns 0 if the size to be allocated is larger than the biggest available block&#8250;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r_gt_max_block_fail</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#10627;(&#955;&#963;. (inv s) &#8743; (suitable_blocks conf (snd (mapping_search conf r)) &#963; = {})) &#10628; 
        (malloc r) &#10627;&#955;ret s. ret = 0&#10628;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>malloc_def</span><span> </span><span>remove_block_def</span><span> </span><span>Let_def</span><span> </span><span>find_suitable_blocks_opt_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>wpsimp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>next_block_j_lt_sl</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;j &lt; sl conf &#10233; next_block conf (i, j) = (i&#39;, j&#39;) &#10233; j&#39; &lt; sl conf&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>next_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_search_j_lt_sl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_search conf r = (r&#39;, i ,j) &#10233; j &lt; sl conf&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mapping_search_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>if_splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>next_block_j_lt_sl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>next_block_j_lt_sl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapping_insert_r_in_l2_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span class="delimiter">+</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r_gt_min_block_alloc</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;(&#955;&#963;&#39;. &#963;=&#963;&#39; &#8743; inv &#963; &#8743; r&#39;=fst (mapping_search conf r) &#8743; suitable_blocks conf (snd (mapping_search conf r)) &#963; &#8800;{})&#10628;
     malloc r 
  &#10627;(&#955;addr &#963;&#39;. addr &gt; 0 &#8743; 
   (&#8707;b &#8712; free_blocks conf &#963;. 
    s_addr b = addr &#8743; b_size b &#8805; r&#39; &#8743; 
  ((b_size b - r&#39;) &#8805; min_block conf &#10230; 
     (&#8707;b&#39; b&#39;&#39;. (alloced_bhdr_s &#963;&#39; = alloced_bhdr_s &#963; &#8746; {b&#39;})  &#8743; 
              (free_blocks conf &#963;) - {b} &#8746; {b&#39;&#39;}  = free_blocks conf &#963;&#39;  &#8743; 
              (b&#39;,b&#39;&#39;) = split_block r&#39; b)) &#8743;
  ((b_size b - r&#39;) &lt; min_block conf &#10230; 
              (alloced_bhdr_s &#963;&#39; = alloced_bhdr_s &#963; &#8746; {b})  &#8743; 
              (free_blocks conf &#963;) = free_blocks conf &#963;&#39; &#8746; {b})))&#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>malloc_def</span><span> </span><span>remove_block_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>wpsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="comment">&#8213;&#8249;No suitable blocks -- Trivially False&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_suitable_blocks_opt_def</span><span> </span><span>Let_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ballI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>r&#39;</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span>p</span><span> </span><span>b</span><span>  </span><span class="comment">&#8213;&#8249;Split block&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>free_matrix_in_free_block</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.sel</span><span> </span><span>prod.collapse</span><span> </span><span>suitable_blocks_j_lt_sl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>impI</span><span> </span><span>allI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b1</span><span> </span><span>b2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_def</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span> </span><span>split_block_def</span><span> </span><span>oh_gt_0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>all_blocks_def</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span> </span><span>neq0_conv</span><span> </span><span>not_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b1</span><span> </span><span>b2</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_block_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_block_gt_overhead</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span> </span><span>Let_def</span><span> </span><span>remove_elem_from_matrix_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span> </span><span>Let_def</span><span> </span><span>remove_elem_from_matrix_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_insert_is_union</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mapping_insert_r_in_l2_set</span><span> </span><span>mbiggerl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>prod.collapse</span><span> </span><span>suitable_blocks_j_lt_sl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>r&#39;</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span>p</span><span> </span><span>b</span><span>  </span><span class="comment">&#8213;&#8249;No Split block&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>free_matrix_in_free_block</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.sel</span><span> </span><span>prod.collapse</span><span> </span><span>suitable_blocks_j_lt_sl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_def</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span> </span><span>all_blocks_def</span><span> </span><span>oh_gt_0</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>Un_iff</span><span> </span><span>neq0_conv</span><span> </span><span>not_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;y. find_suitable_blocks_opt (i, j) &#963; = Some y&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ps</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;find_suitable_blocks_opt (i, j) &#963; = Some ps&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv &#963;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; wf_adjacency_list &#963;&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_search conf r = (r&#39;, i, j)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>l1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;r&#39; &#8712; l2_set conf i j&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mapping_search_def</span><span> </span><span>Let_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mbiggerl</span><span> </span><span>range_l2_disj</span><span> </span><span>fst_range_in_set</span><span> </span><span>l2_set_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j &lt; sl conf&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>map_search_j_lt_sl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p &#8712; the (find_suitable_blocks_opt (i, j) &#963;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>l2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(i,j) &#8804;<span class="hidden">&#8681;</span><sub>b</sub> p&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_blocks_ij_increase</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_suitable_blocks_opt (i, j) &#963; = Some ps&#8250;</span></span></span><span> </span><span>option.sel</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd p &lt; sl conf&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>suitable_blocks_j_lt_sl</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst p&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_suitable_blocks_opt (i, j) &#963; = Some ps&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p &#8712; the (find_suitable_blocks_opt (i, j) &#963;)&#8250;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; bhdr_matrix_f &#963; (fst p) (snd p)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;b_size b &#8712; l2_set conf (fst p) (snd p)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>block_mat_size</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1</span><span> </span><span>l2</span><span> </span><span>l3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#39; &#8804; b_size b&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>block_let_def</span><span> </span><span>block_lt_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l2_set_mapping_search_geq_r</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mapping_search conf _ = _&#8250;</span></span></span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>snd_range_l2_i_j_less_fst_i&#39;_j&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&lt; _&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(snd p)&lt;_&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_set_def</span><span> </span><span>Let_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>snd_range_l2_i_j_less_fst_j&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mbiggerl</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst p&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l2_set_def</span><span> </span><span>Let_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>Let_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>free_blk_mat_s_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free_blocks_remove_is_minus</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>prod.collapse</span><span> </span><span>suitable_blocks_j_lt_sl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(b1, b2) = split_block r b &#10233; (b2, b1) = split_block r b &#10233; False&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_block_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>b1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>b2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>oh_gt_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exist_split_prev_equiv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf s &#10233; disjoint_memory_set s &#10233;
   (&#8707;b&#39; bc r. b&#39; &#8712; free_blocks conf s &#8743; (b&#39;, b) = split_block r bc) &#10231; (&#8707;bp. prev_free_hdr_s conf b s = Some bp)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b&#39;</span><span> </span><span>bc</span><span> </span><span>r</span><span>
</span><span>          </span><span class="comment">&#8213;&#8249;uncomment the following proof script to get a different problem&#8250;</span><span>
</span><span>          </span><span class="comment">&#8213;&#8249;whether or not should we prove bp is THE b. P b ?&#8250;</span><span>
</span><span>          </span><span class="comment">&#8213;&#8249;this means whether or not should we prove the uniqueness of bp&#8250;</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*apply (rule exI[of _ b&#39;])
    unfolding prev_free_hdr_s_def
    apply auto*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prev_free_hdr_s_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split_block_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred</span><span> </span><span>Un_iff</span><span> </span><span>add.commute</span><span> </span><span>all_blocks_def</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>diff_0_eq_0</span><span> </span><span>diff_add_inverse</span><span> </span><span>neq0_conv</span><span> </span><span>not_le</span><span> </span><span>oh_gt_0</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_freeD</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_block_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>bp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_le_eq</span><span> </span><span>Un_iff</span><span> </span><span>add_diff_inverse_nat</span><span> </span><span>all_blocks_def</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>diff_Suc_Suc</span><span> </span><span>diff_zero</span><span> </span><span>less_imp_le_nat</span><span> </span><span>not_le</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exist_split_prev_equiv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;b&#39; bc r. b&#39; &#8712; free_blocks conf s &#10230; (b&#39;, b) &#8800; split_block r bc) &#10231; prev_free_hdr_s conf b s = None&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exist_split_prev_equiv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>option.exhaust</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exist_split_suc_equiv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf s &#10233; disjoint_memory_set s &#10233; b &#8712; alloced_bhdr_s s &#10233;
   (&#8707;b&#39; bc r. b&#39; &#8712; free_blocks conf s &#8743; (b, b&#39;) = split_block r bc) &#10231; (&#8707;bs. suc_hdr_free_s conf b s = Some bs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b&#39;</span><span> </span><span>bc</span><span> </span><span>r</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suc_hdr_free_s_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split_block_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred</span><span> </span><span>Un_iff</span><span> </span><span>add_diff_cancel_right&#39;</span><span> </span><span>all_blocks_def</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>diff_0_eq_0</span><span> </span><span>diff_is_0_eq</span><span> </span><span>diff_zero</span><span> </span><span>neq0_conv</span><span> </span><span>oh_gt_0</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>suc_freeD</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_block_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>bp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_le_eq</span><span> </span><span>Un_iff</span><span> </span><span>add_diff_inverse_nat</span><span> </span><span>all_blocks_def</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>diff_Suc_Suc</span><span> </span><span>diff_zero</span><span> </span><span>less_imp_le_nat</span><span> </span><span>not_le</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_exist_split_suc_equiv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disjoint_memory_set s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; alloced_bhdr_s s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;b&#39; bc r. b&#39; &#8712; free_blocks conf s &#10230; (b, b&#39;) &#8800; split_block r bc) &#10231; suc_hdr_free_s conf b s = None&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exist_split_suc_equiv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exist_split__prev_suc_equiv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf s &#10233; disjoint_memory_set s &#10233; b &#8712; alloced_bhdr_s s &#10233;
   (&#8707;b1 b2 bc bc&#39; r r&#39;. b1 &#8712; free_blocks conf s  &#8743; b2 &#8712; free_blocks conf s
                     &#8743; (b1, bc&#39;) = split_block r bc &#8743; (b, b2) = split_block r&#39; bc&#39;)
   &#10231; (&#8707;bs. suc_hdr_free_s conf b s = Some bs) &#8743; (&#8707;bp. prev_free_hdr_s conf b s = Some bp)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exist_split_suc_equiv</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>exist_split_prev_equiv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b1</span><span> </span><span>b2</span><span> </span><span>bc</span><span> </span><span>bc&#39;</span><span> </span><span>r</span><span> </span><span>r&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Bhdr (s_addr b1) (e_addr b)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b_size b1&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_block_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred</span><span> </span><span>Un_upper2</span><span> </span><span>add.commute</span><span> </span><span>all_blocks_def</span><span> </span><span>bhdr_t.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>contra_subsetD</span><span> </span><span>diff_0_eq_0</span><span> 
</span><span>       </span><span>diff_add_inverse</span><span> </span><span>neq0_conv</span><span> </span><span>not_le</span><span> </span><span>oh_gt_0</span><span> </span><span>wf_def</span><span> </span><span>sup_commute</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bs</span><span> </span><span>bp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>suc_freeD</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_freeD</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>bp</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>bs</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Bhdr (s_addr bp) (e_addr bs)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Bhdr (s_addr b) (e_addr bs)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_block_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b_size bp&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>all_blocks_def</span><span> </span><span>b_size.simps</span><span> </span><span>bhdr_t.exhaust_sel</span><span> </span><span>diff_Suc_Suc</span><span> </span><span>diff_zero</span><span> </span><span>le_Suc_eq</span><span> </span><span>le_add_diff_inverse</span><span> </span><span>plus_1_eq_Suc</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Un_iff</span><span> </span><span>add.left_neutral</span><span> </span><span>add_Suc</span><span> </span><span>all_blocks_def</span><span> </span><span>b_size.simps</span><span> </span><span>bhdr_t.exhaust_sel</span><span> </span><span>le_Suc_eq</span><span> </span><span>le_add_diff_inverse</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b_size b&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>all_blocks_def</span><span> </span><span>b_size.simps</span><span> </span><span>bhdr_t.exhaust_sel</span><span> </span><span>diff_Suc_Suc</span><span> </span><span>diff_zero</span><span> </span><span>le_Suc_eq</span><span> </span><span>le_add_diff_inverse</span><span> </span><span>plus_1_eq_Suc</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Un_iff</span><span> </span><span>add.left_neutral</span><span> </span><span>add_Suc</span><span> </span><span>all_blocks_def</span><span> </span><span>b_size.simps</span><span> </span><span>bhdr_t.exhaust_sel</span><span> </span><span>le_Suc_eq</span><span> </span><span>le_add_diff_inverse</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>free_addr_alloced</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10627;&#955;&#963;&#39;. &#963;=&#963;&#39; &#8743; inv &#963;&#39; &#8743; block_alloced addr &#963; &#10628; free addr  
  &#10627;&#955;x &#963;&#39;. 
    let b = get_alloced_block addr &#963; in
    alloced_bhdr_s &#963;  = alloced_bhdr_s &#963;&#39; &#8746; {b} &#8743;
    (prev_free_hdr_s conf b &#963; = None &#8743; suc_hdr_free_s conf b &#963; = None &#10230; free_blocks conf &#963;&#39; = free_blocks conf &#963; &#8746; {b}) &#8743;
    (prev_free_hdr_s conf b &#963; &#8800; None &#8743; suc_hdr_free_s conf b &#963; = None &#10230; 
      free_blocks conf &#963;&#39; &#8746; {the (prev_free_hdr_s conf b &#963;)} = free_blocks conf &#963; &#8746; {join_block (the (prev_free_hdr_s conf b &#963;)) b}) &#8743;
    (prev_free_hdr_s conf b &#963; = None &#8743; suc_hdr_free_s conf b &#963; &#8800; None &#10230; 
      free_blocks conf &#963;&#39; &#8746; {the (suc_hdr_free_s conf b &#963;)} = free_blocks conf &#963; &#8746; {join_block b (the (suc_hdr_free_s conf b &#963;))}) &#8743;
    (prev_free_hdr_s conf b &#963; &#8800; None &#8743; suc_hdr_free_s conf b &#963; &#8800; None &#10230; 
      free_blocks conf &#963;&#39; &#8746; {the (prev_free_hdr_s conf b &#963;)} &#8746; {the (suc_hdr_free_s conf b &#963;)} = 
      free_blocks conf &#963; &#8746; {join_block (the (prev_free_hdr_s conf b &#963;)) (join_block b (the (suc_hdr_free_s conf b &#963;)))})&#10628;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_def</span><span> </span><span>join_prev_def</span><span> </span><span>join_suc_def</span><span> </span><span>join_block_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>wp</span><span> </span><span class="delimiter">|</span><span> </span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>prod_injects</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="comment">&#8213;&#8249;case 1&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span> </span><span>add_block_def</span><span>
</span><span>                  </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>get_alloced_is_alloced</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insert_is_union_conf</span><span> </span><span>free_blk_mat_s_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="comment">&#8213;&#8249;case 2&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_block_def</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>inv_def</span><span>
</span><span>                  </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>get_alloced_is_alloced</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span> </span><span>Let_def</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>inv_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>insert_is_union_conf</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>remove_is_minus_conf</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_freeD</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>free_blocks_in_matrix</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>prev_freeD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="comment">&#8213;&#8249;case 3&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prev_free_hdr_s conf (get_alloced_block addr s) s = None&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_block_def</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>inv_def</span><span>
</span><span>                  </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>get_alloced_is_alloced</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span> </span><span>Let_def</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>inv_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>insert_is_union_conf</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>remove_is_minus_conf</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>suc_freeD</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>free_blocks_in_matrix</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>suc_freeD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_none_equiv2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_none_equiv3</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>suc_freeD</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>inv_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>add_Suc_right</span><span> </span><span>add_leD1</span><span> </span><span>all_blocks_def</span><span> </span><span>not_less_eq_eq</span><span> </span><span>wf_def</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="comment">&#8213;&#8249;case 4&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;y. prev_free_hdr_s conf (get_alloced_block addr s) s = Some y&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_block_def</span><span> </span><span>remove_elem_from_matrix_def</span><span> </span><span>inv_def</span><span>
</span><span>                  </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>get_alloced_is_alloced</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bs</span><span> </span><span>bp&#39;</span><span> </span><span>bp</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bp&#39; = bp&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hypsubst_thin</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_ = Some bp&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_block_def</span><span> </span><span>Let_def</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>free4</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>prev_freeD</span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span>inv_def</span><span>
</span><span>                       </span><span>dest</span><span class="delimiter">:</span><span> </span><span>prev_freeD</span><span> </span><span>suc_freeD</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>free_blocks_in_matrix</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_alloced_is_alloced</span><span>
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UnI2</span><span> </span><span>all_blocks_def</span><span> </span><span>wf_def</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_some_equiv2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_some_equiv3</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_memory_set_def</span><span>
</span><span>                       </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>suc_freeD</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_n_not_le_n</span><span> </span><span>Un_iff</span><span> </span><span>add.commute</span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_memory_set_def</span><span> 
</span><span>               </span><span>get_alloced_is_alloced</span><span> </span><span>le_cases</span><span> </span><span>le_trans</span><span> </span><span>wf_def</span><span> </span><span>trans_le_add2</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_some_equiv2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>prev_free_some_equiv3</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_def</span><span> </span><span>wf_def</span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_memory_set_def</span><span>
</span><span>                     </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>suc_freeD</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_n_not_le_n</span><span> </span><span>Un_iff</span><span> </span><span>add.commute</span><span> </span><span>all_blocks_def</span><span> </span><span>disjoint_memory_set_def</span><span> 
</span><span>             </span><span>get_alloced_is_alloced</span><span> </span><span>le_cases</span><span> </span><span>le_trans</span><span> </span><span>wf_def</span><span> </span><span>trans_le_add2</span><span> </span><span>wf_block_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;undefined = undefined&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* lemma hfree:&quot;(&#8708;b. b &#8712; alloced_bhdr_s s &#8743; s_addr b = addr) &#10231; &#172;block_alloced addr s&quot;
  unfolding block_alloced_def 
  apply auto
  by (metis bhdr_t.collapse)

 lemma free_addr_not_alloced:
 &quot;&#10627;(&#955;&#963;&#39;. (&#963;&#39;=&#963; &#8743; inv &#963; &#8743; (&#8708;b. b &#8712; alloced_bhdr_s &#963; &#8743;  s_addr b = addr)))&#10628;
     (free addr)
  &#10627;&#955;x &#963;&#39;. x=undefined &#8743; &#963;&#39; = undefined &#10628;&quot;
  unfolding free_def join_prev_def join_suc_def join_block_def Let_def
  apply (wp | split prod.splits, intro allI impI, drule prod_injects(2), erule conjE, clarsimp)+
  apply (split if_splits)
  apply rule
  subgoal
    apply rule
    using hfree by simp
  subgoal
    by auto
  done *)</span></span></span></span></span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
